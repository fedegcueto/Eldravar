<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Eldravar: Chronicle of the Lost King (v2.6 - LargeMap Fix)</title> <!-- Versión Corregida -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

<style>
    /* === Variables CSS y Estilos Base (v2.6) === */
    :root {
        --font-primary: 'Cinzel', serif;
        --font-secondary: 'Roboto', sans-serif;
        --color-primary: #e0c25e; /* Dorado */
        --color-secondary: #b89b40; /* Dorado más oscuro */
        --color-text: #e8e8e8; /* Gris claro */
        --color-text-muted: #a0a0a0; /* Gris medio */
        --color-text-dark: #333; /* Gris oscuro para fondos claros */
        --color-bg-dark: rgba(10, 10, 10, 0.92); /* Fondo más oscuro */
        --color-bg-medium: rgba(30, 30, 30, 0.95); /* Fondo medio */
        --color-bg-light: rgba(50, 50, 50, 0.9); /* Fondo más claro */
        --color-border: rgba(200, 180, 100, 0.3); /* Borde dorado tenue */
        --color-border-light: rgba(200, 180, 100, 0.2); /* Borde dorado más tenue */
        --color-health: #e74c3c; /* Rojo */
        --color-mana: #3498db; /* Azul */
        --color-stamina: #2ecc71; /* Verde */
        --color-ghost: #a29bfe; /* Azul/Púrpura fantasmal */
        --color-xp: var(--color-primary);
        --color-danger: #e74c3c; /* Rojo */
        --color-success: #2ecc71; /* Verde */
        --color-info: #3498db; /* Azul */
        --color-warning: #f1c40f; /* Amarillo */
        --color-quest: var(--color-primary);
        --color-system: #bdc3c7; /* Plata claro */
        --color-loot: var(--color-success);
        --color-combat: var(--color-danger);
        --color-magic: var(--color-mana);
        --color-poison: #9b59b6; /* Púrpura */
        --color-fire: #e67e22; /* Naranja */
        --color-ice: #34e7e7; /* Cian */
        --color-shadow: #581845; /* Púrpura oscuro */
        --color-bleed: #c0392b; /* Rojo oscuro */
        --rarity-common: #ffffff;
        --rarity-uncommon: #1eff00;
        --rarity-rare: #0070dd;
        --rarity-epic: #a335ee;
        --rarity-legendary: #ff8000;
        --rarity-quest: var(--color-quest);
        /* Colores para texto flotante */
        --color-damage: #ffffff; /* Daño normal */
        --color-critical: #ff9900; /* Crítico */
        --color-heal: var(--color-success); /* Curación */
        --color-miss: #bdc3c7; /* Fallo */
        --color-parry: #f1c40f; /* Amarillo Parry */
        --color-meditate: #94d3ff; /* Azul claro para meditación */
        --color-poison-text: var(--color-poison); /* Renamed for clarity */
        /* XP y Mana ya definidos (--color-xp, --color-mana) */
        /* Logos Redes Sociales */
        --color-instagram: #E1306C;
        --color-linkedin: #0A66C2;
        --color-github: #e8e8e8; /* Blanco/Gris claro */
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; /* Evitar scrollbars */ }

    body {
        margin: 0; padding: 0; font-family: var(--font-secondary);
        background-color: #000; color: var(--color-text);
        display: flex; font-size: 14px; cursor: default; /* Cursor predeterminado */
        -webkit-touch-callout: none; /* Deshabilitar callouts en iOS */
        -webkit-user-select: none; /* Deshabilitar selección texto */
        -moz-user-select: none; -ms-user-select: none; user-select: none;
        -webkit-tap-highlight-color: transparent; /* Quitar highlight azul en móvil */
    }
    body.targeting { cursor: crosshair !important; } /* Cursor para apuntar */
    #game-canvas.targeting { cursor: crosshair !important; } /* Asegurar en canvas también */

    button, input { font-family: inherit; font-size: inherit; color: inherit; }
    button { cursor: pointer; border: none; background: none; }
    ul { list-style: none; }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 4px; }
    ::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.25); border-radius: 4px; border: 2px solid transparent; background-clip: content-box; }
    ::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.4); }

    /* === Elementos Canvas === */
    canvas#game-canvas { display: block; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 0; }
    canvas#particle-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }

    /* === Efecto Fantasma del Jugador === */
    .player-ghost-effect .mesh-material { opacity: 0.6 !important; filter: grayscale(0.5) contrast(1.2); }
    #health-bar.ghost-mode { background: linear-gradient(to right, #6c5ce7, var(--color-ghost)) !important; box-shadow: 0 0 7px var(--color-ghost) !important; }

    /* === Barra lateral y Componentes UI === */
    #sidebar {
        position: absolute; top: 0; right: 0; width: 320px; height: 100vh;
        background-color: var(--color-bg-dark); backdrop-filter: blur(8px);
        border-left: 1px solid var(--color-border); z-index: 100;
        display: none; flex-direction: column; padding: 10px; pointer-events: auto;
        font-family: var(--font-primary); color: var(--color-text-muted);
        transition: right 0.3s ease-in-out;
    }

    /* Info Jugador y XP Bar */
    #player-info { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 15px; color: var(--color-primary); font-weight: bold; flex-shrink: 0; }
    .stat-bar { height: 16px; background-color: rgba(0,0,0,0.7); margin-bottom: 6px; border-radius: 8px; overflow: hidden; position: relative; box-shadow: inset 0 1px 3px rgba(0,0,0,0.6); border: 1px solid rgba(0,0,0,0.4); flex-shrink: 0; }
    #xp-bar { height: 100%; transition: width 0.25s ease-out; border-radius: 8px; background: linear-gradient(to right, var(--color-secondary), var(--color-primary)); box-shadow: 0 0 6px var(--color-primary); }

    /* --- Minimapa --- */
    #minimap-container { padding: 8px 0; border-top: 1px solid var(--color-border-light); border-bottom: 1px solid var(--color-border); margin-top: 5px; text-align: center; cursor: pointer; transition: transform 0.2s ease; flex-shrink: 0; }
    #minimap-container:hover { transform: scale(1.05); filter: brightness(1.1); }
    #minimap-canvas { width: 140px; height: 140px; border-radius: 50%; border: 3px solid var(--color-secondary); background-color: #080808; box-shadow: 0 0 10px rgba(0,0,0,0.5), inset 0 0 8px rgba(0,0,0,0.4); image-rendering: pixelated; }

    /* === Estructura Sidebar Modificada === */
    #tabs-container { display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; max-height: 45vh; min-height: 150px; margin-bottom: 10px; flex-shrink: 0; }
    .tabs-header { display: flex; border-bottom: 1px solid var(--color-border); flex-wrap: nowrap; flex-shrink: 0; }
    .tab-button { flex-grow: 1; padding: 8px 5px; text-align: center; background: none; cursor: pointer; transition: all 0.2s ease; border: none; color: var(--color-text-muted); font-family: var(--font-primary); font-size: 12px; border-bottom: 2px solid transparent; margin-bottom: -1px; white-space: nowrap; }
    .tab-button:hover { color: var(--color-text); }
    .tab-button.active { color: var(--color-primary); border-bottom-color: var(--color-primary); }
    .tab-content { display: none; flex: 1; overflow-y: auto; padding: 10px 5px 10px 10px; min-height: 0; }
    .tab-content.active { display: flex; flex-direction: column; }

    /* Botones de Acción (Equipar/Usar/Soltar) */
    #action-buttons { display: flex; padding-top: 10px; border-top: 1px solid var(--color-border-light); margin-top: 0; margin-bottom: 10px; gap: 5px; flex-shrink: 0; }
    .action-button { background-color: var(--color-bg-light); color: var(--color-text); border: 1px solid var(--color-border); padding: 8px; border-radius: 3px; cursor: pointer; transition: all 0.15s ease; flex: 1; font-family: var(--font-primary); font-size: 13px; text-shadow: 1px 1px 1px #000; font-weight: bold; }
    .action-button:hover:not(:disabled) { background-color: rgba(80,80,80,0.9); border-color: var(--color-primary); color: var(--color-primary); }
    .action-button:active:not(:disabled) { transform: translateY(1px); background-color: rgba(40,40,40,0.9); }
    .action-button:disabled { opacity: 0.4; cursor: not-allowed; background-color: rgba(30,30,30,0.7); border-color: rgba(100,100,100,0.3); color: #666; }

    /* Botones Modales en Sidebar */
    #sidebar-modal-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 0; margin-bottom: 10px; padding-top: 10px; border-top: 1px solid var(--color-border-light); flex-shrink: 0; }
    .sidebar-action-button { background-color: var(--color-bg-light); color: var(--color-text-muted); border: 1px solid var(--color-border); padding: 7px 5px; border-radius: 3px; cursor: pointer; transition: all 0.2s ease; font-family: var(--font-primary); font-size: 11px; display: flex; align-items: center; justify-content: center; gap: 5px; text-shadow: 1px 1px 1px #000; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sidebar-action-button i { font-size: 13px; opacity: 0.8; flex-shrink: 0; margin-right: 2px; }
    .sidebar-action-button:hover { background-color: rgba(80,80,80,0.9); border-color: var(--color-primary); color: var(--color-primary); }
    .sidebar-action-button:active:not(:disabled) { transform: translateY(1px); background-color: rgba(40,40,40,0.9); }
    .sidebar-action-button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Contenedor Barras Recursos (Salud, Mana, Stamina) */
    #resource-bars-container { margin-top: 0; padding-top: 10px; border-top: 1px solid var(--color-border-light); margin-bottom: 10px; flex-shrink: 0; }
    #resource-bars-container .stat-bar.low-health #health-bar { /* NEW: Low health flash */
        animation: pulseRed 1s infinite alternate;
    }
    @keyframes pulseRed { from { box-shadow: 0 0 6px var(--color-danger); } to { box-shadow: 0 0 12px #ff0000, 0 0 4px #fff; } }

    #health-bar, #mana-bar, #stamina-bar { height: 100%; transition: width 0.25s ease-out; border-radius: 8px; }
    #health-bar { background: linear-gradient(to right, #a13333, var(--color-health)); box-shadow: 0 0 6px var(--color-health); }
    #mana-bar { background: linear-gradient(to right, #2c5364, var(--color-mana)); box-shadow: 0 0 6px var(--color-mana); }
    #stamina-bar { background: linear-gradient(to right, #1a6333, var(--color-stamina)); box-shadow: 0 0 6px var(--color-stamina); }
    .stat-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 10px; font-weight: bold; color: rgba(255,255,255,0.85); text-shadow: 1px 1px 2px #000; pointer-events: none; white-space: nowrap; }

    /* Efectos de Estado */
    #status-effects-bar { margin-top: 8px; min-height: 16px; font-size: 13px; display: flex; gap: 5px; flex-wrap: wrap; flex-shrink: 0; padding-bottom: 5px; margin-top: auto; }
    #status-effects-bar i { opacity: 0.8; transition: opacity 0.2s; cursor: help; position: relative; }
    #status-effects-bar i:hover { opacity: 1; }
    .status-poison { color: var(--color-poison); } .status-burn { color: var(--color-fire); } .status-slow { color: var(--color-ice); } .status-regen { color: var(--color-success); } .status-buff { color: var(--color-primary); } .status-debuff { color: var(--color-danger); } .status-weakened { color: #7f8c8d; } .status-fatigued { color: #e67e22; } .status-bleed { color: var(--color-bleed); } .status-stun { color: var(--color-warning); } .status-shield { color: var(--color-info); } .status-ghost { color: var(--color-ghost); }
    .status-staggered, .status-stun, .status-paralysis { color: var(--color-warning); }
    .status-root { color: #556B2F; } /* Dark Olive Green for Root */
    .status-invisibility { color: #7f8c8d; } /* Grey for invisible */

    /* === Tooltips === */
    .tooltip { position: fixed; background-color: rgba(15,15,15,0.97); color: #fff; padding: 8px 12px; border-radius: 4px; font-size: 11px; white-space: normal; width: auto; max-width: 260px; z-index: 150; display: none; border: 1px solid var(--color-border); font-family: var(--font-secondary); pointer-events: none; box-shadow: 0 3px 10px rgba(0,0,0,0.4); line-height: 1.4; }
    .tooltip .tooltip-section { margin-bottom: 5px; padding-bottom: 5px; border-bottom: 1px dashed var(--color-border-light); }
    .tooltip .tooltip-section:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
    .tooltip .name-tooltip { font-weight: bold; margin-bottom: 4px; display: block; font-size: 13px; }
    .tooltip .type-tooltip { font-size: 10px; color: var(--color-text-muted); display: block; margin-bottom: 3px; text-transform: capitalize; }
    .tooltip .desc-tooltip { color: var(--color-text-muted); margin-top: 4px; display: block; font-size: 10px; }
    .tooltip .stats-tooltip { color: #88cfff; margin-top: 5px; font-size: 10px; display: block; padding-top: 4px; line-height: 1.3; }
    .tooltip .stats-tooltip span { display: block; margin-bottom: 2px; }
    .tooltip .value-tooltip, .tooltip .cost-tooltip { color: var(--color-primary); margin-top: 4px; font-size: 10px; display: block; }
    .tooltip .duration-tooltip, .tooltip .cooldown-tooltip { color: #aaa; margin-top: 2px; font-size: 10px; display: block; }
    .tooltip .details-tooltip { color: #88cfff; margin-top: 5px; font-size: 10px; display: block; padding-top: 4px; line-height: 1.3; }
    .tooltip .item-name-common { color: var(--rarity-common); } .tooltip .item-name-uncommon { color: var(--rarity-uncommon); } .tooltip .item-name-rare { color: var(--rarity-rare); } .tooltip .item-name-epic { color: var(--rarity-epic); } .tooltip .item-name-legendary { color: var(--rarity-legendary); } .tooltip .item-name-quest { color: var(--rarity-quest); }
    .tooltip .comparison-tooltip { margin-top: 6px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 5px; font-size: 10px; }
    .tooltip .comparison-tooltip span { display: inline-block; margin-right: 5px; }
    .tooltip .comparison-better { color: var(--color-success); } .tooltip .comparison-worse { color: var(--color-danger); }
    .tooltip .skill-level-tooltip { color: #88cfff; margin-top: 5px; font-size: 10px; } .tooltip .skill-xp-tooltip { font-size: 9px; color: var(--color-xp); margin-top: 3px; } .tooltip .skill-bonuses-tooltip { color: var(--color-success); font-size: 10px; margin-top: 4px; }
    .tooltip .recipe-name-tooltip { color: var(--color-primary); } .tooltip .recipe-result-tooltip { color: var(--color-text); font-size: 10px; } .tooltip .recipe-mats-tooltip { font-size: 9px; color: var(--color-text-muted); margin-top: 3px; } .tooltip .recipe-mats-tooltip span { margin-right: 4px; display: inline-block; } .tooltip .recipe-mats-tooltip .has-mats { color: var(--color-success); } .tooltip .recipe-mats-tooltip .no-mats { color: var(--color-danger); } .tooltip .recipe-skill-tooltip { font-size: 10px; margin-top: 4px; } .tooltip .recipe-skill-tooltip.req-met { color: var(--color-success); } .tooltip .recipe-skill-tooltip.req-not-met { color: var(--color-danger); }
    .tooltip .spell-name-tooltip { color: var(--color-magic); } .tooltip .status-name-tooltip { color: var(--color-primary); }

    /* === Pestaña de Inventario === */
    #inventory-grid { display: grid; grid-template-columns: repeat(5, 1fr); grid-auto-rows: minmax(0, 1fr); gap: 4px; margin-bottom: 8px; }
    .inventory-slot { background-color: var(--color-bg-light); border-radius: 3px; border: 1px solid var(--color-border-light); display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; transition: border-color 0.2s ease, transform 0.1s ease; aspect-ratio: 1 / 1; overflow: hidden; }
    .inventory-slot:hover { border-color: var(--color-text-muted); transform: scale(1.03); z-index: 10; }
    .inventory-slot.selected { border-color: var(--color-primary); box-shadow: 0 0 6px var(--color-primary); transform: scale(1.05); }
    .inventory-item { font-size: 20px; width: 90%; height: 90%; object-fit: contain; pointer-events: none; user-select: none; display: flex; justify-content: center; align-items: center; }
    .inventory-item img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; }
    .item-count { position: absolute; bottom: 1px; right: 2px; background-color: rgba(0,0,0,0.8); padding: 0 3px; border-radius: 2px; font-size: 9px; font-weight: bold; line-height: 1.1; pointer-events: none; color: white; z-index: 1; }
    .inventory-slot.item-rarity-common { border-color: var(--color-border-light); } .inventory-slot.item-rarity-uncommon { border: 1px solid var(--rarity-uncommon); } .inventory-slot.item-rarity-rare { border: 1px solid var(--rarity-rare); } .inventory-slot.item-rarity-epic { border: 1px solid var(--rarity-epic); } .inventory-slot.item-rarity-legendary { border: 1px solid var(--rarity-legendary); } .inventory-slot.item-rarity-quest { border: 1px solid var(--rarity-quest); }

    /* === Pestaña de Hechizos === */
    #spells-list { display: flex; flex-direction: column; gap: 5px; }
    .spell-item { background-color: var(--color-bg-light); border-radius: 3px; border: 1px solid var(--color-border-light); padding: 6px 8px; display: flex; align-items: center; cursor: pointer; transition: all 0.2s ease; position: relative; }
    .spell-item:hover { background-color: rgba(70,70,70,0.9); border-color: var(--color-text-muted); transform: translateX(3px); }
    .spell-item.selected { border-color: var(--color-primary); box-shadow: 0 0 6px var(--color-primary); }
    .spell-icon { font-size: 18px; margin-right: 8px; width: 20px; height: 20px; text-align: center; color: var(--color-primary); display: flex; align-items: center; justify-content: center;}
    .spell-icon img { max-width: 100%; max-height: 100%; object-fit: contain; }
    .spell-info { flex: 1; }
    .spell-name { font-weight: bold; margin-bottom: 2px; font-size: 13px; color: var(--color-text); font-family: var(--font-primary); }
    .spell-cost-cd { font-size: 9px; color: var(--color-text-muted); display: flex; justify-content: space-between; }
    .spell-cost { color: var(--color-mana); }
    .spell-cooldown { color: #aaa; }
    .spell-cooldown.on-cooldown { color: var(--color-warning); }
    .spell-cooldown-overlay { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background-color: rgba(0,0,0,0.65); pointer-events: none; border-radius: 0 0 3px 3px; transition: height 0.1s linear; }

    /* === Contenido Modal Equipo === */
    #equipment-modal #equipment-slots { display: grid; grid-template-areas: ". head ." "amulet chest weapon" "ring1 legs ring2" ". feet ."; grid-template-columns: 65px 65px 65px; grid-template-rows: auto auto auto auto; gap: 6px; justify-content: center; margin-top: 15px; margin-bottom: 15px; }
    #equipment-modal .equipment-slot { background-color: rgba(0,0,0,0.4); border: 1px dashed var(--color-text-muted); border-radius: 3px; aspect-ratio: 1; display: flex; justify-content: center; align-items: center; font-size: 18px; color: var(--color-text-muted); cursor: pointer; position: relative; transition: all 0.2s ease; }
    #equipment-modal .equipment-slot:hover { border-color: var(--color-primary); background-color: rgba(20,20,20,0.5); }
    #equipment-modal .equipment-slot .inventory-item { font-size: 26px; }
    #equipment-modal .equipment-slot.item-rarity-common { border-style: solid; border-color: var(--color-border-light); } #equipment-modal .equipment-slot.item-rarity-uncommon { border-style: solid; border-color: var(--rarity-uncommon); } #equipment-modal .equipment-slot.item-rarity-rare { border-style: solid; border-color: var(--rarity-rare); } #equipment-modal .equipment-slot.item-rarity-epic { border-style: solid; border-color: var(--rarity-epic); } #equipment-modal .equipment-slot.item-rarity-legendary { border-style: solid; border-color: var(--rarity-legendary); } #equipment-modal .equipment-slot.item-rarity-quest { border-style: solid; border-color: var(--rarity-quest); }
    #equipment-modal #slot-head { grid-area: head; } #equipment-modal #slot-amulet { grid-area: amulet; } #equipment-modal #slot-chest { grid-area: chest; } #equipment-modal #slot-weapon { grid-area: weapon; } #equipment-modal #slot-legs { grid-area: legs; } #equipment-modal #slot-ring1 { grid-area: ring1; } #equipment-modal #slot-ring2 { grid-area: ring2; } #equipment-modal #slot-feet { grid-area: feet; }

    /* === Contenido Modal Misiones === */
    #quests-modal #quest-log { display: flex; flex-direction: column; gap: 6px; flex-grow: 1; overflow-y: auto; padding: 5px; min-height: 150px; }
    #quests-modal .quest-empty { color: var(--color-text-muted); font-style: italic; text-align: center; margin-top: 15px; }
    #quests-modal .quest-section-header { font-size: 10px; color: var(--color-secondary); text-transform: uppercase; margin-top: 12px; padding-bottom: 2px; border-bottom: 1px solid var(--color-border-light); }
    #quests-modal .quest-entry { background: rgba(15,15,15,0.6); padding: 7px 9px; border-radius: 3px; border-left: 3px solid var(--color-quest); font-size: 11px; font-family: var(--font-secondary); cursor: pointer; transition: background-color 0.2s; }
    #quests-modal .quest-entry.completed { border-left-color: #666; opacity: 0.7; }
    #quests-modal .quest-entry:hover { background-color: rgba(30,30,30,0.7); }
    #quests-modal .quest-title { font-weight: bold; color: var(--color-primary); margin-bottom: 3px; font-size: 13px; font-family: var(--font-primary); display: flex; justify-content: space-between; align-items: center; }
    #quests-modal .quest-entry.completed .quest-title { color: #888; }
    #quests-modal .quest-level { font-size: 10px; color: var(--color-text-muted); }
    #quests-modal .quest-details { display: none; padding-top: 4px; border-top: 1px dashed var(--color-border-light); margin-top: 4px; }
    #quests-modal .quest-entry.active .quest-details { display: block; }
    #quests-modal .quest-description { font-size: 10px; color: var(--color-text-muted); margin-bottom: 5px; line-height: 1.4; }
    #quests-modal .quest-objective { color: var(--color-text); margin-left: 8px; font-size: 10px; padding-left: 10px; position: relative; margin-top: 2px; }
    #quests-modal .quest-objective::before { content: ''; position: absolute; left: 0; top: 4px; width: 5px; height: 5px; background: var(--color-text-muted); border-radius: 50%; }
    #quests-modal .quest-objective.completed { text-decoration: line-through; color: #666; }
    #quests-modal .quest-objective.completed::before { background: var(--color-success); }
    #quests-modal .quest-rewards { font-size: 9px; color: var(--color-secondary); margin-top: 5px; border-top: 1px dashed var(--color-border-light); padding-top: 4px; }
    #quests-modal .quest-track-button { background: rgba(255,255,255,0.08); color: #aaa; border: 1px solid rgba(255,255,255,0.15); padding: 2px 6px; font-size: 9px; border-radius: 3px; cursor: pointer; margin-left: 10px; transition: all 0.2s; }
    #quests-modal .quest-track-button:hover { background: rgba(255,255,255,0.15); color: #fff; border-color: #fff; }
    #quests-modal .quest-track-button.tracking { background: var(--color-success); color: #111; border-color: var(--color-success); font-weight: bold; }

    /* === Contenido Modal Habilidades === */
    #skills-modal .skills-content-wrapper { padding: 10px; display: flex; flex-direction: column; gap: 8px; }
    #skills-modal #skill-points-info { font-size: 11px; color: var(--color-warning); text-align: center; margin-bottom: 8px; }
    #skills-modal #skills-list { display: flex; flex-direction: column; gap: 6px; font-family: var(--font-secondary); }
    #skills-modal .skill-entry { background: rgba(20,20,20,0.5); padding: 7px; border-radius: 3px; border-left: 3px solid var(--color-secondary); position: relative; cursor: help; }
    #skills-modal .skill-name-level { display: flex; justify-content: space-between; align-items: center; margin-bottom: 3px; }
    #skills-modal .skill-name { font-weight: bold; color: var(--color-text); font-size: 12px; }
    #skills-modal .skill-level { font-size: 11px; color: var(--color-primary); font-weight: bold; margin-left: auto; }
    #skills-modal .skill-alloc-button { background: var(--color-secondary); border: 1px solid var(--color-border); border-radius: 50%; width: 18px; height: 18px; line-height: 16px; text-align: center; font-size: 13px; font-weight: bold; color: #111; cursor: pointer; margin-left: 8px; padding: 0; transition: all 0.1s ease; display: inline-flex; justify-content: center; align-items: center; flex-shrink: 0; }
    #skills-modal .skill-alloc-button:hover:not(:disabled) { background: var(--color-primary); transform: scale(1.1); }
    #skills-modal .skill-alloc-button:disabled { background: #555; color: #888; cursor: not-allowed; transform: none; opacity: 0.5; }
    #skills-modal .skill-xp-bar-container { height: 5px; background: rgba(0,0,0,0.5); border-radius: 2.5px; overflow: hidden; margin-top: 2px; }
    #skills-modal .skill-xp-bar { height: 100%; background: var(--color-secondary); width: 0%; transition: width 0.3s ease; border-radius: 2.5px; }

    /* === Contenido Modal Fabricación === */
    #crafting-modal .crafting-content-wrapper { display: flex; flex-direction: column; gap: 10px; width: 100%; }
    #crafting-modal #recipe-list { max-height: 220px; overflow-y: auto; border: 1px solid var(--color-border-light); padding: 5px; border-radius: 3px; background-color: rgba(0,0,0,0.2); display: flex; flex-direction: column; gap: 4px; }
    #crafting-modal .recipe-item { background: var(--color-bg-light); padding: 5px 7px; border-radius: 2px; cursor: pointer; transition: background-color 0.2s; font-size: 11px; border: 1px solid transparent; display: flex; justify-content: space-between; align-items: center; position: relative; }
    #crafting-modal .recipe-item:hover { background: rgba(70,70,70,0.8); }
    #crafting-modal .recipe-item.selected { border-color: var(--color-primary); background: rgba(60,60,60,0.9); }
    #crafting-modal .recipe-item.cannot-craft { color: #888; }
    #crafting-modal .recipe-item .recipe-skill-req { font-size: 8px; color: var(--color-warning); margin-left: 8px; }
    #crafting-modal .recipe-item .recipe-skill-req.req-met { color: var(--color-success); }
    #crafting-modal #crafting-details { background: rgba(15,15,15,0.7); padding: 10px 12px; border-radius: 3px; min-height: 90px; border: 1px solid var(--color-border-light); }
    #crafting-modal #crafting-details h4 { font-size: 13px; color: var(--color-primary); margin-bottom: 8px; font-family: var(--font-primary); border-bottom: 1px dashed var(--color-border); padding-bottom: 5px; }
    #crafting-modal #crafting-materials { font-size: 11px; margin-bottom: 10px; line-height: 1.5; }
    #crafting-modal #crafting-materials span { margin-right: 8px; display: inline-block; }
    #crafting-modal #crafting-materials .has-mats { color: var(--color-success); }
    #crafting-modal #crafting-materials .no-mats { color: var(--color-danger); }
    #crafting-modal #crafting-description { font-size: 11px; color: var(--color-text-muted); margin-bottom: 10px; }
    #crafting-modal #craft-button { background-color: var(--color-secondary); color: #111; border: none; font-weight: bold; margin-top: 8px; width: 100%; padding: 8px; border-radius: 3px; cursor: pointer; transition: all 0.15s ease; font-family: var(--font-primary); font-size: 13px; text-shadow: 0 0 3px rgba(255,255,255,0.4); }
    #crafting-modal #craft-button:hover:not(:disabled) { background-color: var(--color-primary); }
    #crafting-modal #craft-button:disabled { background-color: #444; color: #888; cursor: not-allowed; }

    /* === Contenedor UI y Notificaciones === */
    #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
    #notification-container { position: absolute; bottom: 120px; left: 15px; width: 350px; max-width: calc(100% - 360px); z-index: 100; }
    .notification { background-color: var(--color-bg-medium); margin-bottom: 6px; padding: 7px 10px; border-radius: 3px; border-left: 3px solid #fff; animation: slideInUp 0.3s ease-out, fadeOutDown 0.3s var(--notification-duration, 3.7s) forwards; box-shadow: 0 2px 4px rgba(0,0,0,0.4); backdrop-filter: blur(3px); font-size: 12px; color: var(--color-text); font-family: var(--font-secondary); pointer-events: auto; }
    .notification.success { border-left-color: var(--color-success); } .notification.error { border-left-color: var(--color-danger); } .notification.warning { border-left-color: var(--color-warning); } .notification.info { border-left-color: var(--color-info); } .notification.quest { border-left-color: var(--color-quest); } .notification.loot { border-left-color: var(--color-loot); }
    @keyframes slideInUp { from { opacity: 0; transform: translateY(15px) } to { opacity: 1; transform: translateY(0) } }
    @keyframes fadeOutDown { from { opacity: 1; transform: translateY(0) } to { opacity: 0; transform: translateY(15px) } }
    #message-log-container { position: absolute; top: 10px; left: 10px; width: 400px; height: 120px; background-color: rgba(0,0,0,0.75); border: 1px solid var(--color-border-light); border-radius: 4px; z-index: 90; pointer-events: auto; display: flex; flex-direction: column; opacity: 0.85; }
    #message-log-tabs { display: flex; border-bottom: 1px solid var(--color-border-light); flex-shrink: 0; }
    .message-log-tab { padding: 3px 6px; cursor: pointer; font-size: 9px; color: var(--color-text-muted); background: rgba(0,0,0,0.3); border-right: 1px solid var(--color-border-light); flex-grow: 1; text-align: center; }
    .message-log-tab:last-child { border-right: none; }
    .message-log-tab:hover { background: rgba(20,20,20,0.4); color: var(--color-text); }
    .message-log-tab.active { background: rgba(30,30,30,0.5); color: var(--color-primary); }
    #message-log { flex-grow: 1; padding: 5px 8px; overflow-y: scroll; font-size: 11px; line-height: 1.4; display: flex; flex-direction: column-reverse; font-family: var(--font-secondary); }
    #message-log::-webkit-scrollbar { width: 6px; } #message-log::-webkit-scrollbar-thumb { background-color: rgba(255,255,255,0.15); } #message-log::-webkit-scrollbar-thumb:hover { background-color: rgba(255,255,255,0.3); }
    .log-message { margin-bottom: 2px; word-break: break-word; }
    .log-message.combat { color: var(--color-combat); } .log-message.system { color: var(--color-system); } .log-message.loot { color: var(--color-loot); } .log-message.info { color: var(--color-info); } .log-message.quest { color: var(--color-quest); font-weight: bold; } .log-message.magic { color: var(--color-magic); } .log-message.warning { color: var(--color-warning); } .log-message.error { color: var(--color-danger); font-weight: bold; }
    #message-log-container[data-filter="system"] .log-message:not(.system), #message-log-container[data-filter="combat"] .log-message:not(.combat):not(.error):not(.warning), #message-log-container[data-filter="loot"] .log-message:not(.loot), #message-log-container[data-filter="quest"] .log-message:not(.quest) { display: none !important; }
    .modal-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 8px; padding: 20px; padding-top: 45px; z-index: 1005; display: none; pointer-events: auto; box-shadow: 0 8px 25px rgba(0,0,0,0.7); backdrop-filter: blur(6px); color: var(--color-text); font-family: var(--font-secondary); max-height: 85vh; overflow-y: auto; flex-direction: column; }
    .modal-panel.active { display: flex; }
    .modal-title { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); font-family: var(--font-primary); color: var(--color-primary); font-size: 18px; }
    .modal-close-button { position: absolute; top: 10px; right: 12px; background: none; border: none; color: var(--color-text-muted); font-size: 28px; cursor: pointer; line-height: 1; padding: 0 5px; transition: color 0.2s ease, transform 0.1s ease; }
    .modal-close-button:hover { color: var(--color-primary); transform: scale(1.1); }
    #equipment-modal { width: clamp(280px, 40%, 400px); align-items: center; }
    #equipment-modal #equipment-slots { margin-top: 15px; margin-bottom: 15px; }
    #crafting-modal { width: clamp(350px, 55%, 550px); }
    #quests-modal { width: clamp(400px, 60%, 650px); }
    #quests-modal #quest-log { flex-grow: 1; overflow-y: auto; padding: 5px; min-height: 150px; }
    #skills-modal { width: clamp(350px, 50%, 500px); }
    #skills-modal .skills-content-wrapper { padding: 10px; display: flex; flex-direction: column; gap: 8px; }
    #options-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: clamp(350px, 60%, 550px); background-color: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 8px; padding: 25px 30px; z-index: 1010; display: none; pointer-events: auto; box-shadow: 0 8px 25px rgba(0,0,0,0.7); backdrop-filter: blur(8px); color: var(--color-text); font-family: var(--font-secondary); max-height: 85vh; overflow-y: auto; flex-direction: column; gap: 20px; }
    .options-title { font-family: var(--font-primary); color: var(--color-primary); margin-bottom: 5px; text-align: center; font-size: 20px; border-bottom: 1px solid var(--color-border-light); padding-bottom: 15px; }
    #close-options-button { position: absolute; top: 12px; right: 15px; background: none; border: none; color: var(--color-text-muted); font-size: 26px; cursor: pointer; line-height: 1; padding: 0; transition: color 0.2s ease; }
    #close-options-button:hover { color: var(--color-primary); }
        /* === Styles for New Options === */
    .option-checkbox {
        appearance: none;
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border: 1px solid var(--color-border);
        border-radius: 3px;
        background-color: rgba(0,0,0,0.4);
        cursor: pointer;
        position: relative;
        transition: background-color 0.2s;
    }
    .option-checkbox:checked {
        background-color: var(--color-primary);
        border-color: var(--color-secondary);
    }
    .option-checkbox:checked::after {
        content: '\f00c'; /* Font Awesome check icon */
        font-family: 'Font Awesome 6 Free';
        font-weight: 900;
        font-size: 12px;
        color: #111;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
     .option-checkbox:hover {
          border-color: var(--color-text-muted);
     }

    .option-select {
        background-color: var(--color-bg-light);
        border: 1px solid var(--color-border);
        color: var(--color-text);
        padding: 4px 8px;
        border-radius: 3px;
        cursor: pointer;
        min-width: 120px; /* Adjust as needed */
    }
    .option-select:hover {
         border-color: var(--color-text-muted);
    }
    /* === End Styles for New Options === */
    .options-section { background-color: rgba(0,0,0,0.2); border: 1px solid var(--color-border-light); border-radius: 5px; padding: 15px 20px; }
    .options-section h3 { font-family: var(--font-primary); font-size: 15px; color: var(--color-secondary); margin-bottom: 15px; border-bottom: 1px dashed var(--color-border-light); padding-bottom: 8px; display: flex; align-items: center; gap: 8px; }
    .options-section h3 i { color: var(--color-primary); opacity: 0.8; }
    .option-group { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; gap: 15px; }
    .option-group:last-child { margin-bottom: 5px; }
    .option-label { font-size: 13px; color: var(--color-text-muted); flex-shrink: 0; }
    .volume-slider { flex-grow: 1; cursor: pointer; appearance: none; -webkit-appearance: none; width: 100%; height: 6px; background: rgba(0,0,0,0.5); border-radius: 3px; outline: none; border: 1px solid rgba(255,255,255,0.1); }
    .volume-slider::-webkit-slider-thumb { appearance: none; -webkit-appearance: none; width: 16px; height: 16px; background: var(--color-primary); border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); cursor: pointer; transition: background-color 0.15s ease; }
    .volume-slider::-webkit-slider-thumb:hover { background: var(--color-secondary); box-shadow: 0 0 5px var(--color-primary); }
    .volume-slider::-moz-range-thumb { width: 15px; height: 15px; background: var(--color-primary); border-radius: 50%; border: 1px solid rgba(0,0,0,0.5); cursor: pointer; transition: background-color 0.15s ease; }
    .volume-slider::-moz-range-thumb:hover { background: var(--color-secondary); box-shadow: 0 0 5px var(--color-primary); }
    .slider-value { font-size: 12px; color: var(--color-text); min-width: 40px; text-align: right; font-weight: bold; }
    .options-button { width: auto; padding: 8px 20px; margin-top: 15px; align-self: center; min-width: 150px; background-color: var(--color-bg-light); color: var(--color-text); border: 1px solid var(--color-border); font-family: var(--font-primary); }
    .options-button:hover { background-color: rgba(90,90,90,0.85); border-color: var(--color-primary); color: var(--color-primary); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    #large-map-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: clamp(400px, 70vw, 800px); height: clamp(400px, 80vh, 700px); background-color: rgba(20, 20, 25, 0.97); border: 2px solid var(--color-secondary); border-radius: 6px; padding: 20px; padding-top: 50px; z-index: 1005; display: none; pointer-events: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.8); backdrop-filter: blur(5px); color: var(--color-text); font-family: var(--font-secondary); flex-direction: column; }
    .large-map-title { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); font-family: var(--font-primary); color: var(--color-primary); font-size: 18px; }
    #close-large-map-button { position: absolute; top: 10px; right: 12px; background: none; border: none; color: var(--color-text-muted); font-size: 28px; cursor: pointer; line-height: 1; padding: 0 5px; transition: color 0.2s ease, transform 0.1s ease; }
    #close-large-map-button:hover { color: var(--color-primary); transform: scale(1.1); }
    #large-map-canvas-container { flex-grow: 1; width: 100%; background-color: rgba(0,0,0,0.4); border: 1px solid var(--color-border-light); border-radius: 4px; overflow: hidden; position: relative; display: flex; justify-content: center; align-items: center; cursor: grab; }
    #large-map-canvas-container:active { cursor: grabbing; }
    #large-map-canvas { display: block; image-rendering: pixelated; background-color: #050508; max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none; }
    .large-map-coords { text-align: center; font-size: 11px; color: var(--color-text-muted); margin-top: 10px; font-family: var(--font-secondary); }

    /* === Drop Item Panel v2 (Integrated Look) === */
    #drop-item-panel {
        width: clamp(280px, 80%, 340px); /* Responsive width */
        background-color: var(--color-bg-medium);
        border: 1px solid var(--color-border); border-radius: 5px;
        padding: 15px; padding-top: 45px; /* Space for title */
        z-index: 1100; /* High z-index */
        display: none; /* Initially hidden */
        pointer-events: auto;
        box-shadow: 0 5px 20px rgba(0,0,0,0.5); backdrop-filter: blur(7px);
        font-family: var(--font-secondary); color: var(--color-text);
        flex-direction: column; gap: 15px; /* Increased gap */
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    /* No need for !important if logic manages display correctly */
    #drop-item-panel.active { display: flex; }
    #drop-item-panel .modal-title { /* Re-use modal-title style */
        position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
        font-family: var(--font-primary); color: var(--color-primary); font-size: 16px;
    }
    #drop-item-panel .modal-close-button { /* Re-use modal-close style */
        position: absolute; top: 8px; right: 10px; background: none; border: none;
        color: var(--color-text-muted); font-size: 24px; cursor: pointer; line-height: 1;
    }
    #drop-item-panel .modal-close-button:hover { color: var(--color-primary); }
    .drop-item-info { /* Item Info Area */
        display: flex; align-items: center; gap: 12px;
        background-color: rgba(0,0,0,0.2); padding: 10px; border-radius: 4px;
        border: 1px solid var(--color-border-light);
    }
    #drop-item-icon { /* Icon Container */
        font-size: 26px; min-width: 30px; text-align: center;
        display: flex; justify-content: center; align-items: center;
    }
    #drop-item-icon img { max-width: 100%; max-height: 26px; display: block; }
    #drop-item-name { /* Item Name */
        font-weight: bold; color: var(--color-primary); font-family: var(--font-primary);
        flex-grow: 1; /* Allow name to take space */
    }
    .drop-quantity-control { /* Quantity Control Area */
        display: flex; flex-direction: column; align-items: center; gap: 8px;
    }
    .drop-quantity-control label { font-size: 12px; color: var(--color-text-muted); }
    .quantity-input-group { /* Group for -, input, + */
        display: flex; align-items: center; gap: 8px; /* Increased gap */
    }
    /* Reuse shop quantity button style for consistency */
    #drop-item-panel .shop-qty-button {
        background-color: var(--color-bg-light); border: 1px solid var(--color-border);
        color: var(--color-text-muted); border-radius: 3px; cursor: pointer;
        transition: background-color 0.15s, border-color 0.15s; padding: 3px 8px; font-weight: bold;
        font-size: 14px; line-height: 1.2;
    }
    #drop-item-panel .shop-qty-button:hover:not(:disabled) {
        background-color: rgba(80,80,80,0.9); border-color: var(--color-primary); color: var(--color-primary);
    }
    #drop-item-panel .shop-qty-button:disabled { opacity: 0.5; cursor: not-allowed; }
    /* Reuse shop quantity input style */
    #drop-item-panel .shop-quantity-input { /* Use specific ID for the input */
        width: 60px; text-align: center; padding: 4px;
        background-color: rgba(0,0,0,0.6); border: 1px solid var(--color-border-light);
        color: var(--color-text); -moz-appearance: textfield;
    }
    #drop-item-panel .shop-quantity-input::-webkit-inner-spin-button,
    #drop-item-panel .shop-quantity-input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    #drop-max-text { font-size: 10px; color: var(--color-text-muted); }
    .drop-actions { /* Buttons Area */
        display: grid; grid-template-columns: 1fr auto 1fr; /* Layout for buttons */
        gap: 8px; align-items: center; margin-top: 10px; width: 100%;
    }
    /* Reuse main action button style */
    .drop-actions .action-button {
        flex: 1; /* Buttons fill space */
        padding: 9px 10px; font-family: var(--font-primary); font-size: 13px;
        font-weight: bold; border-radius: 3px; border: 1px solid var(--color-border);
        cursor: pointer; transition: all 0.2s ease;
        background-color: var(--color-bg-light); color: var(--color-text);
        text-shadow: 1px 1px 1px #000; text-align: center;
    }
    .drop-actions .action-button:not(:disabled):hover {
        background-color: rgba(90,90,90,0.85); border-color: var(--color-primary); color: var(--color-primary);
    }
    .drop-actions .action-button:disabled { opacity: 0.4; cursor: not-allowed; border-color: #555; color: #777;}
    #drop-confirm-specific-btn { /* Specific Style for Confirm Qty */ }
    /* Style for MAX button (reused from shop) */
    #drop-quantity-max { justify-self: center; } /* Center the MAX button */
    /* Style for Drop All button */
    #drop-confirm-all-btn {
        background-color: rgba(231, 76, 60, 0.7); /* Reddish tone */
        border-color: var(--color-danger); color: #fff;
    }
    #drop-confirm-all-btn:hover:not(:disabled) { background-color: var(--color-danger); border-color: #fff; }
    .drop-cancel-button { /* General Cancel Button */
        background-color: #555 !important; border-color: #777 !important;
        color: var(--color-text-muted) !important; margin-top: 5px; width: 100%;
        grid-column: 1 / -1; /* Span all columns */
    }
    .drop-cancel-button:hover:not(:disabled) { background-color: #777 !important; color: var(--color-text) !important; border-color: #999 !important; }

    /* === Floating Text (v2.6 - Enhanced Animations) === */
    @keyframes float-up-fade-base { 0% { opacity: 1; transform: translateY(0) scale(1); } 20% { transform: translateY(-10px) scale(1.05); } 100% { opacity: 0; transform: translateY(-70px) scale(0.8); } }
    @keyframes float-up-fade-critical { 0% { opacity: 1; transform: translateY(5px) scale(1.3); } 15% { transform: translateY(-15px) scale(1.0); } 100% { opacity: 0; transform: translateY(-90px) scale(0.7); } }
    @keyframes float-up-fade-heal { 0% { opacity: 1; transform: translateY(0) scale(0.9); } 100% { opacity: 0; transform: translateY(-50px) scale(1.1); } }
    @keyframes float-up-fade-miss { 0% { opacity: 0.9; transform: translateY(0) translateX(0); } 100% { opacity: 0; transform: translateY(-35px) translateX(25px); } }
    /* NEW: Meditation Particle Animation */
    @keyframes swirl-up-fade { 0% { opacity: 0.8; transform: translateY(0) rotate(0deg) scale(0.8); } 100% { opacity: 0; transform: translateY(-80px) rotate(720deg) scale(1.3); } }

    .floating-text {
        position: absolute; pointer-events: none; font-family: var(--font-primary); font-weight: bold;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.9); z-index: 20;
        animation-name: float-up-fade-base; animation-duration: 1.8s; animation-timing-function: ease-out; animation-fill-mode: forwards;
        white-space: nowrap; transform-origin: center bottom; will-change: transform, opacity;
    }
    .damage-text { color: var(--color-damage, #ffffff); font-size: 17px; }
    .critical-text { color: var(--color-critical, #ff9900); font-size: 26px; font-weight: 900; animation-name: float-up-fade-critical !important; animation-duration: 2.0s !important; text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 0 0 8px var(--color-critical, #ff9900); }
    .heal-text { color: var(--color-heal, #2ecc71); font-size: 17px; animation-name: float-up-fade-heal; animation-duration: 2.2s; text-shadow: 0 0 5px var(--color-heal, #2ecc71); }
    .mana-text { color: var(--color-mana, #3498db); font-size: 15px; animation-duration: 1.7s; text-shadow: 0 0 5px var(--color-mana, #3498db); }
    .xp-text { color: var(--color-xp, #e0c25e); font-size: 15px; animation-duration: 1.6s; }
    .miss-text { color: var(--color-miss, #bdc3c7); font-size: 14px; font-style: italic; animation-name: float-up-fade-miss; animation-duration: 1.2s; }
    .system-text { color: var(--color-system, #bdc3c7); font-size: 16px; font-style: italic; animation-duration: 1.5s; }
    .poison-text { color: var(--color-poison-text, #9b59b6); font-size: 15px; animation-duration: 1.9s; }
    .meditation-text { /* NEW */
        color: var(--color-meditate, #94d3ff); font-size: 13px; animation-name: swirl-up-fade;
        animation-duration: 2.5s; animation-timing-function: linear; animation-iteration-count: infinite;
        text-shadow: 0 0 6px var(--color-meditate, #94d3ff);
    }

    #target-info { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 5px 12px; border-radius: 3px; display: none; border: 1px solid var(--color-border-light); text-align: center; font-size: 11px; z-index: 80; pointer-events: none; min-width: 150px; }
    #target-name { color: var(--color-primary); font-weight: bold; font-family: var(--font-primary); font-size: 12px; margin-bottom: 4px; }
    #target-health-bar-container { width: 120px; height: 7px; background: #333; border-radius: 3.5px; overflow: hidden; margin: 4px auto 0 auto; border: 1px solid #222; display: none; }
    #target-health-bar { height: 100%; width: 100%; background: var(--color-success); border-radius: 3.5px; transition: width 0.2s ease-out, background-color 0.2s ease; display: block; }

    /* Screens & Overlays */
    #start-screen, #character-creation, #loading-screen, #pause-indicator-overlay, #death-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1000; background: linear-gradient(rgba(0,0,0,0.7), rgba(0,0,0,0.9)); font-family: var(--font-primary); pointer-events: auto; text-align: center; }
    #start-screen, #character-creation { display: none; background-image: url('https://images.pexels.com/photos/1670187/pexels-photo-1670187.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1'); background-size: cover; background-position: center; }
    #loading-screen { display: flex; background-color: #050505; }
    #pause-indicator-overlay { display: none; background: rgba(0,0,0,0.7); z-index: 990; backdrop-filter: blur(4px); }
    #pause-text { font-size: 36px; color: var(--color-primary); text-shadow: 0 0 10px var(--color-secondary); }
    #death-overlay { background-color: rgba(0,0,0,0); transition: background-color 2s ease-in, opacity 1.5s ease-in; z-index: 999; pointer-events: none; opacity: 0; display: flex; }
    #death-overlay.visible { background-color: rgba(0,0,0,0.85); pointer-events: auto; opacity: 1;}
    #death-message { font-size: 36px; color: var(--color-danger); text-shadow: 0 0 10px var(--color-danger); margin-bottom: 20px; display: none;}
    #respawn-prompt { font-size: 18px; color: var(--color-text-muted); display: none;}
    #death-overlay.visible #death-message, #death-overlay.visible #respawn-prompt { display: block; animation: fadeIn 1s 1.5s forwards; opacity: 0; }
    @keyframes fadeIn { to { opacity: 1; } }

    /* Titles & Menus */
    #game-title { font-size: clamp(28px, 5.5vw, 65px); margin-bottom: 12px; color: var(--color-primary); text-shadow: 0 0 12px var(--color-primary), 0 0 25px var(--color-secondary); animation: pulseTitle 2.5s infinite alternate; }
    #game-subtitle { font-size: clamp(15px, 1.8vw, 22px); margin-bottom: 35px; color: var(--color-text); text-shadow: 0 0 6px rgba(255,255,255,0.5); }
    @keyframes pulseTitle { from { text-shadow: 0 0 12px var(--color-primary), 0 0 25px var(--color-secondary); opacity: 0.9 } to { text-shadow: 0 0 20px var(--color-primary), 0 0 40px var(--color-secondary), 0 0 8px #fff; opacity: 1 } }
    #start-screen .start-menu-container { background-color: rgba(20, 20, 20, 0.6); padding: 25px 35px; border-radius: 8px; border: 1px solid var(--color-border-light); box-shadow: 0 5px 15px rgba(0,0,0,0.4); backdrop-filter: blur(5px); display: flex; flex-direction: column; align-items: center; gap: 10px; }
    .menu-button { background-color: var(--color-bg-light); color: var(--color-text); border: 1px solid var(--color-border); padding: 11px 25px; margin: 5px 0; font-size: clamp(14px, 1.5vw, 18px); border-radius: 4px; cursor: pointer; transition: all 0.3s ease; width: 280px; max-width: 80%; text-align: center; backdrop-filter: blur(4px); font-family: var(--font-primary); text-shadow: 1px 1px 1px #000; }
    .menu-button i { margin-right: 12px; width: 18px; text-align: center; }
    .menu-button:hover:not(:disabled) { background-color: rgba(90,90,90,0.85); border-color: var(--color-primary); color: var(--color-primary); transform: translateY(-2px) scale(1.02); box-shadow: 0 6px 15px rgba(0,0,0,0.35); }
    .menu-button:disabled, .menu-button.disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }

    /* Character Creation */
    #character-form { background-color: var(--color-bg-medium); padding: 25px 30px; border-radius: 8px; width: 90%; max-width: 750px; box-shadow: 0 0 20px rgba(0,0,0,0.5); backdrop-filter: blur(8px); border: 1px solid var(--color-border); max-height: 90vh; overflow-y: auto; font-family: var(--font-secondary); display: grid; grid-template-columns: 1fr 250px; grid-template-rows: auto auto auto auto 1fr auto; gap: 20px; grid-template-areas: "title title" "name preview" "gender preview" "race preview" "class preview" "attributes attributes" "start start"; }
    #character-form .form-title { grid-area: title; margin-bottom: 10px; font-family: var(--font-primary); font-size: 20px; color: var(--color-primary); text-align: center; }
    #character-form .form-group { margin-bottom: 0; }
    #character-form label { display: block; margin-bottom: 5px; font-size: 13px; color: var(--color-text-muted); }
    #character-form input[type="text"] { width: 100%; padding: 8px 10px; background: rgba(0,0,0,0.5); border: 1px solid var(--color-border); border-radius: 3px; color: var(--color-text); }
    #character-form .form-group#name-group { grid-area: name; } #character-form .form-group#gender-group { grid-area: gender; }
    #character-form .form-group#race-group { grid-area: race; } #character-form .form-group#class-group { grid-area: class; }
    #character-preview-area {
        grid-area: preview; background-color: rgba(0,0,0,0.3); border: 1px solid var(--color-border-light);
        border-radius: 5px; display: flex; flex-direction: column; justify-content: center; align-items: center;
        min-height: 250px; text-align: center; padding: 15px; position: relative; /* Needed for canvas */
        overflow: hidden; /* Ensure canvas stays within bounds */
    }
    /* Styling for the preview canvas container specifically */
    #char-preview-model { width: 100%; height: 100%; min-height: 200px; }
    #char-preview-model canvas { display: block; width: 100% !important; height: 100% !important; } /* Force canvas size */
    #character-attributes-display { grid-area: attributes; background-color: rgba(0,0,0,0.2); padding: 10px 15px; border-radius: 4px; border-top: 1px solid var(--color-border-light); margin-top: 10px; font-size: 11px; color: var(--color-text-muted); }
    #character-attributes-display h4 { font-size: 13px; color: var(--color-secondary); margin-bottom: 8px; text-align: center;}
    #character-attributes-display ul { list-style: none; padding: 0; display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 5px 15px;}
    #character-attributes-display li span { color: var(--color-text); font-weight: bold; }
    #start-game { grid-area: start; margin-top: 15px; width: auto; justify-self: center; }
    .gender-selection { display: flex; justify-content: space-around; gap: 15px; margin-top: 5px; }
    .gender-option label { display: flex; flex-direction: column; align-items: center; padding: 8px 15px; background-color: rgba(0,0,0,0.4); border: 2px solid var(--color-border-light); border-radius: 5px; cursor: pointer; transition: all 0.2s ease; }
    .gender-option label i { font-size: 24px; color: var(--color-text-muted); margin-bottom: 5px; transition: color 0.2s; }
    .gender-option label span { font-size: 13px; transition: color 0.2s; }
    .gender-option input[type="radio"] { display: none; }
    .gender-option input[type="radio"]:checked + label { border-color: var(--color-primary); background-color: rgba(40,40,40,0.6); }
    .gender-option input[type="radio"]:checked + label i, .gender-option input[type="radio"]:checked + label span { color: var(--color-primary); }
    .gender-option label:hover { border-color: var(--color-text-muted); }
    .race-selection, .class-selection { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 8px; margin-top: 8px; }
    .race-option, .class-option { background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; text-align: center; cursor: pointer; transition: all 0.2s ease; border: 2px solid var(--color-border); }
    .race-option:hover, .class-option:hover { background-color: rgba(20,20,20,0.6); border-color: var(--color-text-muted); transform: translateY(-2px); }
    .race-option.selected, .class-option.selected { background-color: rgba(40,40,40,0.7); border-color: var(--color-primary); box-shadow: 0 0 8px var(--color-primary); transform: translateY(-2px); }
    .race-name, .class-name { font-weight: bold; margin-bottom: 3px; font-size: 13px; font-family: var(--font-primary); }
    .race-desc, .class-desc { font-size: 10px; color: var(--color-text-muted); line-height: 1.3; }
    .class-icon i { font-size: 24px; margin-bottom: 5px; color: var(--color-primary); }
    #loading-bar-container { width: 80%; max-width: 350px; height: 16px; background-color: rgba(255,255,255,0.1); border-radius: 8px; overflow: hidden; border: 1px solid var(--color-border); }
    #loading-bar { height: 100%; width: 0%; background: linear-gradient(to right, var(--color-secondary), var(--color-primary)); transition: width 0.2s linear; }
    #loading-text { margin-top: 10px; font-size: 14px; color: var(--color-text-muted); }

    /* Dialogue Panel */
    #dialog-panel { position: absolute; bottom: 120px; left: 50%; transform: translateX(-50%); width: clamp(280px, 55%, 650px); background-color: var(--color-bg-medium); border-radius: 5px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); backdrop-filter: blur(6px); border: 1px solid var(--color-border); display: none; z-index: 110; pointer-events: auto; padding: 12px 15px; font-family: var(--font-secondary); }
    .dialog-header { display: flex; align-items: center; margin-bottom: 10px; border-bottom: 1px solid var(--color-border-light); padding-bottom: 8px; }
    #dialog-npc-icon { font-size: 22px; color: var(--color-primary); min-width: 22px; text-align: center; }
    .dialog-npc-name { font-size: 16px; color: var(--color-primary); font-weight: 700; margin-left: 10px; font-family: var(--font-primary); }
    .dialog-text { font-size: 13px; color: var(--color-text); margin-bottom: 15px; line-height: 1.5; max-height: 120px; overflow-y: auto; padding-right: 6px; min-height: 40px; cursor: pointer; /* Allow clicking to skip */ }
    .dialog-options { display: flex; flex-direction: column; gap: 6px; }
    .dialog-option { background-color: var(--color-bg-light); color: var(--color-text-muted); border: 1px solid var(--color-border-light); padding: 7px 10px; border-radius: 3px; cursor: pointer; transition: all 0.15s ease; font-size: 12px; text-align: left; }
    .dialog-option:hover { background-color: rgba(80,80,80,0.9); border-color: var(--color-primary); color: var(--color-primary); }
    .dialog-option.disabled { opacity: 0.5; cursor: not-allowed; background-color: rgba(50,50,50,0.7); color: #777; border-color: var(--color-border-light); }
    .dialog-option.disabled:hover { background-color: rgba(50,50,50,0.7); color: #777; border-color: var(--color-border-light); }

    /* Character Sheet */
    #character-sheet-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: clamp(300px, 45%, 500px); background-color: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; padding: 20px; z-index: 120; display: none; pointer-events: auto; box-shadow: 0 5px 25px rgba(0,0,0,0.6); backdrop-filter: blur(7px); font-family: var(--font-secondary); color: var(--color-text); max-height: 90vh; overflow-y: auto; }
    #character-sheet-panel h2 { font-family: var(--font-primary); color: var(--color-primary); margin-bottom: 18px; text-align: center; font-size: 18px; }
    .char-sheet-section { margin-bottom: 15px; }
    .char-sheet-section h3 { font-size: 14px; color: var(--color-secondary); border-bottom: 1px solid var(--color-border-light); padding-bottom: 4px; margin-bottom: 8px; font-family: var(--font-primary); display: flex; justify-content: space-between; align-items: center; }
    .char-sheet-columns { display: grid; grid-template-columns: 1fr auto; gap: 4px 12px; font-size: 12px; align-items: center; }
    .stat-label { color: var(--color-text-muted); }
    .stat-value { color: var(--color-text); font-weight: bold; text-align: right; display: flex; align-items: center; justify-content: flex-end; min-height: 18px; }
    #close-char-sheet { position: absolute; top: 10px; right: 10px; background: none; border: none; color: var(--color-text-muted); font-size: 22px; cursor: pointer; line-height: 1; padding: 0; }
    #close-char-sheet:hover { color: var(--color-primary); }
    .attribute-alloc-button { background: var(--color-secondary); border: 1px solid var(--color-border); border-radius: 50%; width: 16px; height: 16px; line-height: 14px; text-align: center; font-size: 12px; font-weight: bold; color: #111; cursor: pointer; margin-left: 6px; padding: 0; transition: all 0.1s ease; display: inline-flex; justify-content: center; align-items: center; flex-shrink: 0; }
    .attribute-alloc-button:hover:not(:disabled) { background: var(--color-primary); transform: scale(1.1); }
    .attribute-alloc-button:disabled { background: #555; color: #888; cursor: not-allowed; transform: none; opacity: 0.5; }
    #attribute-points-info { font-size: 10px; color: var(--color-warning); display: inline; font-weight: normal; }

    /* Shop Panel */
    #shop-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: clamp(400px, 65%, 700px); background-color: var(--color-bg-medium); border: 1px solid var(--color-border); border-radius: 5px; padding: 18px; z-index: 120; display: none; pointer-events: auto; box-shadow: 0 5px 25px rgba(0,0,0,0.6); backdrop-filter: blur(7px); font-family: var(--font-secondary); color: var(--color-text); flex-direction: column; max-height: 85vh; }
    #shop-panel h2 { font-family: var(--font-primary); color: var(--color-primary); margin: 0; font-size: 18px; }
    #shop-panel h4 { font-size: 13px; color: var(--color-secondary); margin-bottom: 6px; font-family: var(--font-primary); text-align: center; }
    #close-shop { background: none; border: none; color: var(--color-text-muted); font-size: 22px; cursor: pointer; line-height: 1; padding: 0; }
    #close-shop:hover { color: var(--color-primary); }
    .shop-list { overflow-y: auto; border: 1px solid var(--color-border-light); padding: 6px; border-radius: 3px; flex-grow: 1; background: rgba(0,0,0,0.25); min-height: 120px; }
    .shop-empty { color: var(--color-text-muted); font-style: italic; text-align: center; padding: 15px; font-size: 11px; }
    .shop-item { padding: 5px; border-bottom: 1px solid var(--color-border-light); cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 12px; transition: background-color 0.1s ease; position: relative; }
    .shop-item:last-child { border-bottom: none; }
    .shop-item:hover { background-color: rgba(255,255,255,0.05); }
    .shop-item.selected { background-color: rgba(224, 194, 94, 0.15); /* border: 1px solid var(--color-primary); box-shadow: 0 0 5px rgba(224, 194, 94, 0.5); */} /* Subtle selection */
    .shop-item.selected:hover { background-color: rgba(224, 194, 94, 0.25); }
    .shop-item-name { display: flex; align-items: center; gap: 6px; }
    .shop-item-name i, .shop-item-name span[style*="width: 20px"] { vertical-align: middle; } /* Align icons/spans */
    .shop-item-name img { vertical-align: middle; max-width: 20px; max-height: 20px; margin-right: 5px;} /* Align images */
    .shop-item-price { color: var(--color-primary); font-weight: bold; }
    .item-count-shop { color: var(--color-text-muted); font-size: 0.9em; margin-left: 4px; }
    .shop-item.cannot-afford { color: #aaa; }
    .shop-item.cannot-afford .shop-item-price { color: var(--color-danger); }
    #shop-selected-item-details { min-height: 80px; background-color: rgba(0,0,0,0.3); border: 1px solid var(--color-border-light); border-radius: 4px; padding: 10px; margin-bottom: 15px; font-size: 11px; display: flex; flex-direction: column; justify-content: center; }
    #shop-details-placeholder { color: var(--color-text-muted); font-style: italic; text-align: center; }
    #shop-details-content:not([style*="display: none;"]) + #shop-details-placeholder { display: none; }
    #shop-details-content { display: none; }
    #shop-details-name { font-weight: bold; font-family: var(--font-primary); font-size: 14px; margin-bottom: 5px; }
    #shop-details-desc { color: var(--color-text-muted); margin-bottom: 8px; line-height: 1.4; max-height: 40px; overflow-y: auto; padding-right: 5px; }
    #shop-details-stats { font-size: 10px; color: #88cfff; margin-bottom: 5px; }
    #shop-details-stats span { display: block; margin-bottom: 2px; }
    #shop-details-price { font-weight: bold; color: var(--color-primary); margin-top: 5px;}
    #shop-quantity-selector { border-top: 1px dashed var(--color-border-light); padding-top: 10px; margin-top: 10px; display: none; align-items: center; gap: 8px; font-size: 12px; }
    .shop-qty-button { background-color: var(--color-bg-light); border: 1px solid var(--color-border); color: var(--color-text-muted); border-radius: 3px; cursor: pointer; transition: background-color 0.15s, border-color 0.15s; padding: 2px 6px; font-weight: bold; }
    .shop-qty-button:hover:not(:disabled) { background-color: rgba(80,80,80,0.9); border-color: var(--color-primary); }
    .shop-qty-button:disabled { opacity: 0.5; cursor: not-allowed; }
    #shop-quantity-input { width: 50px; text-align: center; padding: 3px; background-color: rgba(0,0,0,0.6); border: 1px solid var(--color-border-light); color: var(--color-text); -moz-appearance: textfield; }
    #shop-quantity-input::-webkit-inner-spin-button, #shop-quantity-input::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    #shop-qty-max { padding: 2px 8px; margin-left: 5px; }
    #shop-total-price { margin-left: auto; font-weight: bold; }
    #shop-action-buttons { display: flex; justify-content: space-around; gap: 10px; border-top: 1px solid var(--color-border-light); padding-top: 15px; margin-top: 10px; }
    .shop-action-button { flex: 1; padding: 9px 15px; font-family: var(--font-primary); font-size: 13px; font-weight: bold; border-radius: 3px; border: 1px solid var(--color-border); cursor: pointer; transition: all 0.2s ease; background-color: var(--color-bg-light); color: var(--color-text-muted); text-shadow: 1px 1px 1px #000; display: flex; align-items: center; justify-content: center; gap: 8px; }
    .shop-action-button:not(:disabled):hover { background-color: rgba(90,90,90,0.85); border-color: var(--color-primary); color: var(--color-primary); }
    .shop-action-button:not(:disabled):active { transform: translateY(1px); background-color: rgba(40,40,40,0.9); }
    #shop-buy-button:not(:disabled) { border-color: var(--color-success); color: var(--color-success); }
    #shop-buy-button:not(:disabled):hover { background-color: rgba(46, 204, 113, 0.15); color: #ffffff; border-color: #ffffff; }
    #shop-sell-button:not(:disabled) { border-color: var(--color-warning); color: var(--color-warning); }
    #shop-sell-button:not(:disabled):hover { background-color: rgba(241, 196, 15, 0.15); color: #ffffff; border-color: #ffffff; }
    .shop-action-button:disabled { opacity: 0.4; cursor: not-allowed; background-color: rgba(30,30,30,0.7); border-color: rgba(100,100,100,0.3); color: #666; }
    #shop-buy-qty-text, #shop-sell-qty-text { font-size: 0.9em; margin-left: 4px; opacity: 0.8; }

    /* Action Bar & Quest Tracker */
    #action-bar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; background-color: rgba(10, 10, 10, 0.8); padding: 5px; border-radius: 4px; border: 1px solid var(--color-border-light); pointer-events: auto; z-index: 98; }
    .action-slot { width: 42px; height: 42px; background-color: var(--color-bg-light); border: 1px solid var(--color-border); border-radius: 3px; display: flex; justify-content: center; align-items: center; font-size: 20px; color: var(--color-text-muted); cursor: pointer; position: relative; overflow: hidden; transition: background-color 0.2s, border-color 0.2s; }
    .action-slot:hover { border-color: var(--color-primary); background-color: rgba(70, 70, 70, 0.9); }
    .action-slot .item-icon { pointer-events: none; display:flex; align-items:center; justify-content:center; width:90%; height:90%; }
    .action-slot .item-icon img { max-width: 100%; max-height: 100%; object-fit: contain; }
    .action-slot .item-count-hotbar { position: absolute; bottom: 1px; right: 2px; font-size: 9px; font-weight: bold; color: white; background-color: rgba(0, 0, 0, 0.7); padding: 0 2px; border-radius: 2px; line-height: 1.1; }
    .action-slot .keybind-text { position: absolute; top: 1px; left: 2px; font-size: 9px; color: rgba(255, 255, 255, 0.6); font-weight: bold; }
    .action-slot .cooldown-overlay-hotbar { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background-color: rgba(0, 0, 0, 0.7); pointer-events: none; transition: height 0.1s linear; }
    .action-slot.on-cooldown .item-icon { opacity: 0.5; filter: grayscale(80%); }
    #quest-tracker { position: absolute; top: 150px; right: 10px; width: 250px; max-height: 180px; background-color: rgba(15, 15, 15, 0.75); border: 1px solid var(--color-border-light); border-radius: 4px; padding: 8px 10px; font-size: 11px; color: var(--color-text-muted); z-index: 85; pointer-events: none; overflow-y: auto; display: none; }
    #quest-tracker.visible { display: block; }
    #quest-tracker h4 { font-family: var(--font-primary); color: var(--color-primary); font-size: 13px; margin: 0 0 8px 0; padding-bottom: 4px; border-bottom: 1px dashed var(--color-border-light); }
    #quest-tracker .tracker-objective { margin-bottom: 4px; padding-left: 10px; position: relative; color: var(--color-text); }
    #quest-tracker .tracker-objective::before { content: ''; position: absolute; left: 0; top: 5px; width: 6px; height: 6px; background: var(--color-text-muted); border-radius: 50%; }
    #quest-tracker .tracker-objective.completed { color: #888; text-decoration: line-through; }
    #quest-tracker .tracker-objective.completed::before { background: var(--color-success); }

    /* Credits & Manual */
    #credits-panel, #manual-panel { width: clamp(450px, 70%, 800px); max-height: 85vh; z-index: 1100; }
    #credits-panel .credits-content { padding: 15px; font-size: 13px; line-height: 1.6; }
    #credits-panel .credits-content p { margin-bottom: 15px; color: var(--color-text-muted); }
    #credits-panel .credits-content strong { color: var(--color-primary); }
    #credits-panel .social-links { margin-top: 25px; padding-top: 15px; border-top: 1px solid var(--color-border-light); display: flex; justify-content: center; align-items: center; gap: 25px; }
    #credits-panel .social-link { color: var(--color-text-muted); font-size: 28px; transition: color 0.2s ease, transform 0.2s ease; }
    #credits-panel .social-link:hover { transform: scale(1.15); }
    #credits-panel .social-link.instagram:hover { color: var(--color-instagram); }
    #credits-panel .social-link.linkedin:hover { color: var(--color-linkedin); }
    #credits-panel .social-link.github:hover { color: var(--color-github); }
    #manual-panel .manual-tabs { display: flex; border-bottom: 1px solid var(--color-border); margin-bottom: 15px; flex-shrink: 0; }
    #manual-panel .manual-tab-button { flex-grow: 1; padding: 10px 15px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; color: var(--color-text-muted); font-family: var(--font-primary); font-size: 14px; transition: all 0.2s ease; margin-bottom: -1px; white-space: nowrap; }
    #manual-panel .manual-tab-button:hover { color: var(--color-text); }
    #manual-panel .manual-tab-button.active { color: var(--color-primary); border-bottom-color: var(--color-primary); }
    #manual-panel .manual-content-section { display: none; padding: 0 10px 10px 10px; font-size: 13px; line-height: 1.7; overflow-y: auto; flex-grow: 1; height: calc(100% - 60px); /* Adjust height based on tabs/title */ }
    #manual-panel .manual-content-section.active { display: block; }
    #manual-panel .manual-content-section h3 { font-family: var(--font-primary); color: var(--color-secondary); margin-top: 10px; margin-bottom: 10px; font-size: 16px; border-bottom: 1px dashed var(--color-border-light); padding-bottom: 5px; }
    #manual-panel .manual-content-section p { margin-bottom: 12px; color: var(--color-text-muted); }
    #manual-panel .manual-content-section ul { list-style: disc; margin-left: 25px; margin-bottom: 12px; }
    #manual-panel .manual-content-section li { margin-bottom: 6px; }
    #manual-panel .manual-content-section code { background-color: rgba(0,0,0,0.4); padding: 2px 5px; border-radius: 3px; font-family: monospace; color: var(--color-warning); font-size: 12px; }
    #manual-panel .manual-content-section strong { color: var(--color-primary); font-weight: normal; }

    /* === Mobile UI === */
    #mobile-ui-container { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 95; color: var(--color-text); font-family: var(--font-secondary); }
    #mobile-top-bar { position: absolute; top: 0; left: 0; width: 100%; background-color: rgba(10, 10, 10, 0.85); padding: 5px 10px; display: flex; align-items: center; z-index: 100; justify-content: space-between; pointer-events: auto; border-bottom: 1px solid var(--color-border-light); box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
    #mobile-minimap-container { flex-shrink: 0; }
    #mobile-minimap-canvas { width: 65px; height: 65px; border-radius: 50%; border: 2px solid var(--color-secondary); background-color: #080808; image-rendering: pixelated; }
    #mobile-stats-bars { display: flex; flex-direction: column; flex-grow: 1; margin-left: 10px; gap: 3px; max-width: calc(100% - 120px); /* Adjust width */ }
    .mobile-stat-bar { height: 10px; background-color: rgba(0,0,0,0.6); border-radius: 5px; overflow: hidden; position: relative; border: 1px solid rgba(0,0,0,0.3); box-shadow: inset 0 1px 2px rgba(0,0,0,0.5); }
    .mobile-stat-bar > div { height: 100%; transition: width 0.25s ease-out; border-radius: 5px; }
    #mobile-health-bar { background: linear-gradient(to right, #a13333, var(--color-health)); }
    #mobile-mana-bar { background: linear-gradient(to right, #2c5364, var(--color-mana)); }
    #mobile-stamina-bar { background: linear-gradient(to right, #1a6333, var(--color-stamina)); }
    #mobile-bottom-controls { position: absolute; bottom: 0; left: 0; width: 100%; height: 150px; display: flex; justify-content: space-between; align-items: flex-end; padding: 15px; pointer-events: none; }
    #joystick-container { width: 120px; height: 120px; position: absolute; bottom: 15px; left: 15px; pointer-events: auto; border-radius: 50%; background: rgba(50,50,50,0.2); border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(2px); }
    #mobile-action-buttons { position: absolute; bottom: 15px; right: 15px; width: 150px; height: 150px; pointer-events: auto; display: block; }
    .mobile-action-btn { position: absolute; background-color: rgba(60, 60, 60, 0.7); border: 2px solid var(--color-border-light); border-radius: 50%; color: var(--color-text); display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color 0.15s, transform 0.1s, box-shadow 0.2s; text-shadow: 1px 1px 2px #000; backdrop-filter: blur(3px); box-shadow: 0 2px 5px rgba(0,0,0,0.4); }
    .mobile-action-btn:active { background-color: rgba(90, 90, 90, 0.8); transform: scale(0.95); box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
    #mobile-attack-btn { width: 75px; height: 75px; font-size: 28px; bottom: 5px; right: 5px; z-index: 10; }
    #mobile-interact-btn { width: 55px; height: 55px; font-size: 22px; bottom: 95px; right: 18px; }
    #mobile-jump-btn { width: 55px; height: 55px; font-size: 22px; bottom: 18px; right: 95px; }
    #mobile-sprint-toggle-btn { width: 45px; height: 45px; font-size: 18px; bottom: 90px; right: 85px; }
    #mobile-attack-btn i { color: var(--color-danger); } #mobile-interact-btn i { color: var(--color-info); }
    #mobile-jump-btn i { color: var(--color-success); } #mobile-sprint-toggle-btn i { color: var(--color-warning); }
    #mobile-sprint-toggle-btn.sprint-active { background-color: rgba(224, 194, 94, 0.7); box-shadow: 0 0 10px var(--color-warning); border-color: var(--color-warning); }
    #mobile-sprint-toggle-btn.sprint-active i { color: #fff; }
    #mobile-sidebar-close-btn { display: none; position: absolute; top: 5px; left: 5px; width: 30px; height: 30px; background-color: rgba(0, 0, 0, 0.3); border: 1px solid var(--color-border-light); border-radius: 50%; color: var(--color-text-muted); font-size: 16px; cursor: pointer; z-index: 115; pointer-events: auto; justify-content: center; align-items: center; }
    #mobile-sidebar-close-btn:hover { background-color: rgba(0, 0, 0, 0.5); color: var(--color-primary); }
    #sidebar.mobile-visible #mobile-sidebar-close-btn { display: flex; }
    #mobile-sidebar-toggle { display: none; position: fixed; top: 80px; right: 10px; width: 40px; height: 40px; background-color: rgba(30, 30, 30, 0.8); border: 1px solid var(--color-border); border-radius: 5px; color: var(--color-primary); font-size: 18px; cursor: pointer; z-index: 105; pointer-events: auto; justify-content: center; align-items: center; backdrop-filter: blur(4px); }

    /* Media Queries */
    @media (max-width: 768px) {
        #sidebar { display: none !important; right: -280px; width: 280px; /* Slightly narrower for mobile */ } /* Corrected initial right value */
        #sidebar.mobile-visible { display: flex !important; position: fixed; top: 0; right: 0; height: 100%; z-index: 110; transition: right 0.3s ease-out; }
        #sidebar:not(.mobile-visible) { right: -280px; } /* Ensure it's fully hidden */
        #mobile-ui-container, #mobile-sidebar-toggle { display: block; }
        #mobile-sidebar-toggle { display: flex; }
        #mobile-bottom-controls { display: flex; }
        #message-log-container { top: 70px; left: 5px; width: calc(100% - 10px); height: 75px; font-size: 10px; }
        #notification-container { bottom: 170px; left: 10px; width: calc(100% - 20px); z-index: 105; }
        #dialog-panel { bottom: 165px; width: 90%; }
        #target-info { display: none !important; }
        #action-bar { display: none; }
        #quest-tracker { top: 155px; width: calc(100% - 20px); max-height: 100px; right: 10px; left: 10px; font-size: 10px;}
        #sidebar .tab-button { font-size: 11px; padding: 6px 3px; }
        #sidebar #sidebar-modal-buttons { grid-template-columns: 1fr; } /* Stack buttons */
        .sidebar-action-button { font-size: 12px; padding: 8px 10px; } .sidebar-action-button i { font-size: 14px; }
        #minimap-canvas { width: 120px; height: 120px; border-width: 2px; }
        #inventory-grid { grid-template-columns: repeat(5, 1fr); gap: 3px; }
        .modal-panel { width: 90%; max-width: 500px; max-height: 90vh; } /* Allow modal vertical scroll */
        #drop-item-panel { width: 90%; max-width: 320px; } /* Make drop panel slightly smaller */
        #equipment-modal { width: 85%; }
        #equipment-modal #equipment-slots { grid-template-columns: 55px 55px 55px; gap: 5px; }
        .inventory-slot { min-height: 45px; } .inventory-item { font-size: 20px; } .item-count { font-size: 7px; }
        .dialog-text { font-size: 12px; max-height: 80px; } .dialog-option { font-size: 11px; padding: 5px 8px; }
        .shop-item { font-size: 11px; padding: 4px; } .char-sheet-columns { font-size: 11px; }
        #credits-panel, #manual-panel { width: 90%; }
        #start-screen .start-menu-container { width: 90%; padding: 20px; } .menu-button { width: 95%; }
        #character-form { grid-template-columns: 1fr; grid-template-rows: auto; grid-template-areas: "title" "name" "gender" "race" "class" "preview" "attributes" "start"; max-width: 95%; padding: 15px; }
        .race-selection, .class-selection { grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); }
        .race-option, .class-option { min-width: 110px; }
        #manual-panel .manual-tab-button { font-size: 12px; padding: 8px 5px; }
        #manual-panel .manual-content-section { font-size: 12px; }
        /* Make joystick bigger */
        #joystick-container { width: 140px; height: 140px; }
        /* Adjust action button positions if joystick overlaps */
        #mobile-action-buttons { bottom: 20px; right: 20px; }
    }
</style>
</head>
<body>
    <!-- Canvas y Pantallas de Carga/Inicio/Creación (No Changes Here) -->
    <canvas id="particle-canvas"></canvas>
    <div id="loading-screen">
        <div id="game-title">Eldravar</div>
        <div id="loading-bar-container"><div id="loading-bar"></div></div>
        <div id="loading-text">Inicializando...</div>
    </div>
    <div id="start-screen">
        <div id="game-title">Eldravar</div>
        <div id="game-subtitle">Chronicle of the Lost King</div>
        <div class="start-menu-container">
            <button class="menu-button" id="new-game-button"><i class="fas fa-scroll"></i> Nueva Crónica</button>
            <button class="menu-button disabled" id="continue-button"><i class="fas fa-book-open"></i> Continuar Crónica</button>
            <hr style="width: 80%; border-color: var(--color-border-light); margin: 5px 0;">
            <button class="menu-button" id="manual-button"><i class="fas fa-book"></i> Manual</button>
            <button class="menu-button" id="options-button-main"><i class="fas fa-cog"></i> Opciones</button>
            <button class="menu-button" id="credits-button"><i class="fas fa-users"></i> Créditos</button>
        </div>
    </div>
    <div id="character-creation">
        <form id="character-form"> <!-- Changed div to form for semantics -->
            <div class="form-title">Forja Tu Destino</div>

            <div class="form-group" id="name-group">
                <label for="character-name">Nombre:</label>
                <input type="text" id="character-name" placeholder="Ingresa nombre" value="Héroe" maxlength="16">
            </div>

            <div class="form-group" id="gender-group">
                <label>Género:</label>
                <div class="gender-selection">
                    <div class="gender-option">
                        <input type="radio" id="gender-male" name="gender" value="male" checked>
                        <label for="gender-male"><i class="fas fa-mars"></i><span>Masculino</span></label>
                    </div>
                    <div class="gender-option">
                        <input type="radio" id="gender-female" name="gender" value="female">
                        <label for="gender-female"><i class="fas fa-venus"></i><span>Femenino</span></label>
                    </div>
                </div>
            </div>

            <div class="form-group" id="race-group">
                <label>Raza:</label>
                <div class="race-selection" id="race-selection">
                    <!-- Options will be dynamically populated or use JS listeners if already here -->
                    <div class="race-option selected" data-race="human"> <div class="race-name">Humano</div> <div class="race-desc">Equilibrados y resistentes.</div> </div>
                    <div class="race-option" data-race="elf"> <div class="race-name">Elfo</div> <div class="race-desc">Ágiles e inteligentes.</div> </div>
                    <div class="race-option" data-race="gnome"> <div class="race-name">Gnomo</div> <div class="race-desc">Muy inteligentes, frágiles.</div> </div>
                    <div class="race-option" data-race="dark_elf"> <div class="race-name">Elfo Oscuro</div> <div class="race-desc">Combatientes versátiles.</div> </div>
                    <div class="race-option" data-race="dwarf"> <div class="race-name">Enano</div> <div class="race-desc">Fuertes y resistentes.</div> </div>
                    <div class="race-option" data-race="orc"> <div class="race-name">Orco</div> <div class="race-desc">Muy fuertes, resistentes.</div> </div>
                </div>
            </div>

            <div class="form-group" id="class-group">
                <label>Clase:</label>
                <div class="class-selection" id="class-selection">
                     <div class="class-option selected" data-class="warrior"> <div class="class-icon"><i class="fas fa-shield-alt"></i></div> <div class="class-name">Guerrero</div> <div class="class-desc">Fuerza y Constitución. Combate C/C.</div> </div>
                    <div class="class-option" data-class="mage"> <div class="class-icon"><i class="fas fa-hat-wizard"></i></div> <div class="class-name">Mago</div> <div class="class-desc">Inteligencia. Hechizos poderosos.</div> </div>
                    <div class="class-option" data-class="paladin"> <div class="class-icon"><i class="fas fa-cross"></i></div> <div class="class-name">Paladín</div> <div class="class-desc">Fuerza y Fe. Combate y curación.</div> </div>
                    <div class="class-option" data-class="hunter"> <div class="class-icon"><i class="fas fa-bow-arrow"></i></div> <div class="class-name">Cazador</div> <div class="class-desc">Destreza. Combate a distancia.</div> </div>
                    <div class="class-option" data-class="assassin"> <div class="class-icon"><i class="fas fa-mask"></i></div> <div class="class-name">Asesino</div> <div class="class-desc">Destreza. Sigilo y ataques rápidos.</div> </div>
                    <div class="class-option" data-class="worker"> <div class="class-icon"><i class="fas fa-hammer"></i></div> <div class="class-name">Trabajador</div> <div class="class-desc">Versátil. Especializado en profesiones.</div> </div>
                </div>
            </div>

            <!-- Área de Preview (Contenedor del Canvas) -->
            <div id="character-preview-area">
                <div id="char-preview-model"></div> <!-- Canvas will be appended here by JS -->
            </div>

            <!-- Display de Atributos Base -->
            <div id="character-attributes-display">
                <h4>Atributos Base</h4>
                <ul id="char-creation-attributes-list">
                    <!-- Generado por JS -->
                </ul>
            </div>

            <button type="button" id="start-game" class="menu-button"><i class="fas fa-check-circle"></i> Comenzar Aventura</button> <!-- type="button" prevents form submission -->
        </form>
    </div>
    <canvas id="game-canvas"></canvas>

    <!-- Sidebar -->
    <div id="sidebar">
        <button id="mobile-sidebar-close-btn"><i class="fas fa-times"></i></button>
        <div id="player-info" title="Ver Hoja de Personaje (C)" style="cursor: pointer;"> <div><span id="player-name">Héroe</span> (Nivel <span id="player-level">1</span>)</div> <div><i class="fas fa-coins"></i> <span id="gold-text">10</span></div> </div>
        <div class="stat-bar" title="Experiencia"> <div id="xp-bar" style="width: 0%;"></div> <div class="stat-text" id="xp-text">0/100</div> </div>
        <hr style="border-color: var(--color-border-light); margin: 5px 0;">
        <div id="minimap-container" title="Abrir Mapa Grande (M)"><canvas id="minimap-canvas"></canvas></div>
        <div id="tabs-container"> <div class="tabs-header" id="tabs-header"> <button class="tab-button active" data-tab="inventory">Inventario</button> <button class="tab-button" data-tab="spells">Hechizos</button> </div> <div class="tab-content active" id="inventory-tab"> <div id="inventory-grid"></div> <div id="item-tooltip" class="tooltip"></div> </div> <div class="tab-content" id="spells-tab"> <div id="spells-list"></div> <div id="spell-tooltip" class="tooltip"></div> </div> </div>
        <div id="action-buttons"> <button class="action-button" id="equip-button" title="Equipar Objeto (Q)" disabled>Equipar</button> <button class="action-button" id="use-button" title="Usar/Lanzar (U)" disabled>Usar</button> <button class="action-button" id="drop-button" title="Soltar Objeto (T)" disabled>Soltar</button> </div>
        <div id="resource-bars-container"> <div class="stat-bar" title="Salud"> <div id="health-bar" style="width: 100%;"></div> <div class="stat-text" id="health-text">100/100</div> </div> <div class="stat-bar" title="Maná"> <div id="mana-bar" style="width: 100%;"></div> <div class="stat-text" id="mana-text">100/100</div> </div> <div class="stat-bar" title="Resistencia"> <div id="stamina-bar" style="width: 100%;"></div> <div class="stat-text" id="stamina-text">100/100</div> </div> </div>
        <div id="sidebar-modal-buttons"> <button id="open-equipment-button" class="sidebar-action-button" title="Abrir Equipo (B)"><i class="fas fa-user-shield"></i> Equipo</button> <button id="open-crafting-button" class="sidebar-action-button" title="Abrir Fabricación (N)"><i class="fas fa-hammer"></i> Fabricar</button> <button id="open-quests-button" class="sidebar-action-button" title="Abrir Misiones (J)"><i class="fas fa-scroll"></i> Misiones</button> <button id="open-skills-button" class="sidebar-action-button" title="Abrir Habilidades (K)"><i class="fas fa-star"></i> Habilidades</button>             <button id="open-character-sheet-button" class="sidebar-action-button" title="Abrir Hoja de Personaje (C)"><i class="fas fa-address-card"></i> Personaje</button>
<button id="open-map-button-sidebar" class="sidebar-action-button" title="Abrir Mapa (M)"><i class="fas fa-map"></i> Mapa</button> </div>
        <div id="status-effects-bar"></div>
        <div id="status-tooltip" class="tooltip"></div> <div id="equipment-tooltip" class="tooltip"></div> <div id="recipe-tooltip" class="tooltip"></div> <div id="skill-tooltip" class="tooltip"></div>
    </div> <!-- Fin #sidebar -->

    <!-- UI Móvil -->
    <div id="mobile-ui-container">
        <div id="mobile-top-bar">
            <div id="mobile-minimap-container"><canvas id="mobile-minimap-canvas"></canvas></div>
            <div id="mobile-stats-bars">
                <div class="mobile-stat-bar" title="Salud"><div id="mobile-health-bar" style="width: 100%;"></div></div>
                <div class="mobile-stat-bar" title="Maná"><div id="mobile-mana-bar" style="width: 100%;"></div></div>
                <div class="mobile-stat-bar" title="Resistencia"><div id="mobile-stamina-bar" style="width: 100%;"></div></div>
            </div>
        </div>
        <div id="mobile-bottom-controls">
            <div id="joystick-container"></div>
            <div id="mobile-action-buttons">
                <button class="mobile-action-btn" id="mobile-attack-btn" title="Atacar/Cargar (Z)"><i class="fas fa-gavel"></i></button>
                <button class="mobile-action-btn" id="mobile-interact-btn" title="Interactuar (E)"><i class="fas fa-hand-pointer"></i></button>
                <button class="mobile-action-btn" id="mobile-jump-btn" title="Saltar (Espacio)"><i class="fas fa-shoe-prints"></i></button>
                <button class="mobile-action-btn" id="mobile-sprint-toggle-btn" title="Correr Rápido (Shift)"><i class="fas fa-running"></i></button>
            </div>
        </div>
    </div>
    <button id="mobile-sidebar-toggle" title="Mostrar/Ocultar Menú"><i class="fas fa-bars"></i></button>

    <!-- Contenedor UI General -->
    <div id="ui-container">
        <div id="message-log-container" data-filter="all">
             <div id="message-log-tabs"> <button class="message-log-tab active" data-filter="all">Todo</button> <button class="message-log-tab" data-filter="system">Sistema</button> <button class="message-log-tab" data-filter="combat">Combate</button> <button class="message-log-tab" data-filter="loot">Botín</button> <button class="message-log-tab" data-filter="quest">Misión</button> </div>
             <div id="message-log"> <div class="log-message system">Registro inicializado. ¡Bienvenido a Eldravar!</div> </div>
        </div>
        <div id="target-info">
            <div id="target-name">Ninguno</div>
            <div id="target-health-bar-container"><div id="target-health-bar"></div></div>
        </div>
        <div id="quest-tracker"></div>
        <div id="action-bar">
            <div class="action-slot" data-index="0"><span class="keybind-text">1</span></div>
            <div class="action-slot" data-index="1"><span class="keybind-text">2</span></div>
            <div class="action-slot" data-index="2"><span class="keybind-text">3</span></div>
            <div class="action-slot" data-index="3"><span class="keybind-text">4</span></div>
        </div>
    </div>

    <!-- Paneles Modales (No Changes to Structure Here) -->
    <div id="dialog-panel" style="display: none;">
         <div class="dialog-header"> <i class="fas fa-user" id="dialog-npc-icon"></i> <div class="dialog-npc-name" id="dialog-npc-name">NPC</div> </div>
         <div class="dialog-text" id="dialog-text">...</div>
         <div class="dialog-options" id="dialog-options"></div>
    </div>
    <div id="character-sheet-panel" class="modal-panel"> <!-- Added class -->
        <button id="close-char-sheet" class="modal-close-button" title="Cerrar (Esc o C)">×</button>
        <h2>Hoja de Personaje</h2>
        <div style="text-align: center; margin-bottom: 15px; font-size: 14px; color: var(--color-secondary);" id="char-sheet-info">
    <span id="char-sheet-name-level">Nombre (Nivel X)</span> - Clase: <span id="char-sheet-class">Desconocida</span>
</div>
        <div class="char-sheet-section"> <h3>Atributos Primarios <span id="attribute-points-info"></span></h3> <div id="char-attributes"></div> </div>
        <div class="char-sheet-section"> <h3>Estadísticas Derivadas</h3> <div class="char-sheet-columns"> <span class="stat-label">Salud:</span><span class="stat-value" id="char-health">100/100</span> <span class="stat-label">Maná:</span><span class="stat-value" id="char-mana">100/100</span> <span class="stat-label">Resistencia:</span><span class="stat-value" id="char-stamina">100/100</span> <span class="stat-label">Daño Físico:</span><span class="stat-value" id="char-phys-dmg">3-6</span> <span class="stat-label">Daño Mágico:</span><span class="stat-value" id="char-magic-dmg">2-4</span> <span class="stat-label">Defensa:</span><span class="stat-value" id="char-defense">3.0</span> <span class="stat-label">Resistencia Mágica:</span><span class="stat-value" id="char-magic-resist">2.0</span> <span class="stat-label">Prob. Golpe:</span><span class="stat-value" id="char-hit-chance">76.0%</span> <span class="stat-label">Prob. Crítico:</span><span class="stat-value" id="char-crit-chance">8.0%</span> <span class="stat-label">Vel. Movimiento:</span><span class="stat-value" id="char-move-speed">4.0</span> <span class="stat-label">Regen. PS/s:</span><span class="stat-value" id="char-hp-regen">0.0</span> <span class="stat-label">Regen. PM/s:</span><span class="stat-value" id="char-mp-regen">0.0</span> <span class="stat-label">Regen. PR/s:</span><span class="stat-value" id="char-sp-regen">1.5</span> </div> </div>
    </div>
    <div id="shop-panel" class="modal-panel">
       <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--color-border-light); position: relative; padding-right: 30px;"> <h2 id="shop-title">Tienda</h2> <div id="shop-player-gold-container" style="font-size: 14px; color: var(--color-primary);"><i class="fas fa-coins"></i> <span id="shop-player-gold">0</span></div> <button id="close-shop" class="modal-close-button" style="position: absolute; top: -8px; right: -5px;" title="Cerrar Tienda (Esc)">×</button> </div>
       <div style="display: flex; gap: 12px; flex-grow: 1; overflow: hidden; margin-bottom: 15px;"> <div style="flex: 1; display: flex; flex-direction: column;"> <h4 >Objetos del Comerciante (Comprar)</h4> <div id="shop-item-list" class="shop-list"><div class="shop-empty">...</div></div> </div> <div style="flex: 1; display: flex; flex-direction: column;"> <h4>Tus Objetos (Vender)</h4> <div id="shop-player-sell-list" class="shop-list"><div class="shop-empty">...</div></div> </div> </div>
       <div id="shop-selected-item-details"> <span id="shop-details-placeholder">Selecciona un objeto...</span> <div id="shop-details-content" style="display: none;"> <div id="shop-details-name"></div> <div id="shop-details-desc"></div> <div id="shop-details-stats"></div> <div id="shop-details-price"></div> <div id="shop-quantity-selector" style="display: none;"> <span>Cantidad:</span> <button id="shop-qty-decrease" class="shop-qty-button">-</button> <input type="number" id="shop-quantity-input" value="1" min="1"> <button id="shop-qty-increase" class="shop-qty-button">+</button> <button id="shop-qty-max" class="shop-qty-button">MAX</button> <span id="shop-total-price">Total: 0 <i class="fas fa-coins"></i></span> </div> </div> </div>
       <div id="shop-action-buttons"> <button id="shop-buy-button" class="shop-action-button" disabled><i class="fas fa-shopping-cart"></i> Comprar <span id="shop-buy-qty-text"></span></button> <button id="shop-sell-button" class="shop-action-button" disabled><i class="fas fa-hand-holding-usd"></i> Vender <span id="shop-sell-qty-text"></span></button> </div>
       <div id="shop-tooltip" class="tooltip"></div>
    </div>
    <div id="death-overlay"> <div id="death-message">HAS MUERTO</div> <div id="respawn-prompt">Busca un Sacerdote para Revivir</div> </div>
    <div id="pause-indicator-overlay"></div>
    <div id="options-panel" class="modal-panel"> <!-- Added class -->
    <!-- Inside <div id="options-panel" ... > -->
    <h2 class="options-title">Opciones del Juego</h2>
    <button id="close-options-button" class="modal-close-button" title="Cerrar Opciones (Esc)">×</button>

    <!-- Audio Section (Keep Existing) -->
    <div class="options-section">
        <h3><i class="fas fa-volume-up"></i> Audio</h3>
        <div class="option-group"> <label for="volume-master" class="option-label">Volumen Maestro:</label> <input type="range" id="volume-master" class="volume-slider" min="0" max="100" step="1"> <span class="slider-value" id="volume-master-value">100%</span> </div>
        <div class="option-group"> <label for="volume-sfx" class="option-label">Efectos (SFX):</label> <input type="range" id="volume-sfx" class="volume-slider" min="0" max="100" step="1"> <span class="slider-value" id="volume-sfx-value">100%</span> </div>
        <div class="option-group"> <label for="volume-music" class="option-label">Música:</label> <input type="range" id="volume-music" class="volume-slider" min="0" max="100" step="1"> <span class="slider-value" id="volume-music-value">100%</span> </div>
        <div class="option-group"> <label for="volume-weather" class="option-label">Clima:</label> <input type="range" id="volume-weather" class="volume-slider" min="0" max="100" step="1"> <span class="slider-value" id="volume-weather-value">100%</span> </div>
    </div>

    <!-- *** NEW Graphics/Performance Section *** -->
    <div class="options-section">
        <h3><i class="fas fa-desktop"></i> Gráficos y Rendimiento</h3>

        <!-- Show FPS Counter -->
        <div class="option-group">
            <label for="option-show-fps" class="option-label">Mostrar FPS:</label>
            <input type="checkbox" id="option-show-fps" class="option-checkbox">
        </div>

        <!-- Shadow Quality -->
        <div class="option-group">
            <label for="option-shadow-quality" class="option-label">Calidad Sombras:</label>
            <select id="option-shadow-quality" class="option-select">
                <option value="high">Alta (2048)</option>
                <option value="medium" selected>Media (1024)</option> <!-- Default Medium -->
                <option value="low">Baja (512)</option>
                <option value="off">Desactivadas</option>
            </select>
        </div>

        <!-- Particle Limit -->
        <div class="option-group">
            <label for="option-particle-limit" class="option-label">Límite Partículas:</label>
            <select id="option-particle-limit" class="option-select">
                <option value="1200" selected>Alto (1200)</option> <!-- Default High -->
                <option value="700">Medio (700)</option>
                <option value="300">Bajo (300)</option>
            </select>
        </div>

        <!-- Weather Effects -->
        <div class="option-group">
            <label for="option-weather-effects" class="option-label">Efectos Clima:</label>
            <input type="checkbox" id="option-weather-effects" class="option-checkbox" checked> <!-- Default On -->
        </div>

        <!-- Pixel Ratio (Advanced) -->
        <div class="option-group">
            <label for="option-pixel-ratio" class="option-label">Escala Render (Avanzado):</label>
             <input type="range" id="option-pixel-ratio" class="volume-slider" min="50" max="150" step="10" value="100"> <!-- Value is percentage -->
             <span class="slider-value" id="option-pixel-ratio-value">100%</span>
        </div>

    </div>
    <!-- *** END NEW Section *** -->
<!-- *** NUEVA Sección de Visuales/Iluminación *** -->
    <div class="options-section">
        <h3><i class="fas fa-lightbulb"></i> Visuales e Iluminación</h3>

        <!-- Control de Brillo (Tone Mapping Exposure) -->
        <div class="option-group">
            <label for="option-brightness" class="option-label">Brillo General:</label>
            <!-- Usaremos el mismo estilo de slider que el volumen -->
            <input type="range" id="option-brightness" class="volume-slider" min="50" max="150" step="5" value="100">
            <span class="slider-value" id="option-brightness-value">100%</span>
        </div>

        <!-- Control de Intensidad de Luces -->
        <div class="option-group">
            <label for="option-lighting-intensity" class="option-label">Intensidad Luces:</label>
            <input type="range" id="option-lighting-intensity" class="volume-slider" min="0" max="150" step="5" value="100">
            <span class="slider-value" id="option-lighting-intensity-value">100%</span>
        </div>

    </div>
    <!-- *** FIN NUEVA Sección *** -->
    <button class="menu-button options-button" id="options-close-confirm">Aplicar y Cerrar</button>
    <!-- End Options Panel -->
    </div>
    <div id="large-map-panel" class="modal-panel"> <!-- Added class -->
        <h2 class="large-map-title">Mapa del Mundo</h2> <button id="close-large-map-button" class="modal-close-button" title="Cerrar Mapa (Esc o M)">×</button>
        <div id="large-map-canvas-container"> <canvas id="large-map-canvas"></canvas> </div>
        <p class="large-map-coords" id="large-map-player-coords">X: 0, Z: 0</p>
    </div>
    <div id="equipment-modal" class="modal-panel">
        <h2 class="modal-title">Equipo</h2> <button id="close-equipment-modal" class="modal-close-button" title="Cerrar (Esc o B)">×</button>
        <div id="equipment-slots"> <div class="equipment-slot" id="slot-head" data-slot="head"></div> <div class="equipment-slot" id="slot-amulet" data-slot="amulet"></div> <div class="equipment-slot" id="slot-chest" data-slot="chest"></div> <div class="equipment-slot" id="slot-weapon" data-slot="weapon"></div> <div class="equipment-slot" id="slot-legs" data-slot="legs"></div> <div class="equipment-slot" id="slot-ring1" data-slot="ring1"></div> <div class="equipment-slot" id="slot-ring2" data-slot="ring2"></div> <div class="equipment-slot" id="slot-feet" data-slot="feet"></div> </div>
    </div>
    <div id="crafting-modal" class="modal-panel">
         <h2 class="modal-title">Fabricación</h2> <button id="close-crafting-modal" class="modal-close-button" title="Cerrar (Esc o N)">×</button>
         <div class="crafting-content-wrapper"> <h4>Recetas Conocidas</h4> <div id="recipe-list"></div> <div id="crafting-details"> <h4>Detalles de Receta</h4> <div id="crafting-materials">Requiere: Ninguno</div> <div id="crafting-description">Selecciona una receta.</div> <button id="craft-button" disabled>Fabricar</button> </div> </div>
    </div>
    <div id="quests-modal" class="modal-panel">
         <h2 class="modal-title">Registro de Misiones</h2> <button id="close-quests-modal" class="modal-close-button" title="Cerrar (Esc o J)">×</button>
         <div id="quest-log"> <div class="quest-empty">No hay misiones activas.</div> </div>
    </div>
    <div id="skills-modal" class="modal-panel">
         <h2 class="modal-title">Habilidades</h2> <button id="close-skills-modal" class="modal-close-button" title="Cerrar (Esc o K)">×</button>
         <div class="skills-content-wrapper"> <div id="skill-points-info">Puntos de Habilidad: 0</div> <div id="skills-list"></div> </div>
    </div>
    <!-- Drop Item Panel (v2 - DEDICATED PANEL) -->
    <div id="drop-item-panel" class="modal-panel"> <!-- No need for quantity-prompt ID here -->
        <h2 class="modal-title" id="drop-panel-title">Soltar Objeto</h2> <!-- Unique ID for title if needed -->
        <button id="close-drop-panel-button" class="modal-close-button" title="Cerrar (Esc)">×</button>
        <div class="drop-item-info"> <span id="drop-item-icon"></span> <span id="drop-item-name"></span> </div>
        <div class="drop-quantity-control"> <label for="drop-quantity-input">Cantidad a Soltar:</label> <div class="quantity-input-group"> <button id="drop-decrease-btn" class="shop-qty-button">-</button> <input type="number" id="drop-quantity-input" value="1" min="1" max="1" class="shop-quantity-input"> <button id="drop-increase-btn" class="shop-qty-button">+</button> </div> <span id="drop-max-text">(Max: 1)</span> </div>
        <div class="drop-actions"> <button id="drop-confirm-specific-btn" class="action-button">Soltar Cantidad</button> <button id="drop-quantity-max" class="shop-qty-button">MAX</button> <button id="drop-confirm-all-btn" class="action-button drop-all-button">Soltar Todo (<span id="drop-all-count">0</span>)</button> </div>
        <!-- Optional Cancel Button (or rely on 'X') -->
        <!-- <button id="drop-cancel-btn" class="drop-cancel-button action-button">Cancelar</button> -->
    </div>
    <!-- Quantity Prompt (Generic - Can be REMOVED if only used for dropping now) -->
    <div id="quantity-prompt" class="modal-panel" style="display: none;">
        <!-- Leave empty or remove if replaced by drop-item-panel -->
    </div>
    <!-- Credits Panel -->
    <div id="credits-panel" class="modal-panel" style="display: none;">
        <h2 class="modal-title">Créditos</h2> <button id="close-credits-button" class="modal-close-button" title="Cerrar">×</button>
        <div class="credits-content"> <p><strong>Eldravar: Chronicle of the Lost King</strong> es un proyecto de demostración...</p> <p>Desarrollo por:</p> <p style="text-align: center; font-size: 1.1em;"><strong>Federico Gonzalez Cueto</strong></p> <div class="social-links"> <a href="https://www.instagram.com/fedecueto/" target="_blank" class="social-link instagram" title="Instagram"><i class="fab fa-instagram"></i></a> <a href="https://www.linkedin.com/in/federico-gonzalez-cueto-249986115/" target="_blank" class="social-link linkedin" title="LinkedIn"><i class="fab fa-linkedin"></i></a> <a href="https://github.com/fedegcueto" target="_blank" class="social-link github" title="GitHub"><i class="fab fa-github"></i></a> </div> <p style="font-size: 0.9em; margin-top: 20px; text-align: center;">Agradecimientos...</p> </div>
    </div>
    <!-- Manual Panel -->
    <div id="manual-panel" class="modal-panel" style="display: none;">
        <h2 class="modal-title">Manual del Juego</h2> <button id="close-manual-button" class="modal-close-button" title="Cerrar">×</button>
        <div class="manual-tabs" id="manual-tabs-header"> <button class="manual-tab-button active" data-manual-tab="controls">Controles</button> <button class="manual-tab-button" data-manual-tab="concepts">Conceptos</button> <button class="manual-tab-button" data-manual-tab="creatures">Criaturas</button> <button class="manual-tab-button" data-manual-tab="locations">Lugares</button> <button class="manual-tab-button" data-manual-tab="skills">Habilidades</button> </div>
        <div class="manual-content-section active" id="manual-controls-content"> <h3>Controles Básicos</h3> <ul> <li><strong>Moverse:</strong> <code>W</code>, <code>S</code></li> <li><strong>Girar:</strong> <code>A</code>, <code>D</code></li> <li><strong>Correr:</strong> <code>Shift Izq</code></li> <li><strong>Saltar:</strong> <code>Espacio</code></li> <li><strong>Atacar/Cargar:</strong> <code>Z</code></li> <li><strong>Bloquear/Parry:</strong> <code>X</code></li> <li><strong>Esquivar:</strong> <code>Alt Izq</code></li> <li><strong>Interactuar:</strong> <code>E</code></li> <li><strong>Meditar (Regen. Maná):</strong> <code>R</code></li> <!-- Changed to R --> <li><strong>Usar Item/Hechizo Seleccionado:</strong> <code>U</code></li> <li><strong>Equipar Item Seleccionado:</strong> <code>Q</code></li> <li><strong>Soltar Item Seleccionado:</strong> <code>T</code></li> <li><strong>Hotbar:</strong> <code>1</code>-<code>4</code></li> </ul> <h3>Interfaz</h3> <ul> <li><strong>Inventario/Hechizos:</strong> <code>I</code></li> <li><strong>Hoja Personaje:</strong> <code>C</code></li> <li><strong>Equipo:</strong> <code>B</code></li> <li><strong>Fabricación:</strong> <code>N</code></li> <li><strong>Misiones:</strong> <code>J</code></li> <li><strong>Habilidades:</strong> <code>K</code></li> <li><strong>Mapa Grande:</strong> <code>M</code> (Minimapa)</li> <li><strong>Pausa/Menú:</strong> <code>Esc</code></li> </ul></div>
        <div class="manual-content-section" id="manual-concepts-content"> <h3>Conceptos Básicos</h3> <p>Entiende las mecánicas fundamentales de Eldravar:</p> <ul> <li><strong>Atributos:</strong> Fuerza (Daño Físico), Agilidad (Destreza), Inteligencia (Magia, Maná), Constitución (Salud, Defensa), Carisma (Domar, Interacción).</li> <li><strong>Estadísticas:</strong> Salud, Maná, Resistencia, Daños, Defensas, Probabilidades, Regeneraciones, Velocidad.</li> <li><strong>Nivel y Experiencia (XP):</strong> Gana XP matando enemigos y completando misiones.</li> <li><strong>Habilidades:</strong> Mejoran con uso o Puntos de Habilidad. Tienen un límite natural y se pueden asignar puntos.</li> <li><strong>Fabricación:</strong> Requiere recetas, materiales, habilidad y a veces estaciones.</li> <li><strong>Combate:</strong> Ataques (rápido/cargado), bloqueo, parry (<code>X</code> en el momento justo), esquiva (<code>Alt</code>).</li> <li><strong>Meditar (R):</strong> Mantén la tecla <code>R</code> estando quieto para regenerar maná. El movimiento o volver a pulsar <code>R</code> interrumpe.</li> <!-- Changed to R --> <li><strong>Muerte:</strong> Te conviertes en fantasma. Busca un Sacerdote para revivir. No puedes atacar ni usar la mayoría de objetos.</li> <li><strong>Razas y Clases:</strong> Modifican atributos base y habilidades iniciales.</li> </ul> </div>
        <div class="manual-content-section" id="manual-creatures-content"> <h3>Bestiario (General)</h3> <p>El mundo está lleno de vida... y peligros.</p> <ul> <li><strong>NPCs:</strong> Habitantes que ofrecen misiones, comercio o información (busca <code>!</code> amarillo para nuevas quests, verde para completar).</li> <li><strong>Enemigos Comunes:</strong> Animales, bandidos, goblins, esqueletos básicos.</li> <li><strong>Enemigos Fuertes:</strong> Criaturas más resistentes o con habilidades (guerreros, hechiceros, trolls).</li> <li><strong>Jefes y Únicos:</strong> Enemigos con nombre, muy poderosos, con botín especial. No entran en zonas seguras.</li> </ul> <p>Usa la habilidad <strong>Supervivencia</strong> para ver más detalles.</p> </div>
        <div class="manual-content-section" id="manual-locations-content"> <h3>Lugares de Interés</h3> <p>Explora los rincones de Eldravar:</p> <ul> <li><strong>Ciudades:</strong> Zonas seguras con servicios (Ullathorpe, Nix, etc.).</li> <li><strong>Campamentos Hostiles:</strong> Guaridas de Orcos, Bandidos, etc.</li> <li><strong>Mazmorras:</strong> Instancias peligrosas accesibles por entradas específicas.</li> <li><strong>Ruinas:</strong> Zonas antiguas, a menudo con no-muertos.</li> <li><strong>Puntos de Interés (POIs):</strong> Lugares especiales como altares, torres, etc.</li> <li><strong>Nodos de Recursos:</strong> Minerales, plantas, etc. para recolectar con la habilidad y herramienta adecuadas.</li> <li><strong>Caminos:</strong> Rutas principales, generalmente más seguras.</li> <li><strong>Biomas:</strong> Bosques, montañas, desiertos... con flora y fauna únicas.</li> </ul> </div>
        <div class="manual-content-section" id="manual-skills-content"> <h3>Habilidades</h3> <p>Las habilidades mejoran con el uso o asignando puntos (tecla <code>K</code>).</p> <ul> <li><strong>Combate:</strong> Sin armas, Con armas, Escudo, Armas Distancia, Apuñalar.</li> <li><strong>Magia:</strong> Magia general, Meditar, Resistencia Mágica.</li> <li><strong>Defensa/Mov.:</strong> Destreza Combate, Ocultarse.</li> <li><strong>Profesiones:</strong> Alquimia, Tala, Pesca, Minería, Carpintería, Herrería, Sastrería.</li> <li><strong>Miscelánea:</strong> Supervivencia, Comercio, Liderazgo, Domar, Navegación.</li> <li><strong>Límite Natural:</strong> El nivel que puedes alcanzar por uso depende de tu nivel de personaje. Puedes superar este límite asignando Puntos de Habilidad.</li> </ul> </div>
    </div>

    <!-- === SCRIPTS === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/17/Stats.min.js" integrity="sha512-N36afv40wLvmz7hQJ7fEC5z7qg87M1oJvy+mBOgQKV8x/HNJy40qE97J0iJ6o9vC1nmMG87EKNr5M2KzS8zBQw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
    // @ts-check
    // Eldravar - RPG Demo - v2.6 Refined
    console.log("%cEldravar v2.6 Refined Cargando...", "color: lime; font-size: 16px; font-weight: bold; text-shadow: 0 0 8px lime;");

    // *** GLTFLoader - Declaración Global ***
    let gltfLoader; // Se inicializará en init()

    // Constantes del juego (igual que v2.5)
    const VERSION = "2.6"; // Versión actualizada
    const MAX_LEVEL = 47;
    const BASE_XP_REQ = 100;
    const XP_MULTIPLIER = 1.35;
    const ATTRIBUTE_POINTS_PER_LEVEL = 3;
    const SKILL_POINTS_PER_LEVEL = 5; // Base, Trabajador tiene +1
    const SKILL_POINTS_PER_LEVEL_WORKER = 6;
    const MAX_SKILL_LEVEL = 100;
    const BASE_SKILL_XP_REQ = 50;
    const SKILL_XP_MULTIPLIER = 1.25;
    const BASE_STAT = 10;
    const BASE_HEALTH = 80;
    const HEALTH_PER_CON = 10;
    const BASE_MANA = 50;
    const MANA_PER_INT = 8;
    const BASE_STAMINA = 80;
    const STAMINA_PER_DEX = 5;
    const PHYS_DMG_PER_STR = { min: 0.4, max: 0.7 };
    const MAGIC_DMG_PER_INT = { min: 0.6, max: 1.1 };
    const DEF_PER_CON = 0.3;
    const MRES_PER_INT = 0.2;
    const HIT_CHANCE_PER_DEX = 0.6;
    const CRIT_CHANCE_PER_DEX = 0.3;
    const MOVE_SPEED_BASE = 4.0;
    const ROTATION_SPEED = Math.PI * 2.5;
    const SPRINT_MULTIPLIER = 1.6;
    const SPRINT_STAMINA_COST_PER_SEC = 10;
    const JUMP_STAMINA_COST = 10;
    const JUMP_VELOCITY = 8;
    const ATTACK_STAMINA_COST = 5;
    const CHARGED_ATTACK_STAMINA_COST = 18;
    const DODGE_STAMINA_COST = 12;
    const DODGE_DURATION = 350;
    const DODGE_SPEED_MULTIPLIER = 1.8;
    const REGEN_TICK_INTERVAL = 1000;
    const STATUS_EFFECT_TICK_INTERVAL = 1000;
    const SAVE_INTERVAL = 120000; // 2 minutos
    const DAY_NIGHT_DURATION_MS = 600000; // 10 minutos
    const WORLD_SIZE = 1500;
    const TERRAIN_SEGMENTS = 200;
    const TERRAIN_HEIGHT_SCALE = 35;
    const FLAT_REGION_DAMPENING = 0.1;
    const MOUNTAIN_REGION_BOOST = 2.0;
    const WATER_LEVEL = -1.5;
    const PLAYER_HEIGHT = 1.8;
    const PLAYER_RADIUS = 0.4;
    const PLAYER_HALF_HEIGHT = PLAYER_HEIGHT / 2;
    const GRAVITY = -25;
    const INTERACT_DISTANCE_SQ = 3.5 * 3.5;
    const ATTACK_DISTANCE = 2.2;
    const CHARGED_ATTACK_DISTANCE = 2.8;
    const PICKUP_DISTANCE_SQ = 2.5 * 2.5;
    const LOOT_RANGE_SQ = 2.5 * 2.5;
    const PROJECTILE_SPEED = 28;
    const ITEM_DESPAWN_TIME = 300000; // 5 minutos
    const ENEMY_RESPAWN_TIME = 120000; // 2 minutos
    const UNIQUE_ENEMY_RESPAWN_TIME = 300000; // 5 minutos para únicos
    const RESOURCE_RESPAWN_TIME = 180000; // 3 minutos para nodos
    const NOTIFICATION_DURATION = 4000;
    const DAMAGE_TEXT_DURATION = 2000; // ms
    const DIALOG_TYPING_SPEED = 20; // ms por carácter
    const MINIMAP_SIZE_PX = 100;
    const MINIMAP_WORLD_RADIUS = 70;
    const MINIMAP_CACHE_SIZE_FACTOR = 1.5;
    const MINIMAP_CACHE_SIZE_PX = MINIMAP_SIZE_PX * MINIMAP_CACHE_SIZE_FACTOR;
    const MINIMAP_BG_SAMPLE_STEP = 3;


const DEFAULT_BUILDING_SCALE = 1.0;
const BUILDING_SCALES = {
    // Viviendas (con ligera variación)
    'house_small': { scaleRange: [12.9, 18.1] },
    'house_medium': { scaleRange: [13.0, 20.25] },
    'house_large': { scaleRange: [17.2, 22.5] },
    'mansion_small': { scale: 18.8 },
    'shack_simple': { scaleRange: [14.8, 25.0] },
    'house_ruined': { scaleRange: [14.9, 24.15], isRuined: true },

// Funcionales
'inn': { scale: 19.3 },
'blacksmith': { scale: 21.15 },
'temple': { scale: 18.2 },
'temple_large': { scale: 20.0 },
'library': { scale: 17.4 },
'library_small': { scale: 15.1 },
'shop_generic': { scaleRange: [21.0, 29.2] },
'shop_potion': { scale: 21.0 },
'shop_books': { scale: 21.1 },
'alchemist_lab': { scale: 21.1 },
'guild_hall_small': { scale: 21.3 },
'guild_hall_medium': { scale: 21.6 },

// Mercado
'market_stalls': { scaleRange: [20.9, 11.1] },
'market_stalls_desert': { scaleRange: [23.0, 11.2] },

// Militares
'guard_tower_small': { scale: 18.4 }, // Más altas
'barracks': { scale: 21.4 },
'barracks_small': { scale: 21.2 },
'armory_small': { scale: 21.0 },
'city_wall_section': { scale: 21.1 }, // Ligeramente más grandes que el modelo base?
'city_gate_simple': { scale: 31.2 },

// Castillo
'castle_wall_section': { scale: 31.5 }, // Muros más imponentes
'castle_tower': { scale: 28.2 }, // Torres altas
'castle_gatehouse': { scale: 25.8 },
'castle_keep': { scale: 22.5 }, // Edificio principal grande

// Puerto
'dock_section': { scale: 21.0 },
'warehouse': { scale: 20.4 },
'warehouse_small': { scale: 14.1 },

// Tribales
'orc_hut_large': { scale: 22.3 },
'orc_hut_small': { scale: 20.0 },
'orc_tent': { scaleRange: [20.9, 11.1] },
'desert_tent': { scaleRange: [21.0, 11.2] },
'goblin_shack': { scaleRange: [20.8, 11.0] },
'crude_tent': { scaleRange: [20.9, 11.1] },

// Ruinas (Edificios)
'tower_ruined': { scale: 21.6, isRuined: true },
'ruined_wall_section': { scaleRange: [20.8, 28.3], isRuined: true },
'ruined_temple_large': { scale: 31.9, isRuined: true },
'ruined_crypt': { scaleRange: [21.0, 31.2], isRuined: true },
'mausoleum_ruined': { scale: 31.4, isRuined: true },

// Otros (Se podrían mover a POI/Props si son pequeños)
'anvil': { scale: 31.0 },
'loom': { scale: 31.0 },
'bonfire': { scale: 31.2 },
'fountain': { scale: 11.1 },
};

const DEFAULT_POI_SCALE = 1.0;
const POI_SCALES = {
    // Landmarks
    'wizard_tower_ruined': { scale: 18.8 },
    'farmhouse_ruined': { scale: 10.0 },
    'elfic_tree_large': { scale: 20.5 }, // Árbol grande especial
    'bandit_camp_props': { scale: 10.0 }, // El GLB ya define el tamaño relativo
    'orc_watchtower_model': { scale: 10.6 },
    'lighthouse_model': { scale: 18.8 }, // Faros altos
    'shipwreck_model': { scale: 10.5 },
    'standing_stones_model': { scale: 10.4 }, // Piedras grandes
    'giant_skeleton_bones': { scale: 18.0 },
    'volcanic_vent_effect': { scale: 10.3 },
    'stone_bridge_ruined': { scale: 10.2 },
    'oasis_model': { scale: 10.0 }, // El GLB define el tamaño del oasis
    'waterfall_with_cave': { scale: 10.8 },
    'graveyard_small': { scale: 10.0 },

    // Shrines
    'shrine_health': { scale: 10.1 },
    'shrine_mana': { scale: 10.1 },
    'shrine_strength': { scale: 10.2 }, // Un poco más imponente?
    'shrine_wisdom': { scale: 10.0 },
    'shrine_ruined': { scale: 10.1 },
    'shrine_magic_res': { scale: 10.1 },

    // Fallbacks (para IDs placeholder)
    'placeholder_landmark': { scale: 10.0 },
    'placeholder_shrine': { scale: 10.0 },
};

const DEFAULT_DUNGEON_ENTRANCE_SCALE = 15.0;
const DUNGEON_ENTRANCE_SCALES = {
    'cave_entrance_dark': { scale: 13.1 },
    'crypt_door_stone': { scale: 13.3 }, // Puertas más grandes
    'mountain_cave_large': { scale: 13.8 }, // Cueva grande
    'cave_entrance_small': { scale: 15.9 }, // Cueva pequeña
    'mine_entrance_wooden': { scale: 13.1 },
    'ruined_archway': { scale: 14.5 }, // Arco imponente
    'cave_entrance_reinforced': { scale: 12.2 },
    'sewer_grate': { scale: 10.0 }, // Rejilla tamaño real
    'placeholder_dungeon_entrance': { scale: 10.0 }
};
    
      const enemyHeightOffsets = {
        // --- Nivel Bajo (1-5) ---
        ant: 0.1,             // Hormiga: muy bajo
        bat: 1.2,             // Murciélago: volando/alto
        snake: 0.15,            // Serpiente: muy bajo
        rooster: 0.4,           // Gallo: altura media-baja
        rat: 0.25,            // Rata: bajo
        wolf: 0.6,             // Lobo: altura media
        goblin: 0.7,           // Duende: humanoide bajo
        wolfang: 0.8,           // Lobo Jefe: más grande que lobo normal
        spider: 0.5,           // Araña: bajo

        // --- Nivel Medio-Bajo (6-12) ---
        bandit: 0.9,          // Bandido: humanoide estándar
        skeleton: 0.9,        // Esqueleto: humanoide estándar
        orc_hunter: 1.1,        // Orco: humanoide alto
        assassin: 0.85,         // Asesino: humanoide estándar/ligero
        lord_goblin: 0.75,       // Lord Duende: un poco más alto que goblin normal
        orc_bewitched: 1.15,      // Orco Chamán: humanoide alto
        orc_farmer: 1.0,        // Orca: humanoide media-alta
        orc_protector: 1.2,     // Orco Protector: humanoide alto y robusto
        bear: 0.9,             // Oso: cuadrúpedo grande
        giant_scorpion: 0.5,  // Escorpión: bajo pero grande
        zombie: 0.9,          // Zombie: humanoide estándar
        ghoul: 0.85,           // Ghoul: ligeramente agachado?

        // --- Nivel Medio (13-25) ---
        skeleton_warrior: 0.95, // Guerrero Esqueleto: humanoide
        orc_warrior: 1.2,       // Guerrero Orco: humanoide alto
        troll: 1.6,            // Troll: muy alto
        cyclops: 1.8,           // Cíclope: muy alto
        harpy: 1.4,            // Arpía: volando/alto
        lizardman: 1.0,         // Hombre Lagarto: humanoide alto
        mummy: 0.9,           // Momia: humanoide
        golem_stone: 1.4,       // Golem: alto y voluminoso

        // --- Nivel Medio-Alto (26-40) ---
        drake: 1.3,            // Draco: cuadrúpedo/volador grande
        ogre: 1.7,             // Ogro: muy alto y robusto
        meduza: 1.5,           // Guiverno: volador/alto
        elemental_ice: 1.2,   // Elemental: flotante/medio-alto
        ghost: 1.1,            // Fantasma: flotante
        lich: 2.0,             // Liche: humanoide (quizás flotando ligeramente)
        minotaur: 1.6,         // Minotauro: alto y fuerte

        // --- Nivel Alto (41+) ---
        dragon_red: 2.5,        // Dragón: Muy grande, el offset depende de la pose
        golem_iron: 1.6,        // Golem Hierro: alto y pesado
        beholder: 1.4,         // Contemplador: flotante
        demon: 1.5             // Demonio: alto y poderoso

        // Añade más enemigos aquí si los defines...
        // wraith: 1.2,         // Espectro (ejemplo)
        // imp: 0.5,            // Diablillo (ejemplo)
        // elemental_fire: 1.2, // Elemental Fuego (ejemplo)
    };
    const MINIMAP_UPDATE_INTERVAL = 500;
    const TOOLTIP_DELAY = 400;
    const MAX_PARTICLES = 1200;
    const PARTICLE_RENDER_BATCH_SIZE = 600;
    const AI_UPDATE_THROTTLE = 2;
    let frameCount = 0;
    const BLOCK_STAMINA_COST_PER_SEC = 15;
    const BLOCK_DAMAGE_REDUCTION = 0.6;
    const CHARGE_ATTACK_MAX_TIME = 1500;
    const CHARGE_ATTACK_DAMAGE_MULTIPLIER = 2.5;
    const ATTACK_COOLDOWN = 650;
    const WEATHER_DURATION_MIN = 240000;
    const WEATHER_DURATION_MAX = 720000;
    const MAX_WEATHER_PARTICLES = 350;
    const STATIC_COLLISION_CHECK_RADIUS_SQ = 2.0 * 2.0;
    const PARRY_WINDOW = 180;
    const ROAD_WIDTH = 2.5;
    const ROAD_SMOOTHING_FACTOR = 0.4;
    const ROAD_HEIGHT_OFFSET = 0.08;
    const ROAD_TEXTURE_TRANSITION = 0.6;
    const PARRY_STAGGER_DURATION = 1500;
    const PARRY_STAMINA_REWARD = 15;
    const PICKUP_UNDERFOOT_RADIUS_SQ = (PLAYER_RADIUS + 0.4)**2;
    const ATTACK_CONE_ANGLE = Math.PI / 2.2;

    // Variables globales
    let orbitControls = null; let joystickManager = null; let joystickActive = false;
    let joystickVector = { x: 0, y: 0 }; let joystickMagnitude = 0;
    let mobileMinimapCtx = null;
    let simplex, simplexHeight, simplexBiomes, simplexObjects, simplexRivers, simplexDetails, biomeNoise, tempNoise, moistureNoise;
    let scene; let camera; let renderer; let clock; let raycaster; let mouse;
    let playerModel, playerModelGroup;
    let playerMeshes = {}; let playerLight; let playerCollider;
    let gameLoopId = null;
    let lastMinimapPlayerPos = { x: Infinity, z: Infinity };
    let lastMinimapPlayerChunk = { x: Infinity, z: Infinity };
    let minimapBgCache = null; let lastMinimapRenderTime = 0;
    let lastMinimapCacheCenter = { x: Infinity, z: Infinity };
    const MINIMAP_CACHE_UPDATE_DISTANCE = 15;
    const MINIMAP_FRAME_THROTTLE_MS = 50;
    const domCache = {};
    let worldSeed = Date.now();
    let currentDropItemId = null;
    let currentDropMaxQuantity = 0;
    let currentDropInventoryIndex = -1;
    let mobileSprintToggleActive = false;
    let isLargeMapDrawPending = false
    let previewAnimationLoopId = null;

const classNameMap = { // Mapeo para nombres de clase
    warrior: 'Guerrero', mage: 'Mago', paladin: 'Paladín', hunter: 'Cazador',
    assassin: 'Asesino', worker: 'Trabajador', bard: 'Bardo', druid: 'Druida',
    cleric: 'Clérigo', bandit: 'Bandido'
};

let preloadedBuildingModels = {}; // Almacenará { buildingId: GLTFScene }
let preloadedPOIs = {}; // Almacenará { poiId: GLTFScene }
let preloadedDungeonEntrances = {}; // Almacenará { entranceId: GLTFScene }
let textureCache = {}; // Para texturas del terreno, UI, etc.
let areCoreAssetsPreloaded = false; // Flag para saber si la precarga inicial está completa


    let preloadedPreviewModels = {}; // To store loaded GLTF scenes
    let isPreviewPreloadingComplete = false; // Flag
      
    let gameBrightness = 1.0; // Representa renderer.toneMappingExposure
    let lightingIntensityFactor = 1.0; // Multiplicador para intensidades base de luz
    
      // --- Performance Monitoring ---
    let statsMonitor = null; // For stats.js instance
    let showFPS = false; // Game state flag for showing FPS

    // --- Performance Options (Defaults) ---
    let shadowQuality = 'medium'; // 'high', 'medium', 'low', 'off'
    let particleLimit = 1200; // Matches MAX_PARTICLES default
    let weatherEffectsEnabled = true;
    let renderPixelRatio = 1.0; // Represents 100% initially

let largeMapBgCache = null; // Canvas para el caché del fondo del mapa grande
let lastLargeMapCacheCenter = { x: Infinity, z: Infinity }; // Centro del mundo para el caché actual
let lastLargeMapCacheZoom = 0; // Nivel de zoom del caché actual
let lastLargeMapDrawTime = 0; // Para throttling del redibujado
const LARGE_MAP_DRAW_THROTTLE = 30; // ms entre redibujados (ajustable)
const LARGE_MAP_CACHE_SIZE_FACTOR = 1.5; // Qué tan grande es el caché vs. el canvas visible
const LARGE_MAP_CACHE_UPDATE_THRESHOLD = 150; // Cuánto mover el centro antes de regenerar caché (en unidades del mundo)
const LARGE_MAP_ZOOM_UPDATE_THRESHOLD = 0.15; // Cuánto cambiar el zoom antes de regenerar caché

    // Definiciones de datos (pobladas más abajo)
    let itemDefinitions = {};
    let spellDefinitions = {};
    let npcDefinitions = {};
    let enemyDefinitions = {};
    let questDefinitions = {};
    let skillDefinitions = {};
    let recipeDefinitions = {};
    let worldData = {}; // Poblado en initGameDataDefinitions
    let resourceDefinitions = {}; // Poblado en initGameDataDefinitions
    let dungeonDefinitions = {}; // <<< Añadido para mazmorras

    let animationMixers = [];

    // Preview Scene Variables
    let previewScene, previewCamera, previewRenderer, previewModelContainer, previewLight, previewMixer = null, previewClock = new THREE.Clock();

    // Race/Class Definitions (igual que antes)

    const raceDefinitions = {
        human: { name: "Humano", modifiers: { strength: 1, dexterity: 1, intelligence: 0, constitution: 2, charisma: 0 } },
        elf: { name: "Elfo", modifiers: { strength: 0, dexterity: 2, intelligence: 2, constitution: 1, charisma: 1 } },
        gnome: { name: "Gnomo", modifiers: { strength: -2, dexterity: 3, intelligence: 4, constitution: 0, charisma: 2 } },
        dark_elf: { name: "Elfo Oscuro", modifiers: { strength: 2, dexterity: 1, intelligence: 1, constitution: 1, charisma: -1 } },
        dwarf: { name: "Enano", modifiers: { strength: 3, dexterity: 0, intelligence: -3, constitution: 3, charisma: -1 } },
        orc: { name: "Orco", modifiers: { strength: 3, dexterity: 1, intelligence: -2, constitution: 2, charisma: -1 } }
    };
    

        const classBaseAttributes = {
        warrior: { strength: 11, dexterity: 9, intelligence: 8, constitution: 10, charisma: 0 },
        mage:    { strength: 8, dexterity: 8, intelligence: 12, constitution: 9, charisma: 1 },
        paladin: { strength: 10, dexterity: 8, intelligence: 9, constitution: 10, charisma: 1 },
        hunter:  { strength: 9, dexterity: 11, intelligence: 8, constitution: 9, charisma: 1 },
        assassin:{ strength: 9, dexterity: 12, intelligence: 8, constitution: 9, charisma: 0 },
        worker:  { strength: 10, dexterity: 10, intelligence: 9, constitution: 10, charisma: -1 },
        // Añadir Bardo, Druida, Clérigo, Bandido aquí si se implementan
        bard:    { strength: 8, dexterity: 10, intelligence: 10, constitution: 8, charisma: 2 },
        druid:   { strength: 9, dexterity: 9, intelligence: 11, constitution: 9, charisma: 0 },
        cleric:  { strength: 10, dexterity: 8, intelligence: 10, constitution: 11, charisma: -1 },
        bandit:  { strength: 10, dexterity: 11, intelligence: 7, constitution: 10, charisma: 0 },
    };
    

    // Estado del Juego (gameState)
const gameState = {
    isLoading: true, isPlaying: false, isPaused: false, isGameOver: false,
    isCharacterSheetOpen: false, isInDialog: false, isShopOpen: false,
    isGhost: false, currentDialogNPC: null, currentDialogData: null, currentDialogueStep: 0,
    currentOfferedQuestId: null, targetEntity: null, typingInterval: null,
    lastSaveTime: 0, timeOfDay: 0.25, gameTime: 0,
    weather: 'clear', lastWeatherChange: 0, weatherIntensity: 0, weatherDuration: 0,
    messageLogFilter: 'all', isTyping: false, isProcessingOption: false,
    activeTooltip: null, tooltipTimeout: null,
    selectedRecipeId: null, isAimingWithBow: false, aimingTarget: null,
    isOptionsMenuOpen: false, isLargeMapOpen: false,
    largeMapIsPanning: false,
    largeMapOffsetX: 0, largeMapOffsetY: 0, largeMapZoom: 1.0,
    largeMapMinZoom: 0.3, largeMapMaxZoom: 4.0,
    largeMapLastPanX: 0, largeMapLastPanY: 0,
    shopSelectedItemToBuyId: null, shopSelectedItemToSellIndex: null,
    isTargetingSpell: false, spellBeingTargeted: null,
    isEquipmentModalOpen: false, isCraftingModalOpen: false,
    isQuestsModalOpen: false, isSkillsModalOpen: false,
    isCreditsPanelOpen: false, isManualPanelOpen: false,
    currentLocation: 'world'
};

    // Estado del Jugador (playerState) - Estructura ampliada
let playerState = {
    name: 'Héroe', gender: 'male', race: 'human', class: 'warrior',
    position: new THREE.Vector3(0, PLAYER_HALF_HEIGHT, 5), velocity: new THREE.Vector3(), rotationY: Math.PI, stats: { /* Inicializado después */ },
    onGround: true, isMoving: false, isSprinting: false, isJumping: false, isBlocking: false,
    blockStartTime: 0, isParrying: false, isDodging: false, dodgeStartTime: 0, isInvulnerable: false,
    isAttacking: false, isChargingAttack: false, chargeAttackStartTime: 0, isCastingSpell: false,
    castingSpellTimeoutId: null, isDrawingBow: false, isFiringBow: false, lastAttackTime: 0,
    attributes: { strength: BASE_STAT, dexterity: BASE_STAT, intelligence: BASE_STAT, constitution: BASE_STAT },
    level: 1, xp: 0, xpToNextLevel: BASE_XP_REQ, gold: 25,
    statusEffects: [], attributePoints: 0, skillPoints: 10, skills: {}, assignedSkillPoints: {},
    knownRecipes: [], equipment: {}, actionSlots: new Array(4).fill(null), trackedQuestId: null,
    manaCostMultiplier: 1.0, moveSpeedMultiplier: 1.0,
    lastWorldPosition: null, lastWorldRotationY: null,
    mixer: null, animations: {}, currentAction: null // Para animaciones del jugador
};

    // Controles del Jugador (controls)
    const controls = {
        moveForward: false, moveBackward: false, turnLeft: false, turnRight: false,
        sprint: false, jump: false, dodge: false, // Añadido dodge
        isAttackKeyDown: false, // Si Z o botón móvil está presionado
        block: false, interact: false,
    };
    // Inventario, Hechizos, Misiones
    const inventory = { items: [], maxItems: 25, selectedItemIndex: null };
    const spells = { known: [], selectedSpellIndex: null };
    const quests = { active: [], completed: [] };

    // Cámara
    const cameraOffset = new THREE.Vector3(0, 4.5, 7.0);
    let currentCameraPosition = new THREE.Vector3();

    // Respawn Point
    const RESPAWN_POINT = new THREE.Vector3(5, 0, 5);

    // Datos del Mundo (world)
    const world = {
        // Ya no se usa terrain y water globales, se manejan por chunks
        // terrain: null,
        // water: null,
        objects: [], // Todos los objetos estáticos CARGADOS (árboles, rocas, edificios, estaciones)
        npcs: [], // NPCs activos
        enemies: [], // Enemigos activos
        items: [], // Items en el suelo (pickups)
        interactables: [], // Objetos con los que se puede interactuar (NPCs, cofres, nodos, shrines, etc.)
        particles: [], // Partículas 2D (texto flotante, efectos)
        activeProjectiles: [], // Proyectiles en vuelo
        activeAOEs: [], // Áreas de efecto activas
        dungeon: {}, // Contenedor para elementos específicos de la mazmorra actual
        worldStateData: { // Estado persistente del mundo
            openedChests: new Set(),
            depletedNodes: {}, // { nodeId: timestamp }
            leverStates: {} // { leverId: state }
        },
        // Los límites ahora podrían ser dinámicos o basados en tamaño de worldData
        get worldBounds() {
             const size = worldData?.size || {width: WORLD_SIZE, depth: WORLD_SIZE};
             return { minX: -size.width/2, maxX: size.width/2, minZ: -size.depth/2, maxZ: size.depth/2 };
        },
        weatherSystem: { // Sistema de clima
            active: false, type: 'clear', intensity: 0, particles: [], update: ()=>{}, setWeather: ()=>{}
        },
        // cities y roads ahora están dentro de worldData
    };

    // === TERRAIN NOISE PARAMS ===
    const TERRAIN_NOISE_PARAMS = {
        regionScale:      { frequency: 0.0015, amplitude: 0.60 },
        mountainRangeScale:{ frequency: 0.005, amplitude: 0.50 },
        largeScale:       { frequency: 0.008, amplitude: 1.0 }, // Added/Confirmed
        hillScale:        { frequency: 0.022, amplitude: 0.40 },
        detailScale:      { frequency: 0.08, amplitude: 0.10 },
        roughnessScale:   { frequency: 0.30, amplitude: 0.05 }
    };
    const TERRAIN_HEIGHT_POWER = 1.7;

    const BIOME_PARAMS = {
        tempScale: 0.009, moistureScale: 0.012,
        tempCold: 0.35, tempWarm: 0.65,
        moistureDry: 0.3, moistureWet: 0.65,
        // Umbrales de altura ajustados a la nueva escala
        heightMountain: TERRAIN_HEIGHT_SCALE * 0.55, // Montañas empiezan un poco antes
        heightHill: TERRAIN_HEIGHT_SCALE * 0.20,
        heightBeach: WATER_LEVEL + 1.8,
        heightSwampMax: TERRAIN_HEIGHT_SCALE * 0.15,
        moistureSwampMin: 0.68, tempSwampMin: 0.4, tempSwampMax: 0.75,
    };
    
    
    
    // === ChunkManager (COMPLETO - Sin cambios internos necesarios para los bugs reportados) ===
    const ChunkManager = {
        activeChunks: new Map(), // Almacena datos y mallas de chunks activos { key: { terrainMesh, objects: [], data: {...} } }
        playerChunkCoords: { x: -Infinity, z: -Infinity }, // Coordenadas del chunk donde está el jugador
        loadRadius: 1,           // Radio (en chunks) alrededor del jugador para cargar
        unloadMargin: 1,         // Margen adicional (en chunks) antes de descargar
        sceneRef: null,          // Referencia a la escena principal de THREE.js
        worldDataSource: null,   // Referencia a worldData (contiene tamaño, chunkSize, etc.)
        loadingQueue: new Set(), // Set de keys de chunks ('x_z') esperando ser cargados
        unloadQueue: new Set(),  // Set de keys de chunks ('x_z') esperando ser descargados
        chunkDataCache: new Map(), // Cache para datos generados (altura, biomas, objetos)
        MAX_CHUNK_CACHE_SIZE: 200, // Número máximo de datos de chunks a mantener en caché
        currentLoadingChunkKey: null, // Key del chunk que se está cargando actualmente
        currentLoadingStage: 0, // Etapa actual de carga (0=idle, 1=genData, 2=createTerrain, 3=instanceObjects)
        currentLoadingObjectBatch: [], // Array de datos de objetos a instanciar para el chunk actual
        OBJECTS_PER_FRAME: 10, // Objetos a instanciar por frame durante la carga incremental
        isInitialLoadingComplete: false, // Flag para indicar si la carga inicial ha terminado
        totalInitialChunks: 0, // Contador para la pantalla de carga inicial
        initialChunksLoadedCount: 0, // Contador para la pantalla de carga inicial
        initialChunkKeysBeingLoaded: null, // Set de keys de chunks de la carga inicial

        // --- Helpers Internos _getBaseHeightAndBiome, _getFinalTerrainHeightAndBiome ---
        /**
         * Calcula la altura base y el bioma en un punto SIN considerar carreteras/ciudades.
         * (Función interna v3 - Sin cambios)
         */
        _getBaseHeightAndBiome(worldX, worldZ) {
             if (!simplexHeight || !tempNoise || !moistureNoise || !TERRAIN_NOISE_PARAMS || !BIOME_PARAMS || !this.worldDataSource) {
                 console.error("_getBaseHeightAndBiome: Dependencias no inicializadas!");
                 return { baseHeight: WATER_LEVEL, baseBiomeId: this.worldDataSource?.getBiomeId('grassland') ?? 2 };
             }
             let noiseVal = 0; const p = TERRAIN_NOISE_PARAMS;
             try {
                 noiseVal += (simplexHeight.noise2D(worldX * p.regionScale.frequency, worldZ * p.regionScale.frequency)) * p.regionScale.amplitude;
                 noiseVal += (simplexHeight.noise2D(worldX * p.mountainRangeScale.frequency, worldZ * p.mountainRangeScale.frequency)) * p.mountainRangeScale.amplitude;
                 noiseVal += (simplexHeight.noise2D(worldX * p.largeScale.frequency, worldZ * p.largeScale.frequency)) * p.largeScale.amplitude;
                 const regionNoise = (simplexHeight.noise2D(worldX * p.regionScale.frequency * 0.5, worldZ * p.regionScale.frequency * 0.5) + 1) * 0.5; // 0 a 1
                 const hillAmp = p.hillScale.amplitude * regionNoise; const detailAmp = p.detailScale.amplitude * (0.5 + regionNoise * 0.5); const roughAmp = p.roughnessScale.amplitude * (0.2 + regionNoise * 0.8);
                 noiseVal += (simplexHeight.noise2D(worldX * p.hillScale.frequency, worldZ * p.hillScale.frequency)) * hillAmp;
                 noiseVal += (simplexHeight.noise2D(worldX * p.detailScale.frequency, worldZ * p.detailScale.frequency)) * detailAmp;
                 noiseVal += (simplexHeight.noise2D(worldX * p.roughnessScale.frequency, worldZ * p.roughnessScale.frequency)) * roughAmp;
             } catch (e) { console.error("Error Simplex Noise:", e); noiseVal = 0; }
             const totalAmplitude = p.regionScale.amplitude + p.mountainRangeScale.amplitude + p.largeScale.amplitude + p.hillScale.amplitude + p.detailScale.amplitude + p.roughnessScale.amplitude;
             let normalizedNoise = totalAmplitude > 0 ? (noiseVal / totalAmplitude * 0.5 + 0.5) : 0.5;
             normalizedNoise = Math.max(0, Math.min(1, normalizedNoise)); // Clamp 0-1
             let baseHeight = Math.pow(normalizedNoise, TERRAIN_HEIGHT_POWER) * TERRAIN_HEIGHT_SCALE;
             baseHeight = Math.max(WATER_LEVEL - 5, baseHeight); // Asegurar que no vaya demasiado bajo

             // Cálculo Bioma Base
             const bp = BIOME_PARAMS;
             const tempValue = (tempNoise.noise2D(worldX * bp.tempScale, worldZ * bp.tempScale) * 0.5 + 0.5);
             const moistureValue = (moistureNoise.noise2D(worldX * bp.moistureScale, worldZ * bp.moistureScale) * 0.5 + 0.5);
             let baseBiomeId;

             if (baseHeight < WATER_LEVEL) baseBiomeId = this.worldDataSource.getBiomeId('water');
             else if (baseHeight < bp.heightBeach) baseBiomeId = this.worldDataSource.getBiomeId('beach');
             else if (baseHeight >= bp.heightMountain) { if (tempValue < bp.tempCold) baseBiomeId = this.worldDataSource.getBiomeId('snow'); else baseBiomeId = this.worldDataSource.getBiomeId('mountains_rocky'); }
             else if (baseHeight >= bp.heightHill) { if (tempValue < bp.tempCold * 1.1 && moistureValue > 0.45) baseBiomeId = this.worldDataSource.getBiomeId('taiga'); else baseBiomeId = this.worldDataSource.getBiomeId('hills'); }
             else { // Tierras bajas/planas
                 if (tempValue < bp.tempCold) { if (moistureValue < bp.moistureDry * 1.2) baseBiomeId = this.worldDataSource.getBiomeId('tundra'); else baseBiomeId = this.worldDataSource.getBiomeId('taiga'); }
                 else if (tempValue > bp.tempWarm) { if (moistureValue < bp.moistureDry) baseBiomeId = this.worldDataSource.getBiomeId('desert'); else baseBiomeId = this.worldDataSource.getBiomeId('jungle'); }
                 else { // Templado
                     if (moistureValue > bp.moistureSwampMin && baseHeight < bp.heightSwampMax && tempValue > bp.tempSwampMin && tempValue < bp.tempSwampMax) { baseBiomeId = this.worldDataSource.getBiomeId('swamp'); }
                     else if (moistureValue > bp.moistureWet * 0.85) { baseBiomeId = this.worldDataSource.getBiomeId('forest_dense'); }
                     else if (moistureValue > bp.moistureDry * 1.1) { baseBiomeId = this.worldDataSource.getBiomeId('forest'); }
                     else { baseBiomeId = this.worldDataSource.getBiomeId('grassland'); }
                 }
             }
             baseBiomeId = baseBiomeId ?? this.worldDataSource.getBiomeId('grassland'); // Fallback final
             return { baseHeight, baseBiomeId };
         },

        _getFinalTerrainHeightAndBiome(worldX, worldZ) {
             let { baseHeight, baseBiomeId } = this._getBaseHeightAndBiome(worldX, worldZ);
             let finalHeight = baseHeight; let finalBiomeId = baseBiomeId;
             let isInsideCity = false; let cityDefinition = null;

             if (finalBiomeId !== this.worldDataSource?.getBiomeId('water') && this.worldDataSource?.cities) {
                 for (const city of (this.worldDataSource.cities)) {
                     if (!city.center || !city.radius) continue;
                     const distSq = (worldX - city.center.x)**2 + (worldZ - city.center.z)**2;
                     const cityRadiusSq = city.radius**2;

                     if (distSq < cityRadiusSq) { // Punto DENTRO del radio de la ciudad
                         isInsideCity = true; cityDefinition = city;
                         finalHeight = city.terrainHeight ?? 1.0; // Aplanar a la altura definida o 1.0 por defecto
                         finalBiomeId = this.worldDataSource.getBiomeId('city'); // Marcar como ciudad
                         break; // Solo una ciudad afecta
                     } else {
                         // Opcional: Suavizado en los bordes (si no se quiere borde duro)
                         // const influenceRadiusSq = cityRadiusSq * 1.2; // Radio de influencia un poco mayor
                         // if (distSq < influenceRadiusSq) {
                         //    const cityBaseHeight = city.terrainHeight ?? 1.0;
                         //    const cityInfluence = Math.max(0, 1 - (Math.sqrt(distSq) - city.radius) / (city.radius * 0.2)); // Fade out suave
                         //    finalHeight = THREE.MathUtils.lerp(baseHeight, cityBaseHeight, cityInfluence * 0.95); // Aplanar casi completamente
                         // }
                     }
                 }
             }

             if (!isInsideCity) { // Aplicar influencia de carretera SOLO si no está dentro de una ciudad
                 const roadInfluence = typeof getRoadInfluence === 'function' ? getRoadInfluence(worldX, worldZ) : 0;
                 if (roadInfluence > 0.1 && finalBiomeId !== this.worldDataSource?.getBiomeId('water')) {
                      finalBiomeId = this.worldDataSource.getBiomeId('road');
                      // NO modificar altura por carretera
                 }
             }

             if (finalHeight < WATER_LEVEL && finalBiomeId !== this.worldDataSource?.getBiomeId('water')) {
                 finalHeight = WATER_LEVEL + 0.05;
             }

             return { height: finalHeight, biomeId: finalBiomeId };
         },
        // --- Inicialización (init) ---
        /**
         * Inicializa el ChunkManager.
         * @param {THREE.Scene} sceneInstance - La escena principal del juego.
         * @param {object} worldDataSourceRef - Referencia al objeto worldData.
         */
        init(sceneInstance, worldDataSourceRef) {
            this.sceneRef = sceneInstance;
            this.worldDataSource = worldDataSourceRef;
            this.activeChunks.clear();
            this.chunkDataCache.clear();
            this.loadingQueue.clear();
            this.unloadQueue.clear();
            this.playerChunkCoords = { x: -Infinity, z: -Infinity };
            this.currentLoadingChunkKey = null;
            this.currentLoadingStage = 0;
            this.currentLoadingObjectBatch = [];
            this.isInitialLoadingComplete = false;
            this.initialChunksLoadedCount = 0;
            this.totalInitialChunks = 0;
            this.initialChunkKeysBeingLoaded = null;
            console.log(`ChunkManager inicializado. Load Radius: ${this.loadRadius}, Unload Margin: ${this.unloadMargin}, Cache Size: ${this.MAX_CHUNK_CACHE_SIZE}, Objs/Frame: ${this.OBJECTS_PER_FRAME}`);

            // Precalcular segmentos de carretera para getRoadInfluence
            this.worldDataSource.roadSegments = [];
            (this.worldDataSource.mainRoads || []).forEach(road => {
                 if (!road.points || road.points.length < 2) return;
                 for (let i = 0; i < road.points.length - 1; i++) {
                     const p1 = road.points[i]; const p2 = road.points[i + 1];
                     if (p1 && p2) {
                         this.worldDataSource.roadSegments.push({
                             start: new THREE.Vector3(p1.x, 0, p1.z),
                             end: new THREE.Vector3(p2.x, 0, p2.z)
                         });
                     }
                 }
            });

            // Precalcular altura inicial del punto de respawn
            if (typeof RESPAWN_POINT !== 'undefined' && RESPAWN_POINT instanceof THREE.Vector3) {
                 try {
                     RESPAWN_POINT.y = this.getTerrainHeightAt(RESPAWN_POINT.x, RESPAWN_POINT.z);
                     console.log(`RESPAWN_POINT Y calculado a: ${RESPAWN_POINT.y.toFixed(2)}`);
                 } catch(e) {
                     console.error("Error calculando Y inicial de respawn, usando default.", e);
                     RESPAWN_POINT.y = 1.0;
                 }
            } else { console.error("RESPAWN_POINT no definido correctamente antes de ChunkManager.init()"); }

            // Precalcular objetos y spawns
            this.precalculateChunkObjects();
            this.precalculateEnemySpawnPoints();
        },

        // --- Precalculo (precalculateChunkObjects, precalculateEnemySpawnPoints) ---
        /** Precalcula qué objetos estáticos (edificios, POIs, spawns NPC) pertenecen a cada chunk. */
        precalculateChunkObjects() {
            console.log("Precalculando objetos estáticos (v3 - Posición Directa)...");
            if (!this.worldDataSource || !this.sceneRef) { console.error("Precalculo fallido: worldData o sceneRef no disponibles."); return; }
            this.worldDataSource.chunkObjects = new Map(); // { 'x_z': [objData1, objData2...] }
            const worldCs = this.worldDataSource.chunkSize;
            const worldHalfW = this.worldDataSource.size.width / 2;
            const worldHalfD = this.worldDataSource.size.depth / 2;

            // Función helper para añadir objeto a su chunk correspondiente
            const addObjectToChunk = (objectData, objectWorldX, objectWorldZ) => {
                const cx = Math.floor((objectWorldX + worldHalfW) / worldCs);
                const cz = Math.floor((objectWorldZ + worldHalfD) / worldCs);
                const key = `${cx}_${cz}`;
                // Ignorar si está fuera de los límites del mundo
                if (cx < 0 || cx >= this.worldDataSource.numChunksX || cz < 0 || cz >= this.worldDataSource.numChunksZ) { return; }
                if (!this.worldDataSource.chunkObjects.has(key)) { this.worldDataSource.chunkObjects.set(key, []); }
                // Calcular Y final si no está definida y quitar objeto 'pos' anidado
                if (objectData.pos) {
                    objectData.x = objectData.pos.x; objectData.z = objectData.pos.z;
                    if (objectData.y === undefined) {
                        const { height: finalY } = this._getFinalTerrainHeightAndBiome(objectData.x, objectData.z);
                        objectData.y = finalY;
                    }
                    delete objectData.pos;
                }
                this.worldDataSource.chunkObjects.get(key).push(objectData);
            };

            let buildingCount = 0, npcMarkerCount = 0, poiCount = 0;

            // Procesar Edificios y NPCs de Ciudades
            (this.worldDataSource.cities || []).forEach(city => {
                 (city.districts || []).forEach(district => {
                     // Edificios
                     (district.buildings || []).forEach(building => {
                         if (!building.id || !building.pos) return;
                         // La altura Y se calculará en addObjectToChunk si no está presente
                         addObjectToChunk({ ...building, type: 'building', defId: building.id, originCity: city.id, originDistrict: district.type || district.name }, building.pos.x, building.pos.z);
                         buildingCount++;
                     });
                     // NPCs (Marcadores de Spawn)
                     (district.npcs || []).forEach(npcSpawn => {
                         if (!npcSpawn.type || !npcSpawn.pos) return;
                          // La altura Y se calculará en addObjectToChunk
                         addObjectToChunk({ type: 'npc_spawn_marker', npcType: npcSpawn.type, pos: npcSpawn.pos, rotY: npcSpawn.rotY || 0, originCity: city.id, originDistrict: district.type || district.name }, npcSpawn.pos.x, npcSpawn.pos.z);
                         npcMarkerCount++;
                     });
                 });
            });

            // Procesar POIs y Entradas Dungeon (Special Locations)
            (this.worldDataSource.specialLocations || []).forEach(loc => {
                if (!loc.pos || !loc.id || !loc.type) return;
                // Asegurar visualDefId o crear placeholder
                if (!loc.visualDefId) loc.visualDefId = `placeholder_${loc.type}`;
                // La altura Y se calculará en addObjectToChunk
                addObjectToChunk({ ...loc, defId: loc.id }, loc.pos.x, loc.pos.z);
                poiCount++;
            });

            console.log(`Precalculo objetos estáticos (v3): ${buildingCount} edificios, ${npcMarkerCount} marcadores NPC, ${poiCount} POIs/Dungeons.`);
        },

        /** Precalcula qué puntos de spawn de enemigos pertenecen a cada chunk. */
        precalculateEnemySpawnPoints() {
            if (!this.worldDataSource) { console.error("precalc Enemy Spawns: worldDataSource no definido."); return; }
            this.worldDataSource.chunkEnemySpawnPoints = new Map(); // { 'x_z': [spawnPointData1, ...] }
            const worldCs = this.worldDataSource.chunkSize;
            const worldHalfW = this.worldDataSource.size.width / 2;
            const worldHalfD = this.worldDataSource.size.depth / 2;

            (this.worldDataSource.enemySpawns || []).forEach((spawnDef, spawnDefIndex) => {
                const enemyType = spawnDef.type;
                if (!enemyDefinitions[enemyType]) { console.warn(`precalc Enemy Spawns: Tipo enemigo ${enemyType} no definido.`); return; }
                const count = spawnDef.count || 1; const center = spawnDef.center || { x: 0, z: 0 }; const radius = spawnDef.radius || 10;
                const respawnTime = spawnDef.respawn || (enemyDefinitions[enemyType].isUnique ? UNIQUE_ENEMY_RESPAWN_TIME : ENEMY_RESPAWN_TIME);

                for (let i = 0; i < count; i++) {
                     let worldX, worldZ, finalY, cx, cz, key; let attempts = 0; let positionFound = false;
                     while (attempts < 20 && !positionFound) { // Intentar encontrar posición válida
                          attempts++;
                          const angle = Math.random() * Math.PI * 2; const distance = Math.random() * radius;
                          worldX = center.x + Math.cos(angle) * distance; worldZ = center.z + Math.sin(angle) * distance;
                          const { height: calculatedY, biomeId } = this._getFinalTerrainHeightAndBiome(worldX, worldZ); finalY = calculatedY;
                          const cityId = getCityAtPosition(worldX, worldZ); // <-- Usa función global
                          const inSafeZone = cityId && this.worldDataSource.cities.find(c => c.id === cityId)?.isSafeZone;

                          if (biomeId !== this.worldDataSource.getBiomeId('water') && !inSafeZone) { // Fuera de agua y zona segura
                               cx = Math.floor((worldX + worldHalfW) / worldCs); cz = Math.floor((worldZ + worldHalfD) / worldCs);
                               if (cx >= 0 && cx < this.worldDataSource.numChunksX && cz >= 0 && cz < this.worldDataSource.numChunksZ) {
                                   key = `${cx}_${cz}`; positionFound = true;
                               }
                          }
                     }
                     if (positionFound) {
                          const spawnPointId = `spawn_${enemyType}_${spawnDefIndex}_${i}`;
                          const spawnPointData = {
                              id: spawnPointId, type: 'enemy_spawn_point', enemyType: enemyType,
                              x: worldX, y: finalY, z: worldZ, // Guardar coords finales
                              respawnTime: respawnTime, isUnique: enemyDefinitions[enemyType].isUnique || false,
                              lastDeathTime: 0, isSpawned: false, activeEnemyUUID: null, originChunkKey: key
                          };
                          if (!this.worldDataSource.chunkEnemySpawnPoints.has(key)) this.worldDataSource.chunkEnemySpawnPoints.set(key, []);
                          this.worldDataSource.chunkEnemySpawnPoints.get(key).push(spawnPointData);
                     } else { console.warn(`No se pudo encontrar posición válida (fuera de agua/SZ) para enemigo ${enemyType} cerca de (${center.x}, ${center.z})`); }
                }
            });
            console.log("Precalculo de puntos de spawn de enemigos (v3 - Posición Corregida) completado.");
        },

        // --- Update y Gestión de Colas (update, processUnloadQueue) ---
        /**
         * Lógica principal para actualizar chunks según la posición del jugador.
         * Determina qué chunks cargar y descargar.
         * (v3 - Sin cambios)
         * @param {THREE.Vector3} playerPosition - Posición actual del jugador.
         */
        update(playerPosition) {
            // <<< MODIFY THIS CHECK >>>
            // Only check if initial loading is complete and essential refs exist
            // REMOVE the !gameState.isGhost check if it exists here.
            if (!this.isInitialLoadingComplete || !this.sceneRef || !this.worldDataSource || !playerPosition) {
                 // console.warn("ChunkManager.update skipped: Initial load incomplete or missing refs.");
                 return;
            }
            // <<< END MODIFICATION >>>

            const worldCs = this.worldDataSource.chunkSize;
            const worldHalfW = this.worldDataSource.size.width / 2;
            const worldHalfD = this.worldDataSource.size.depth / 2;
            const currentChunkX = Math.floor((playerPosition.x + worldHalfW) / worldCs);
            const currentChunkZ = Math.floor((playerPosition.z + worldHalfD) / worldCs);

            // Only recalculate if the player changed chunk OR if it's the very first update
            if (currentChunkX !== this.playerChunkCoords.x || currentChunkZ !== this.playerChunkCoords.z) {
                this.playerChunkCoords.x = currentChunkX;
                this.playerChunkCoords.z = currentChunkZ;
                console.log(`ChunkManager: Player moved to chunk: ${currentChunkX}, ${currentChunkZ}. Updating required chunks...`); // More informative log

                const requiredChunks = new Set();
                const maxLoadDist = this.loadRadius;
                const minUnloadDist = this.loadRadius + this.unloadMargin;

                // Calculate boundaries (same as before)
                const minCX = Math.max(0, currentChunkX - maxLoadDist);
                const maxCX = Math.min(this.worldDataSource.numChunksX - 1, currentChunkX + maxLoadDist);
                const minCZ = Math.max(0, currentChunkZ - maxLoadDist);
                const maxCZ = Math.min(this.worldDataSource.numChunksZ - 1, currentChunkZ + maxLoadDist);

                // Populate required chunks (same as before)
                for (let cz = minCZ; cz <= maxCZ; cz++) {
                    for (let cx = minCX; cx <= maxCX; cx++) {
                        requiredChunks.add(`${cx}_${cz}`);
                    }
                }

                // Identify chunks to unload (same as before)
                this.activeChunks.forEach((chunkData, key) => {
                    if (!requiredChunks.has(key)) {
                        const [cx, cz] = key.split('_').map(Number);
                        const distSq = (cx - currentChunkX)**2 + (cz - currentChunkZ)**2;
                        if (distSq > minUnloadDist * minUnloadDist) {
                            this.unloadQueue.add(key);
                        }
                    }
                });

                // Identify chunks to load (same as before)
                requiredChunks.forEach(key => {
                    if (!this.activeChunks.has(key) && !this.loadingQueue.has(key) && this.currentLoadingChunkKey !== key) {
                        this.loadingQueue.add(key);
                    }
                });

                this.processUnloadQueue(); // Process unload immediately
            }

            this.processLoadQueueIncremental(); // Process load queue incrementally
        },
        /** Procesa los chunks marcados para descarga. */
        processUnloadQueue() {
            this.unloadQueue.forEach(key => {
                this.unloadChunkByKey(key);
            });
            this.unloadQueue.clear();
        },

        // --- unloadChunkByKey (CON LIMPIEZA DE RECURSOS) ---
        /**
         * Descarga un chunk específico, eliminando su malla y objetos de la escena.
         * Incluye dispose de geometría/materiales y llamada a despawnEnemies.
         * (v3.1 - Dispose Robusto)
         * @param {string} key - La clave del chunk ('x_z').
         */
        unloadChunkByKey(key) {
            const chunkDataContainer = this.activeChunks.get(key);
            if (!chunkDataContainer) {
                // Si no está activo, asegurarse de que no esté en colas o caché
                this.loadingQueue.delete(key);
                this.unloadQueue.delete(key);
                this.chunkDataCache.delete(key);
                return;
            }
            // No descargar si se está cargando activamente
            if(this.currentLoadingChunkKey === key) {
                this.unloadQueue.delete(key); // Quitar de la cola pero no descargar
                return;
            }

            console.log(`Unloading chunk ${key}...`);

            // Despawnear enemigos asociados (si existe EnemySpawner)
            if (typeof EnemySpawner !== 'undefined') EnemySpawner.despawnEnemiesFromChunk(key);

            // Eliminar Terreno y Disponer Recursos
            if (chunkDataContainer.terrainMesh) {
                try {
                    if (chunkDataContainer.terrainMesh.parent) {
                        this.sceneRef.remove(chunkDataContainer.terrainMesh);
                    }
                    chunkDataContainer.terrainMesh.geometry?.dispose(); // Dispose geometría
                    const mat = chunkDataContainer.terrainMesh.material;
                    if (mat) { // Dispose material(es)
                        if (Array.isArray(mat)) { mat.forEach(m => { m.map?.dispose(); m.dispose(); }); }
                        else { mat.map?.dispose(); mat.dispose(); }
                    }
                } catch (e) { console.error(`Error disposing terrain ${key}:`, e); }
                chunkDataContainer.terrainMesh = null; // Liberar referencia
            }

            // Eliminar Objetos y Disponer Recursos
            // Copiar array para evitar problemas al modificarlo mientras se itera
            const objectsToProcess = [...(chunkDataContainer.objects || [])];
            objectsToProcess.forEach(obj => {
                if (!obj) return;
                const objUUID = obj.uuid;
                try {
                    // Remover de listas globales (world.objects, world.interactables, etc.)
                    const globalIndex = world.objects.indexOf(obj); if (globalIndex > -1) world.objects.splice(globalIndex, 1);
                    const interactableIndex = world.interactables.indexOf(obj); if (interactableIndex > -1) world.interactables.splice(interactableIndex, 1);
                    const npcIndex = world.npcs.indexOf(obj); if (npcIndex > -1) world.npcs.splice(npcIndex, 1); // Si los NPCs están en esta lista
                    const enemyIndex = world.enemies.indexOf(obj); if (enemyIndex > -1) world.enemies.splice(enemyIndex, 1); // Si los enemigos están aquí (aunque EnemySpawner debería manejarlos)

                    // Remover de la escena
                    if (obj.parent) this.sceneRef.remove(obj);

                    // Dispose recursivo de geometría/materiales
                    obj.traverse(child => {
                        if (child.isMesh) {
                            child.geometry?.dispose();
                            if (child.material) {
                                const mats = Array.isArray(child.material) ? child.material : [child.material];
                                mats.forEach(m => {
                                    m.map?.dispose(); m.lightMap?.dispose(); m.aoMap?.dispose(); m.emissiveMap?.dispose();
                                    m.bumpMap?.dispose(); m.normalMap?.dispose(); m.displacementMap?.dispose(); m.roughnessMap?.dispose();
                                    m.metalnessMap?.dispose(); m.alphaMap?.dispose(); m.envMap?.dispose(); m.dispose();
                                });
                            }
                        }
                    });
                } catch (e) { console.error(`Error removing/disposing object ${objUUID} from chunk ${key}:`, e); }
            });
            chunkDataContainer.objects = []; // Vaciar array en el contenedor

            // Eliminar de activeChunks y caché
            this.activeChunks.delete(key);
            this.chunkDataCache.delete(key); // Quitar del caché también al descargar
             console.log(`   Chunk ${key} unloaded successfully.`);
        },

        // --- Generación de Datos (generateChunkData) ---
        /**
         * Genera o recupera de caché los datos de altura, bioma y objetos para un chunk.
         * (v3.1 - Mejor Cache LRU, Spawn Procedural Básico)
         * @param {number} chunkX - Coordenada X del chunk.
         * @param {number} chunkZ - Coordenada Z del chunk.
         * @returns {object | null} Los datos del chunk o null si falla.
         */
        generateChunkData(chunkX, chunkZ) {
            const key = `${chunkX}_${chunkZ}`;

            // 1. Comprobar Caché
            if (this.chunkDataCache.has(key)) { return this.chunkDataCache.get(key); }
            // Limpieza simple de caché (LRU básico: elimina el más antiguo si excede límite)
            if (this.chunkDataCache.size >= this.MAX_CHUNK_CACHE_SIZE) {
                const firstKey = this.chunkDataCache.keys().next().value; if (firstKey) { this.chunkDataCache.delete(firstKey); }
            }

            // 2. Obtener Parámetros
            if (!this.worldDataSource) { console.error("generateChunkData: worldDataSource no definido."); return null; }
            const worldCs = this.worldDataSource.chunkSize; const res = this.worldDataSource.resolution;
            const vertsPerEdge = this.worldDataSource.verticesPerChunkEdge; const numVerts = (vertsPerEdge + 1) * (vertsPerEdge + 1);
            const heightData = new Float32Array(numVerts); const biomeData = new Uint8Array(numVerts); const objectData = [];
            const chunkWorldXStart = chunkX * worldCs - this.worldDataSource.size.width / 2;
            const chunkWorldZStart = chunkZ * worldCs - this.worldDataSource.size.depth / 2;
            const segmentSize = 1 / res;

            // 3. Añadir Objetos Precalculados (Edificios, POIs, Spawns)
            const precalculatedObjects = this.worldDataSource.chunkObjects?.get(key) || [];
            objectData.push(...precalculatedObjects);
            // Preparar datos para evitar solapamiento procedural
            const precalcPositions = precalculatedObjects.filter(obj => obj.type === 'building' || obj.type === 'landmark' || obj.type === 'dungeon_entrance')
                .map(obj => ({ x: obj.x, z: obj.z, radiusSq: (obj.avgBuildingSize || obj.radius || 8) ** 2 }));
            const enemySpawnPoints = this.worldDataSource.chunkEnemySpawnPoints?.get(key) || [];
            objectData.push(...enemySpawnPoints);

            // 4. Generar Datos de Terreno (Altura y Bioma Final)
            for (let z = 0; z <= vertsPerEdge; z++) {
                for (let x = 0; x <= vertsPerEdge; x++) {
                    const index = z * (vertsPerEdge + 1) + x; const worldX = chunkWorldXStart + x * segmentSize; const worldZ = chunkWorldZStart + z * segmentSize;
                    const { height, biomeId } = this._getFinalTerrainHeightAndBiome(worldX, worldZ);
                    heightData[index] = height; biomeData[index] = biomeId;
                }
            }

            // 5. Generación Procedural (Árboles, Rocas, Recursos Menores)
            const placementNoise = simplexObjects || new SimplexNoise(worldSeed + 3); const placementStep = 3.5; const jitter = placementStep * 0.45; const minProceduralSpacingSq = 2.5 * 2.5; const proceduralPositions = [];
            for (let z = 0; z < vertsPerEdge; z += placementStep) {
                for (let x = 0; x < vertsPerEdge; x += placementStep) {
                    const cellWorldX = chunkWorldXStart + (x + (Math.random() * 2 - 1) * jitter) * segmentSize; const cellWorldZ = chunkWorldZStart + (z + (Math.random() * 2 - 1) * jitter) * segmentSize;
                    const { height: objHeight, biomeId: objBiomeId } = this._getFinalTerrainHeightAndBiome(cellWorldX, cellWorldZ); const biomeName = this.worldDataSource.getBiomeName(objBiomeId);
                    if (['water', 'road', 'city'].includes(biomeName)) continue; // No colocar en estas zonas base
                    // Evitar solapamiento con objetos precalculados y otros procedurales
                    let tooClosePrecalc = precalcPositions.some(p => (cellWorldX - p.x)**2 + (cellWorldZ - p.z)**2 < p.radiusSq * 1.2); if (tooClosePrecalc) continue;
                    let tooCloseProcedural = proceduralPositions.some(p => (cellWorldX - p.x)**2 + (cellWorldZ - p.z)**2 < minProceduralSpacingSq); if (tooCloseProcedural) continue;

                    const placementRoll = Math.random(); let placedInCell = false;

                    // Intentar colocar Recursos (prioridad sobre scenery)
                    if (!placedInCell && resourceDefinitions) {
                        for (const resId in resourceDefinitions) {
                            const resDef = resourceDefinitions[resId];
                            if (resDef.biomes?.includes(biomeName) && placementRoll < (resDef.spawnChance || 0.01)) {
                                if (resDef.resourceType !== 'wood') { // Madera se maneja con árboles
                                    objectData.push({ defId: resId, type: 'resource', resourceType: resDef.resourceType, x: cellWorldX, y: objHeight, z: cellWorldZ, rotY: Math.random() * Math.PI * 2, scale: 1.0 });
                                    placedInCell = true; break;
                                }
                            }
                        }
                    }
                    // Intentar colocar Árboles (si no se puso recurso)
                    const treeBiomes = ['forest', 'forest_dense', 'taiga', 'hills', 'grassland', 'swamp', 'forest_elfic'];
                    const treeSpawnChance = { forest_dense: 0.4, forest: 0.3, taiga: 0.3, hills: 0.25, grassland: 0.1, swamp: 0.08, forest_elfic: 0.35 };
                    if (!placedInCell && treeBiomes.includes(biomeName) && placementRoll < (treeSpawnChance[biomeName] || 0)) {
                        const treeType = (biomeName === 'taiga' || (biomeName === 'hills' && Math.random() > 0.6)) ? 'tree_pine' : (biomeName === 'forest_elfic' ? 'tree_elfic' : (biomeName === 'swamp' ? 'tree_swamp' : 'tree_oak'));
                        const woodResourceDef = resourceDefinitions.wood_tree_common; // Asumir que existe esta definición
                        if (woodResourceDef) {
                            objectData.push({
                                defId: treeType, type: 'scenery_tree', x: cellWorldX, y: objHeight, z: cellWorldZ,
                                rotY: Math.random() * Math.PI * 2, scale: 0.8 + Math.random() * 0.4,
                                isResource: true, resourceDefId: woodResourceDef.id, resourceType: 'wood', depleted: false,
                                id: `tree_${Math.round(cellWorldX)}_${Math.round(cellWorldZ)}` // ID único para estado
                            });
                            placedInCell = true;
                        }
                    }
                    // Intentar colocar Rocas (si no se puso árbol/recurso)
                    const rockBiomes = ['hills', 'mountains', 'mountains_rocky', 'ruin', 'desert', 'beach'];
                    if (!placedInCell && rockBiomes.includes(biomeName) && placementRoll < 0.15) {
                        const rockSize = 0.8 + Math.random() * 1.5;
                        objectData.push({ defId: 'rock_generic', type: 'scenery_rock', x: cellWorldX, y: objHeight, z: cellWorldZ, rotY: Math.random() * Math.PI * 2, scale: rockSize });
                        placedInCell = true;
                    }
                    // Intentar colocar Ruinas (si no se puso nada y es bioma ruin)
                    if (!placedInCell && biomeName === 'ruin' && placementRoll < 0.05) {
                        objectData.push({ defId: 'ruin_part_wall', subType: 'wall', type: 'scenery_ruin', x: cellWorldX, y: objHeight, z: cellWorldZ, rotY: Math.random() * Math.PI * 2, scale: 1.0 });
                        placedInCell = true;
                    }

                    if (placedInCell) proceduralPositions.push({ x: cellWorldX, z: cellWorldZ });
                }
            }

            // 6. Empaquetar y Cachear
            const chunkGeneratedData = { heightData, biomeData, objectData, worldXStart: chunkWorldXStart, worldZStart: chunkWorldZStart };
            this.chunkDataCache.set(key, chunkGeneratedData);
            return chunkGeneratedData;
        },

        // --- Carga Incremental (processLoadQueueIncremental, _continueLoadingCurrentChunk) ---
        /** Procesa un chunk de la cola de carga de forma incremental. */
        processLoadQueueIncremental() {
            if (this.currentLoadingChunkKey) {
                // Continuar cargando el chunk actual si hay uno en progreso
                this._continueLoadingCurrentChunk();
                return;
            }
            if (this.loadingQueue.size > 0) {
                // Sacar el siguiente chunk de la cola
                const keyToLoad = this.loadingQueue.values().next().value;
                this.loadingQueue.delete(keyToLoad);
                const [cx, cz] = keyToLoad.split('_').map(Number);

                // Validar que el chunk sea válido y no esté ya activo
                if (cx >= 0 && cx < this.worldDataSource.numChunksX && cz >= 0 && cz < this.worldDataSource.numChunksZ && !this.activeChunks.has(keyToLoad)) {
                    // console.log(`Starting incremental load for chunk ${keyToLoad}...`); // DEBUG
                    this.currentLoadingChunkKey = keyToLoad;
                    this.currentLoadingStage = 1; // Empezar con generación de datos
                    this.currentLoadingObjectBatch = [];
                    this._continueLoadingCurrentChunk(); // Ejecutar primera etapa
                }
            } else if (!this.currentLoadingChunkKey && !this.isInitialLoadingComplete && this.initialChunkKeysBeingLoaded === null) {
                 // Caso especial: Si la cola está vacía, no hay carga en curso Y la carga inicial ya terminó (initialChunkKeysBeingLoaded es null)
                 // Podríamos considerar que isInitialLoadDone() es true aquí si no lo era ya
                 // Aunque idealmente isInitialLoadingComplete ya debería ser true
                 if(!this.isInitialLoadingComplete) {
                      console.warn("Loading queue empty, no chunk loading, but initial load flag still false?");
                      // this.isInitialLoadingComplete = true; // Podría forzarse aquí
                 }
            } else if (!this.currentLoadingChunkKey && !this.isInitialLoadingComplete && this.initialChunkKeysBeingLoaded !== null && this.initialChunksLoadedCount >= this.totalInitialChunks ) {
                 // Caso carga inicial: cola vacía, no hay carga en curso, pero el contador dice que terminamos
                 console.log("Initial chunk loading process seems complete based on counts.");
                 this.isInitialLoadingComplete = true;
                 this.initialChunkKeysBeingLoaded = null; // Marcar como terminado
            }
        },

        /** Continúa la carga del chunk actual (`currentLoadingChunkKey`) en su etapa actual. */
        _continueLoadingCurrentChunk() {
            if (!this.currentLoadingChunkKey) return;
            const key = this.currentLoadingChunkKey; const [chunkX, chunkZ] = key.split('_').map(Number);
            try {
                switch (this.currentLoadingStage) {
                    case 1: // Generar/Obtener Datos del Chunk
                        let chunkData = this.chunkDataCache.get(key);
                        if (!chunkData) { chunkData = this.generateChunkData(chunkX, chunkZ); }
                        if (!chunkData) throw new Error("Fallo al generar/obtener datos del chunk.");
                        // Crear contenedor en activeChunks ANTES de pasar a la siguiente etapa
                        this.activeChunks.set(key, { terrainMesh: null, objects: [], data: chunkData });
                        this.currentLoadingStage = 2; // Pasar a crear terreno
                        break;
                    case 2: // Crear Malla de Terreno
                        const loadedChunk = this.activeChunks.get(key);
                        if (!loadedChunk || !loadedChunk.data) throw new Error(`Datos chunk ${key} no encontrados para etapa 2.`);
                        // Llamar a función global createTerrain
                        loadedChunk.terrainMesh = this._createTerrainMesh(chunkX, chunkZ, loadedChunk.data);
                        if (loadedChunk.terrainMesh) {
                            this.sceneRef.add(loadedChunk.terrainMesh);
                            // Preparar lote de objetos para la siguiente etapa
                            this.currentLoadingObjectBatch = [...(loadedChunk.data.objectData || [])];
                            this.currentLoadingStage = 3; // Pasar a instanciar objetos
                        } else {
                            console.error(`Fallo al crear malla de terreno para ${key}. Abortando carga.`);
                            this.activeChunks.delete(key); // Limpiar entrada fallida
                            this._resetLoadingState(true); // Resetear con error
                        }
                        break;
                    case 3: // Instanciar Objetos (Incremental)
                        const chunkContainer = this.activeChunks.get(key);
                        if (!chunkContainer) throw new Error(`Contenedor chunk ${key} no encontrado para etapa 3.`);
                        // Si no quedan objetos por procesar, finalizar
                        if(this.currentLoadingObjectBatch.length === 0) {
                            this._chunkLoadComplete(key); // Marcar como completo
                            this._resetLoadingState();    // Limpiar estado de carga
                            break; // Salir del switch
                        }
                        // Procesar un lote de objetos
                        const objectsToProcess = this.currentLoadingObjectBatch.splice(0, this.OBJECTS_PER_FRAME);
                        // Usar Promise.all para manejar la instanciación asíncrona de cada objeto
                        Promise.all(objectsToProcess.map(objData => this._instanceSingleObject(chunkContainer, objData, key)))
                           .then(() => {
                                // Después de que el lote actual termine (exitoso o no),
                                // verificar si quedan más objetos. Si no, finalizar.
                                if (this.currentLoadingObjectBatch.length === 0) {
                                     this._chunkLoadComplete(key);
                                     this._resetLoadingState();
                                }
                                // Si quedan más objetos, _continueLoadingCurrentChunk se llamará de nuevo en el próximo frame.
                           })
                           .catch(error => {
                                // Error durante la instanciación de objetos
                                console.error(`Error procesando lote objetos chunk ${key}:`, error);
                                // Si ya no quedan objetos en el lote (porque falló al final), finalizar con error
                                if (this.currentLoadingObjectBatch.length === 0) {
                                     this._chunkLoadComplete(key, true); // Marcar como completo con error
                                     this._resetLoadingState(true); // Resetear con error
                                }
                                // Si quedan objetos, podría intentar continuar en el próximo frame,
                                // aunque un error aquí podría indicar un problema mayor.
                           });
                        break; // Salir del switch (la carga de objetos continúa en el siguiente frame)
                    default: // Etapa inválida
                        this._resetLoadingState(true); // Resetear con error
                        break;
                }
            } catch (error) {
                 console.error(`Error cargando chunk ${key} en etapa ${this.currentLoadingStage}:`, error);
                 if (this.activeChunks.has(key)) this.unloadChunkByKey(key); // Intentar limpiar si se añadió parcialmente
                 this._resetLoadingState(true); // Resetear estado con error
            }
        },

        /** Registra que un chunk ha terminado de cargarse. */
        _chunkLoadComplete(chunkKey, hadError = false) {
            // console.log(`Chunk ${chunkKey} load complete ${hadError ? ' (with errors)' : ''}.`); // DEBUG
            // Actualizar contador de carga inicial si aplica
            if (this.initialChunkKeysBeingLoaded?.has(chunkKey)) {
                this.initialChunksLoadedCount++;
                // console.log(`Initial chunks loaded: ${this.initialChunksLoadedCount}/${this.totalInitialChunks}`); // DEBUG
            }
        },

        /** Resetea el estado de carga actual. */
        _resetLoadingState(errorOccurred = false) {
            if (!errorOccurred && this.currentLoadingChunkKey && this.currentLoadingStage !== 3) {
                // console.warn(`_resetLoadingState called for ${this.currentLoadingChunkKey} before object instantiation finished.`);
            }
            this.currentLoadingChunkKey = null;
            this.currentLoadingStage = 0;
            this.currentLoadingObjectBatch = [];
        },

        /** Llama a la función global 'createTerrain'. */
        _createTerrainMesh(chunkX, chunkZ, chunkData) {
            try {
                 // Asegurar que las coordenadas de inicio estén presentes (necesarias para createTerrain)
                 if (chunkData.worldXStart === undefined) chunkData.worldXStart = chunkX * this.worldDataSource.chunkSize - this.worldDataSource.size.width / 2;
                 if (chunkData.worldZStart === undefined) chunkData.worldZStart = chunkZ * this.worldDataSource.chunkSize - this.worldDataSource.size.depth / 2;
                 if (typeof createTerrain !== 'function') throw new Error("La función global 'createTerrain' no está definida.");
                 return createTerrain(chunkX, chunkZ, chunkData); // Pasa los datos al creador global
            } catch (e) {
                 console.error(`Error en _createTerrainMesh para chunk ${chunkX}_${chunkZ}:`, e);
                 return null;
            }
        },

    async _instanceSingleObject(chunkContainer, objData, chunkKey) {
        let objMesh = null;
        const definitionId = objData.defId || objData.id || objData.npcType || objData.enemyType;
        const objType = objData.type;

        if (objData.x === undefined || objData.y === undefined || objData.z === undefined) {
            console.error(`_instanceSingleObject: Faltan datos de posición en objData (ID: ${definitionId || 'unknown'}) en chunk ${chunkKey}`, objData);
            return;
        }
        const objPosition = new THREE.Vector3(objData.x, objData.y, objData.z);
        const objRotationY = objData.rotY || 0;
        const instanceOverrideScale = objData.scale;

        try {
            let isCameraCollidable = false;

            if (objType === 'enemy_spawn_point') {
                if (typeof EnemySpawner !== 'undefined' && typeof EnemySpawner.trySpawnEnemyFromMarker === 'function') {
                    await EnemySpawner.trySpawnEnemyFromMarker(objData).catch(e => console.error(`Error en trySpawnEnemyFromMarker para ${definitionId}:`, e));
                } else { console.warn("EnemySpawner no disponible."); }
                return;
            }
            else if (objType === 'npc_spawn_marker') {
                if (typeof createAndAddNPC === 'function') {
                    await createAndAddNPC(objData.npcType, objPosition, objRotationY).catch(e => console.error(`Error creando NPC ${objData.npcType} desde marcador:`, e));
                } else { console.warn("Función createAndAddNPC no disponible."); }
                return;
            }
             // *** MANEJO DE MODELOS PRECARGADOS vs. OTROS ***
             else if (objType === 'building' && preloadedBuildingModels[definitionId]) {
                  objMesh = preloadedBuildingModels[definitionId].clone(); // CLONAR modelo precargado
                  isCameraCollidable = true;
             }
             else if (objType === 'landmark' && preloadedPOIs[objData.visualDefId || definitionId]) {
                  objMesh = preloadedPOIs[objData.visualDefId || definitionId].clone(); // CLONAR POI precargado
                  isCameraCollidable = objMesh?.userData?.height > 3.0;
             }
             else if (objType === 'dungeon_entrance' && preloadedDungeonEntrances[objData.visualDefId || definitionId]) {
                   objMesh = preloadedDungeonEntrances[objData.visualDefId || definitionId].clone(); // CLONAR entrada precargada
                   isCameraCollidable = true;
             }
             // *** MODELOS NO PRECARGADOS (O FALLO PRECARGA) - Carga dinámica ***
             else if (objType === 'building') { objMesh = await createFunctionalBuilding(definitionId); isCameraCollidable = true; }
             else if (objType === 'landmark') { objMesh = await createPOIModel(objData.visualDefId || definitionId); isCameraCollidable = objMesh?.userData?.height > 3.0; }
             else if (objType === 'dungeon_entrance') { objMesh = await createDungeonEntranceModel(objData.visualDefId || definitionId); isCameraCollidable = true; }
             // --- El resto de tipos (recursos, árboles, etc.) se crean síncronamente ---
             else if (objType === 'resource') { objMesh = createResourceNodeModel(objData.resourceType, definitionId); isCameraCollidable = false; }
             else if (objType === 'scenery_tree') { objMesh = createTreeModel({ type: definitionId?.includes('pine') ? 'pine' : (definitionId?.includes('elfic') ? 'elfic' : (definitionId?.includes('swamp') ? 'swamp' : 'oak')) }); if (objMesh?.userData) { objMesh.userData.id = objData.id || `tree_${Math.round(objData.x)}_${Math.round(objData.z)}`; } isCameraCollidable = true; }
             else if (objType === 'scenery_rock') { objMesh = createRockModel({ size: instanceOverrideScale || 1.0 }); isCameraCollidable = (instanceOverrideScale || 1.0) > 1.2; }
             else if (objType === 'scenery_ruin') { objMesh = createSimpleRuinPiece(objData.subType); isCameraCollidable = true; }
             else if (objType === 'shrine') { objMesh = createShrineModel(objData.effect); isCameraCollidable = true; }
             else if (objType === 'chest') { objMesh = createChestModel(); isCameraCollidable = false; }
             else if (objType === 'crafting_station') { objMesh = createCraftingStationModel(definitionId); isCameraCollidable = true; }
             else { console.warn(`_instanceSingleObject: Tipo de objeto visual no manejado '${objType}'. Saltando.`); return; }

            if (objMesh && objMesh instanceof THREE.Object3D) {
                objMesh.position.copy(objPosition); objMesh.rotation.y = objRotationY;
                let finalScale = 1.0;
                if (objType === 'scenery_tree' || objType === 'scenery_rock') { finalScale = instanceOverrideScale || 1.0; finalScale = Math.max(0.5, Math.min(objType === 'scenery_tree' ? 1.8 : 2.5, finalScale)); }
                else {
                    let scaleInfo = null; let defaultScale = 1.0;
                    if (objType === 'building') { scaleInfo = BUILDING_SCALES[definitionId]; defaultScale = DEFAULT_BUILDING_SCALE; }
                    else if (objType === 'landmark' || objType === 'shrine') { scaleInfo = POI_SCALES[objData.visualDefId || definitionId]; defaultScale = DEFAULT_POI_SCALE; }
                    else if (objType === 'dungeon_entrance') { scaleInfo = DUNGEON_ENTRANCE_SCALES[objData.visualDefId || definitionId]; defaultScale = DEFAULT_DUNGEON_ENTRANCE_SCALE; }
                    if (scaleInfo) { if (typeof scaleInfo.scale === 'number') { finalScale = scaleInfo.scale; } else if (Array.isArray(scaleInfo.scaleRange)) { finalScale = THREE.MathUtils.lerp(scaleInfo.scaleRange[0], scaleInfo.scaleRange[1], Math.random()); } else { finalScale = defaultScale; } } else { finalScale = defaultScale; }
                    if (typeof instanceOverrideScale === 'number' && instanceOverrideScale > 0) { finalScale = instanceOverrideScale; }
                }
                objMesh.scale.setScalar(finalScale);

                objMesh.updateMatrixWorld(true);
                let objectForBBox = objMesh; objMesh.userData.colliderType = 'full_object';
                if (objType === 'scenery_tree') { const trunkNode = objMesh.userData?.trunkRef || objMesh.getObjectByName('Trunk') || objMesh.getObjectByName('Cylinder'); if (trunkNode) { objectForBBox = trunkNode; objMesh.userData.colliderType = 'trunk'; } }
                const initialBox = new THREE.Box3().setFromObject(objectForBBox, true);
                const worldMinY = initialBox.min.y; const verticalOffsetNeeded = objPosition.y - worldMinY;
                objMesh.position.y += verticalOffsetNeeded;
                objMesh.updateMatrixWorld(true);
                let finalObjectForBBoxRecalc = objMesh;
                if (objType === 'scenery_tree' && objMesh.userData.colliderType === 'trunk') { const trunkNodeRecalc = objMesh.userData?.trunkRef || objMesh.getObjectByName('Trunk') || objMesh.getObjectByName('Cylinder'); if (trunkNodeRecalc) finalObjectForBBoxRecalc = trunkNodeRecalc; }
                objMesh.userData.boundingBox = new THREE.Box3().setFromObject(finalObjectForBBoxRecalc, true);

                objMesh.castShadow = true; objMesh.receiveShadow = true;
                objMesh.traverse(c => { if (c.isMesh) { c.castShadow = true; c.receiveShadow = (c === objectForBBox || objMesh.userData.colliderType === 'full_object'); } });

                let isInteractable = false; let interactFn = null; let userDataExtra = {};
                if (objType === 'resource' || (objType === 'scenery_tree' && objMesh.userData.isResource)) { const nodeId = objMesh.userData.id || `${definitionId}_${Math.round(objData.x)}_${Math.round(objData.z)}`; const isDepleted = !!world.worldStateData.depletedNodes?.[nodeId]; isInteractable = !isDepleted; interactFn = () => { if (!gameState.isGhost) harvestResource(objMesh); else logMessage("Los fantasmas no recolectan.", "info"); }; userDataExtra = { resourceDefId: definitionId||objMesh.userData.resourceDefId, id: nodeId, depleted: isDepleted, type: 'resource', resourceType: objMesh.userData.resourceType || objData.resourceType }; if (isDepleted) { objMesh.scale.multiplyScalar(0.4); const nodeDef = resourceDefinitions[userDataExtra.resourceDefId]; const respawnDelay = nodeDef?.respawnTime || RESOURCE_RESPAWN_TIME; const depletionTimestamp = world.worldStateData.depletedNodes[nodeId]; scheduleNodeRespawn(objMesh, depletionTimestamp, respawnDelay); } }
                else if (objType === 'dungeon_entrance') { isInteractable = true; interactFn = () => { if (!gameState.isGhost) enterDungeon(objData.targetLevel); else logMessage("Los fantasmas no entran a mazmorras.", "info"); }; userDataExtra = { targetLevel: objData.targetLevel, type: 'dungeon_entrance' }; }
                else if (objType === 'shrine') { isInteractable = true; interactFn = () => { if (!gameState.isGhost) activateShrine(objMesh, objData.effect); else logMessage("Los fantasmas no necesitan altares.", "info"); }; userDataExtra = { effect: objData.effect, type: 'shrine' }; }
                else if (objType === 'chest') { const chestId = objData.id || `chest_${Math.round(objData.x)}_${Math.round(objData.z)}`; const isOpen = world.worldStateData.openedChests.has(chestId); isInteractable = !isOpen; interactFn = () => { if (!gameState.isGhost) openChest(objMesh); else logMessage("Los fantasmas no abren cofres.", "info"); }; userDataExtra = { type: 'chest', id: chestId, isOpen: isOpen, loot: isOpen ? [] : generateChestLoot(objData.level || 1) }; if (isOpen) { const lid = objMesh.getObjectByName('lidPivot'); if(lid) lid.rotation.x = -Math.PI / 1.6;} }
                else if (objType === 'crafting_station') { isInteractable = true; interactFn = () => { if (!gameState.isGhost) interactWithCraftingStation(objMesh); else logMessage("Los fantasmas no fabrican.", "info"); }; userDataExtra = { type: 'crafting_station', stationType: definitionId }; }

                objMesh.userData = { ...(objData || {}), ...(objMesh.userData || {}), objectRef: objMesh, isEquipmentVisual: false, chunkKey: chunkKey, cameraCollidable: isCameraCollidable, interactable: isInteractable, interact: interactFn, ...userDataExtra };

                if (objMesh.parent !== this.sceneRef) { this.sceneRef.add(objMesh); }
                if (!chunkContainer.objects.includes(objMesh)) { chunkContainer.objects.push(objMesh); }
                if (!world.objects.includes(objMesh)) { world.objects.push(objMesh); }
                if (objMesh.userData.interactable && !world.interactables.includes(objMesh)) { world.interactables.push(objMesh); }

            } else { if (objType !== 'enemy_spawn_point' && objType !== 'npc_spawn_marker') console.warn(`_instanceSingleObject: objMesh inválido o no creado para ${definitionId} (${objType}) en chunk ${chunkKey}`); }

        } catch (e) { console.error(`Error fatal instanciando ${definitionId} (${objType}) en ${chunkKey}:`, e); if (objMesh?.parent) this.sceneRef.remove(objMesh); }
    },
        // --- Acceso a Datos (getTerrainHeightAt, getBiomeIdAt) ---
        /**
         * Obtiene la altura final del terreno en una posición dada, usando datos de chunks activos o caché.
         * (v2 - Usa _getFinalTerrainHeightAndBiome como fallback)
         * @param {number} worldX Coordenada X mundial.
         * @param {number} worldZ Coordenada Z mundial.
         * @returns {number} La altura Y del terreno.
         */
        getTerrainHeightAt(worldX, worldZ) {
            if (!this.worldDataSource) return WATER_LEVEL; // Valor seguro si no hay datos
            const worldCs = this.worldDataSource.chunkSize; const worldHalfW = this.worldDataSource.size.width / 2; const worldHalfD = this.worldDataSource.size.depth / 2;
            const chunkX = Math.floor((worldX + worldHalfW) / worldCs); const chunkZ = Math.floor((worldZ + worldHalfD) / worldCs);
            const key = `${chunkX}_${chunkZ}`;
            let chunkDataContainer = this.activeChunks.get(key); let chunkData = chunkDataContainer?.data || this.chunkDataCache.get(key); // Buscar en activos O caché

            if (chunkData?.heightData) { // Si tenemos datos del chunk
                const res = this.worldDataSource.resolution; const vertsPerEdge = this.worldDataSource.verticesPerChunkEdge;
                const chunkWorldXStart = chunkX * worldCs - worldHalfW; const chunkWorldZStart = chunkZ * worldCs - worldHalfD;
                const mapX = (worldX - chunkWorldXStart) * res; const mapZ = (worldZ - chunkWorldZStart) * res;
                // Índices y pesos para interpolación bilineal
                const x0 = Math.floor(mapX); const z0 = Math.floor(mapZ);
                const x1 = x0 + 1; const z1 = z0 + 1;
                // Clamp índices a los límites del array
                const ix0 = Math.max(0, Math.min(vertsPerEdge, x0)); const iz0 = Math.max(0, Math.min(vertsPerEdge, z0));
                const ix1 = Math.max(0, Math.min(vertsPerEdge, x1)); const iz1 = Math.max(0, Math.min(vertsPerEdge, z1));
                // Índices 1D en el array de alturas
                const idx00 = iz0 * (vertsPerEdge + 1) + ix0; const idx10 = iz0 * (vertsPerEdge + 1) + ix1;
                const idx01 = iz1 * (vertsPerEdge + 1) + ix0; const idx11 = iz1 * (vertsPerEdge + 1) + ix1;

                // Validar índices antes de acceder al array
                if ( idx00 < chunkData.heightData.length && idx10 < chunkData.heightData.length &&
                     idx01 < chunkData.heightData.length && idx11 < chunkData.heightData.length )
                {
                    const h00 = chunkData.heightData[idx00]; const h10 = chunkData.heightData[idx10];
                    const h01 = chunkData.heightData[idx01]; const h11 = chunkData.heightData[idx11];
                    // Pesos de interpolación
                    const tx = mapX - x0; const tz = mapZ - z0;
                    // Interpolar en X
                    const h_x0 = THREE.MathUtils.lerp(h00, h10, tx); const h_x1 = THREE.MathUtils.lerp(h01, h11, tx);
                    // Interpolar en Z
                    return THREE.MathUtils.lerp(h_x0, h_x1, tz);
                } else {
                    // Si los índices son inválidos (debería ser raro), usar fallback
                    console.warn(`Índices de altura fuera de rango para (${worldX}, ${worldZ}) en chunk ${key}. Usando fallback.`);
                    return this._getFinalTerrainHeightAndBiome(worldX, worldZ).height;
                }
            } else {
                // Si no hay datos en caché ni activo, calcular desde cero
                return this._getFinalTerrainHeightAndBiome(worldX, worldZ).height;
            }
        },

        /**
         * Obtiene el ID del bioma final en una posición dada.
         * (v2 - Usa _getFinalTerrainHeightAndBiome como fallback)
         * @param {number} worldX Coordenada X mundial.
         * @param {number} worldZ Coordenada Z mundial.
         * @returns {number} El ID del bioma.
         */
        getBiomeIdAt(worldX, worldZ) {
            if (!this.worldDataSource) return this.worldDataSource?.getBiomeId('grassland') ?? 2;
            const worldCs = this.worldDataSource.chunkSize; const worldHalfW = this.worldDataSource.size.width/2; const worldHalfD = this.worldDataSource.size.depth/2;
            const chunkX = Math.floor((worldX+worldHalfW)/worldCs); const chunkZ = Math.floor((worldZ+worldHalfD)/worldCs);
            const key = `${chunkX}_${chunkZ}`;
            let chunkDataContainer = this.activeChunks.get(key); let chunkData = chunkDataContainer?.data || this.chunkDataCache.get(key);

            if (chunkData?.biomeData) {
                const res=this.worldDataSource.resolution; const vertsPerEdge=this.worldDataSource.verticesPerChunkEdge;
                const chunkWorldXStart = chunkX*worldCs-worldHalfW; const chunkWorldZStart = chunkZ*worldCs-worldHalfD;
                // Usar el vértice más cercano (más simple que interpolar biomas)
                const mapX = Math.round((worldX-chunkWorldXStart)*res); const mapZ = Math.round((worldZ-chunkWorldZStart)*res);
                const ix=Math.max(0,Math.min(vertsPerEdge,mapX)); const iz=Math.max(0,Math.min(vertsPerEdge,mapZ));
                const index=iz*(vertsPerEdge+1)+ix;
                // Validar índice
                return chunkData.biomeData[index] ?? (this.worldDataSource?.getBiomeId('grassland') ?? 2); // Fallback si índice inválido
            } else {
                // Calcular desde cero si no hay datos
                return this._getFinalTerrainHeightAndBiome(worldX, worldZ).biomeId;
            }
        },

        // --- Utilidades ---
        /** Placeholder para futura lógica de Nivel de Detalle (LOD). */
        updateLOD(playerPosition) { /* No implementado */ },
        /** Verifica si la carga inicial de chunks ha terminado completamente. */
        isInitialLoadDone() { return this.isInitialLoadingComplete && this.loadingQueue.size === 0 && !this.currentLoadingChunkKey; }
    }; // --- FIN DEL OBJETO ChunkManager ---


    // === EnemySpawner (COMPLETO - Sin cambios desde v2.5 Fix) ===
const EnemySpawner = {
    respawnTimers: {}, // { spawnPointId: timeoutId }

    /**
     * Intenta spawnear un enemigo basado en los datos de un marcador de spawn.
     * AHORA es async y usa await para createAndAddEnemy.
     * Lee las coordenadas x, y, z directamente desde spawnPointData.
     * (v3 - Async Await + Lee x,y,z directos)
     * @param {object} spawnPointData - Los datos del punto de spawn precalculado.
     */
    async trySpawnEnemyFromMarker(spawnPointData) { // <-- Añadido async
        // --- Validaciones Iniciales ---
        if (!spawnPointData || spawnPointData.type !== 'enemy_spawn_point' || !spawnPointData.id ||
            spawnPointData.x === undefined || spawnPointData.y === undefined || spawnPointData.z === undefined) {
            console.error("[EnemySpawner v3] trySpawnEnemyFromMarker: Datos de spawn point inválidos o faltan coordenadas.", spawnPointData);
            return;
        }

        const spawnId = spawnPointData.id;
        const now = Date.now();

        // --- Comprobar Estado Actual ---
        if (spawnPointData.isSpawned || this.respawnTimers[spawnId]) {
            return; // Ya spawneado o esperando respawn
        }

        // --- Comprobar Tiempo de Respawn ---
        const timeSinceDeath = now - (spawnPointData.lastDeathTime || 0);
        const requiredRespawnTime = spawnPointData.respawnTime || ENEMY_RESPAWN_TIME;

        if (spawnPointData.lastDeathTime !== 0 && timeSinceDeath < requiredRespawnTime) {
            const remainingTime = requiredRespawnTime - timeSinceDeath;
            this.respawnTimers[spawnId] = setTimeout(() => {
                delete this.respawnTimers[spawnId];
                this.trySpawnEnemyFromMarker(spawnPointData); // Llamar de nuevo
            }, remainingTime + 50);
            return;
        }

        // --- Condiciones Cumplidas: Intentar Spawn ---
        console.log(`[EnemySpawner v3] Spawning enemigo desde ${spawnId} (${spawnPointData.enemyType})`);

        // Crear Vector3 desde x, y, z directos
        const position = new THREE.Vector3(spawnPointData.x, spawnPointData.y, spawnPointData.z);
        const rotationY = Math.random() * Math.PI * 2;

        // *** LLAMADA ASÍNCRONA AHORA con await ***
        // Espera a que createAndAddEnemy termine y devuelva el objeto enemigo
        const enemyObject = await createAndAddEnemy(spawnPointData.enemyType, position, rotationY, spawnPointData);
        // *** FIN LLAMADA ASÍNCRONA ***

        // --- Actualizar Estado del Spawn Point ---
        if (enemyObject && enemyObject.userData) { // Verificar que el objeto y userData existan
            const enemyData = enemyObject.userData; // Ahora enemyData está definido
            spawnPointData.isSpawned = true;
            spawnPointData.activeEnemyUUID = enemyObject.uuid;
            console.log(`  -> Enemigo ${enemyData.name} spawneado con UUID ${enemyObject.uuid}`); // Ahora funciona
        } else {
            console.error(`  -> Fallo al crear enemigo (createAndAddEnemy devolvió null/inválido) para spawn point ${spawnId}`);
            spawnPointData.lastDeathTime = now;
            spawnPointData.isSpawned = false;
            spawnPointData.activeEnemyUUID = null;
            // Opcional: Iniciar timer de reintento explícito
            // this.startRespawnTimer(spawnId, 5000); // Reintentar en 5s
        }
    }, // Fin trySpawnEnemyFromMarker (async)

    // --- Resto de funciones de EnemySpawner (startRespawnTimer, etc. sin cambios necesarios aquí) ---
    startRespawnTimer(spawnPointId, respawnTime) {
         if (!spawnPointId || this.respawnTimers[spawnPointId]) return;
         const spawnPointData = this.findSpawnPointData(spawnPointId);
         if (!spawnPointData) { console.error(`No se encontraron datos para spawnPointId ${spawnPointId}`); return; }
         spawnPointData.lastDeathTime = Date.now(); spawnPointData.isSpawned = false; spawnPointData.activeEnemyUUID = null;
         console.log(`[EnemySpawner] Iniciando timer respawn para ${spawnPointId} (${(respawnTime/1000).toFixed(1)}s)`);
         this.respawnTimers[spawnPointId] = setTimeout(() => { console.log(`[EnemySpawner] Timer respawn finalizado para ${spawnPointId}. Intentando respawn...`); delete this.respawnTimers[spawnPointId]; this.trySpawnEnemyFromMarker(spawnPointData); }, respawnTime + 50);
    },
    handleEnemyDeath(enemyObject) {
        if (!enemyObject?.userData?.spawnPointId) return;
        const spawnId = enemyObject.userData.spawnPointId; const respawnTime = enemyObject.userData.respawnTime || ENEMY_RESPAWN_TIME; this.startRespawnTimer(spawnId, respawnTime);
    },
    despawnEnemiesFromChunk(chunkKey) {
        let despawnedCount = 0; const [unloadCX, unloadCZ] = chunkKey.split('_').map(Number); const worldCs = worldData.chunkSize; const worldHalfW = worldData.size.width / 2; const worldHalfD = worldData.size.depth / 2; const chunkMinX = unloadCX * worldCs - worldHalfW; const chunkMaxX = chunkMinX + worldCs; const chunkMinZ = unloadCZ * worldCs - worldHalfD; const chunkMaxZ = chunkMinZ + worldCs;
        for (let i = world.enemies.length - 1; i >= 0; i--) {
            const enemy = world.enemies[i]; if (!enemy?.userData || !enemy.position) continue;
            const isInsideUnloadingChunk = enemy.position.x >= chunkMinX && enemy.position.x < chunkMaxX && enemy.position.z >= chunkMinZ && enemy.position.z < chunkMaxZ;
            const isOriginChunk = enemy.userData.originChunkKey === chunkKey;
            if (isOriginChunk || isInsideUnloadingChunk) {
                if (enemy.parent) scene.remove(enemy);
                enemy.traverse(child => { if (child.isMesh) { child.geometry?.dispose(); if (child.material) { const mats = Array.isArray(child.material)?child.material:[child.material]; mats.forEach(m=>{m.map?.dispose(); /*...*/ m.dispose();}); } } });
                if(isOriginChunk){ const spawnPointData = this.findSpawnPointData(enemy.userData.spawnPointId); if (spawnPointData) { spawnPointData.isSpawned = false; spawnPointData.activeEnemyUUID = null; spawnPointData.lastDeathTime = 0; if (this.respawnTimers[spawnPointData.id]) { clearTimeout(this.respawnTimers[spawnPointData.id]); delete this.respawnTimers[spawnPointData.id]; } } }
                world.enemies.splice(i, 1); despawnedCount++;
            }
        }
        if(despawnedCount > 0) console.log(`   ${despawnedCount} enemigos despawneados del chunk ${chunkKey} / área.`);
    },
    findSpawnPointData(spawnPointId) {
        if (!spawnPointId || !worldData?.chunkEnemySpawnPoints) return null;
        for (const spawnPointArray of worldData.chunkEnemySpawnPoints.values()) { if (!Array.isArray(spawnPointArray)) continue; const found = spawnPointArray.find(sp => sp?.id === spawnPointId); if (found) return found; } return null;
    },
}; // --- FIN EnemySpawner ---


    const AudioManager = {
        audioContext: null, soundBuffers: {}, sounds: {
            swing: 'sounds/swing.wav', swing_heavy: 'sounds/swing_heavy.wav',
            hit_flesh: 'sounds/hit_flesh.wav', hit_flesh_heavy: 'sounds/hit_flesh_heavy.wav',
            hit_metal: 'sounds/hit_metal.wav', hit_stone: 'sounds/hit_stone.wav',
            enemy_die: 'sounds/enemy_die.wav', player_hit: 'sounds/player_hit.wav',
            player_death: 'sounds/player_death.wav', level_up: 'sounds/level_up.wav',
            quest_accept: 'sounds/quest_accept.wav', quest_objective: 'sounds/quest_objective.wav',
            quest_item: 'sounds/quest_item.wav', quest_complete: 'sounds/quest_complete.wav',
            equip: 'sounds/equip.wav', unequip: 'sounds/unequip.wav', use_potion: 'sounds/use_potion.wav',
            drop_item: 'sounds/drop_item.wav', pick_up: 'sounds/pick_up.wav', spell_cast: 'sounds/spell_cast.wav',
            spell_impact: 'sounds/spell_impact.wav', spell_buff: 'sounds/spell_buff.wav', jump: 'sounds/jump.wav',
            land: 'sounds/land.wav', footstep_grass: 'sounds/footstep_grass.wav', footstep_stone: 'sounds/footstep_stone.wav',
            footstep_sand: 'sounds/footstep_sand.wav', chest_open: 'sounds/chest_open.wav',
            harvest_stone: 'sounds/harvest_stone.wav', // Para minar
            harvest_plant: 'sounds/harvest_plant.wav', // Para hierbas
            harvest_wood: 'sounds/harvest_wood.wav', // Para talar
            harvest_crystal: 'sounds/harvest_crystal.wav', // Para cristales
            craft: 'sounds/craft.wav',
            buy_item: 'sounds/buy_item.wav', sell_item: 'sounds/sell_item.wav', rain_loop: 'sounds/rain_loop.wav',
            snow_loop: 'sounds/snow_loop.wav', music_day: 'music/day.mp3', music_night: 'music/night.mp3',
            music_combat: 'music/combat.mp3', ui_confirm: 'sounds/ui_confirm.wav', ui_error: 'sounds/ui_error.wav',
            ui_open: 'sounds/ui_open.wav', ui_close: 'sounds/ui_close.wav', block: 'sounds/block.wav',
            parry_success: 'sounds/parry_success.wav', // Sonido de parry
            teleport: 'sounds/teleport.wav', bow_shoot: 'sounds/bow.wav', crossbow_shoot: 'sounds/crossbow.wav',
            arrow_hit: 'sounds/arrow_hit.wav', lockpick_attempt: 'sounds/lockpick_attempt.wav',
            lockpick_success: 'sounds/lockpick_success.wav', lockpick_fail: 'sounds/lockpick_fail.wav',
            lever_pull: 'sounds/lever.wav', enemy_flee: 'sounds/enemy_flee.wav', respawn: 'sounds/respawn.wav',
        }, gainNodes: { master: null, sfx: null, music: null, weather: null },
        currentMusic: null, currentWeatherSound: null, footstepSound: null,
        lastFootstepTime: 0, footstepInterval: 450, musicState: 'none',
        masterVolume: 0.6, sfxVolume: 0.7, musicVolume: 0.3, weatherVolume: 0.4,

        init() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (!this.audioContext) throw new Error("AudioContext no soportado");
                this.gainNodes.master = this.audioContext.createGain();
                this.gainNodes.sfx = this.audioContext.createGain();
                this.gainNodes.music = this.audioContext.createGain();
                this.gainNodes.weather = this.audioContext.createGain();
                this.gainNodes.sfx.connect(this.gainNodes.master);
                this.gainNodes.music.connect(this.gainNodes.master);
                this.gainNodes.weather.connect(this.gainNodes.master);
                this.gainNodes.master.connect(this.audioContext.destination);
                // Cargar volúmenes de localStorage si existen
                this.masterVolume = parseFloat(localStorage.getItem('volume_master') ?? '0.6');
                this.sfxVolume = parseFloat(localStorage.getItem('volume_sfx') ?? '0.7');
                this.musicVolume = parseFloat(localStorage.getItem('volume_music') ?? '0.3');
                this.weatherVolume = parseFloat(localStorage.getItem('volume_weather') ?? '0.4');
                this.setVolume('master', this.masterVolume);
                this.setVolume('sfx', this.sfxVolume);
                this.setVolume('music', this.musicVolume);
                this.setVolume('weather', this.weatherVolume);
                console.log("AudioContext inicializado y volúmenes cargados.");
                this.preloadSounds();
            } catch (e) {
                console.error("Falló la inicialización de Web Audio API.", e);
                this.audioContext = null;
            }
            const resumeAudio = () => {
                if (this.audioContext?.state === 'suspended') {
                    this.audioContext.resume().catch(e => console.warn("Falló la reanudación de audio:", e));
                }
                document.removeEventListener('click', resumeAudio);
                document.removeEventListener('keydown', resumeAudio);
            };
            document.addEventListener('click', resumeAudio, { once: true });
            document.addEventListener('keydown', resumeAudio, { once: true });
        },
        preloadSounds() {
            if (!this.audioContext) return;
            console.log("Precargando sonidos...");
            Object.entries(this.sounds).forEach(([id, url]) => {
                this.loadSound(id, url);
            });
        },
        async loadSound(id, url) {
            if (!this.audioContext || this.soundBuffers[id]) return;
            this.soundBuffers[id] = 'loading';
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`¡Error HTTP! estado: ${response.status} para ${url}`);
                const arrayBuffer = await response.arrayBuffer();
                this.soundBuffers[id] = await this.audioContext.decodeAudioData(arrayBuffer);
                // console.log(`Sonido ${id} cargado.`); // Reduce spam
            } catch (error) {
                console.warn(`Error cargando sonido ${id} (${url}):`, error.message); // Más conciso
                this.soundBuffers[id] = 'error';
            }
        },
        playSound(id, volume = 1.0, loop = false, category = 'sfx', playbackRate = 1.0) {
            if (!this.audioContext || this.audioContext.state !== 'running') return null;
            const buffer = this.soundBuffers[id];
            if (!buffer || buffer === 'loading' || buffer === 'error') {
                // console.warn(`Intento de reproducir sonido no cargado o con error: ${id}`);
                return null;
            }
            try {
                const source = this.audioContext.createBufferSource();
                source.buffer = buffer;
                const gainNode = this.audioContext.createGain();
                const categoryGainNode = this.gainNodes[category];
                if (!categoryGainNode) { gainNode.connect(this.gainNodes.master); }
                else { gainNode.connect(categoryGainNode); }
                gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                source.connect(gainNode);
                source.loop = loop;
                source.playbackRate.setValueAtTime(playbackRate, this.audioContext.currentTime);
                source.start(0);
                // console.log(`Playing sound: ${id}`); // DEBUG
                return source;
            } catch (e) {
                console.warn(`Error reproduciendo sonido ${id}: ${e.message}`);
                return null;
            }
        },
        stopSound(sourceNode) {
            if (sourceNode?.stop) {
                try { sourceNode.stop(0); sourceNode.disconnect(); } catch(e) {}
            }
        },
        setVolume(category, volume) {
            const targetVolume = Math.max(0, Math.min(1, volume));
            this[`${category}Volume`] = targetVolume;
            if (this.audioContext && this.gainNodes[category]) {
                this.gainNodes[category].gain.linearRampToValueAtTime(
                    targetVolume, this.audioContext.currentTime + 0.1
                );
                // Guardar en localStorage
                localStorage.setItem(`volume_${category}`, targetVolume.toString());
            }
        },

playMusic(trackId) {
            if (!this.audioContext || this.musicState === trackId) return;
            this.stopMusic();
            this.currentMusic = this.playSound(trackId, 1.0, true, 'music');
            this.musicState = this.currentMusic ? trackId : 'none';
            console.log(`Music changed to: ${this.musicState}`); // DEBUG
        },
        stopMusic() {
            if (this.currentMusic) {
                this.stopSound(this.currentMusic);
                this.currentMusic = null;
                this.musicState = 'none';
                 console.log("Music stopped."); // DEBUG
            }
        },
        playWeatherSound(weatherType) {
            if (!this.audioContext) return;
            this.stopWeatherSound();
            let soundId = null;
            if (weatherType === 'rain') soundId = 'rain_loop';
            else if (weatherType === 'snow') soundId = 'snow_loop';
            if (soundId) {
                this.currentWeatherSound = this.playSound(soundId, 0.6, true, 'weather');
                console.log(`Weather sound started: ${weatherType}`); // DEBUG
            }
        },
        stopWeatherSound() {
            if (this.currentWeatherSound){
                this.stopSound(this.currentWeatherSound);
                this.currentWeatherSound = null;
                console.log("Weather sound stopped."); // DEBUG
            }
        },
        playFootstep() {
            if (!this.audioContext || !playerState.onGround || !playerState.isMoving || playerState.isJumping || gameState.isGhost) return;
            const now = Date.now();
            // Ajustar intervalo de pasos según sprint y si está en el aire (evitar sonido justo al aterrizar)
            const intervalMultiplier = playerState.isSprinting ? 0.6 : 1.0;
            const baseInterval = playerState.onGround ? this.footstepInterval : this.footstepInterval * 1.5; // Más lento si está 'cayendo'
            const interval = baseInterval * intervalMultiplier;

            if (now - this.lastFootstepTime > interval) {
                const biome = getBiome(playerState.position.x, playerState.position.z);
                let groundType = 'grass';
                if (['mountains', 'hills', 'city', 'ruin', 'road'].includes(biome)) groundType = 'stone';
                else if (['desert', 'beach'].includes(biome)) groundType = 'sand';
                // Añadir más tipos si se definen (madera, agua poco profunda?)

                const soundId = `footstep_${groundType}`;
                // Verificar si el sonido existe antes de intentar reproducirlo
                if (this.sounds[soundId]) {
                    this.playSound(soundId, 0.35, false, 'sfx', 0.9 + Math.random() * 0.2);
                } else {
                     // Fallback a sonido genérico si el específico no existe
                     this.playSound('footstep_grass', 0.30, false, 'sfx', 0.9 + Math.random() * 0.2);
                }
                this.lastFootstepTime = now;
            }
        },
        updateMusic() {
            if (!this.audioContext || !gameState.isPlaying) {
                 if(this.musicState !== 'none') this.stopMusic(); // Detener si ya no se juega
                 return;
            }

            // Determinar música objetivo
            let targetMusic = 'none';
            const nearAggroEnemy = world.enemies.some(e =>
                e && e.userData && !e.userData.isDead && e.userData.isAggro &&
                e.position.distanceToSquared(playerState.position) < 30*30 // Rango de música de combate
            );
            const isNight = gameState.timeOfDay < 0.2 || gameState.timeOfDay > 0.8;

            if (gameState.isGhost) targetMusic = 'music_night'; // Música tranquila fantasma
            else if (nearAggroEnemy) targetMusic = 'music_combat';
            else targetMusic = isNight ? 'music_night' : 'music_day';

            // Cambiar solo si es necesario
            if (this.musicState !== targetMusic && this.sounds[targetMusic]) {
                this.playMusic(targetMusic);
            } else if (this.musicState !== 'none' && !this.sounds[targetMusic]) {
                // Si la música objetivo no existe, detener la actual
                this.stopMusic();
            }
        }
    }; // Fin AudioManager

function init() {
    console.log("DOM Cargado. Iniciando secuencia init() (vOptimized)...");
    assignDOMElements();
    initMinimap();
    showLoadingScreen();
    AudioManager.init();

    try {
         worldSeed = parseInt(localStorage.getItem('eldravar_seed') || Date.now().toString(), 10);
         localStorage.setItem('eldravar_seed', worldSeed.toString());
         console.log("World Seed:", worldSeed);
         if (typeof SimplexNoise !== 'function') throw new Error("SimplexNoise no está definido.");
         simplex = new SimplexNoise(worldSeed); simplexHeight = new SimplexNoise(worldSeed + 1);
         simplexBiomes = new SimplexNoise(worldSeed + 2); simplexObjects = new SimplexNoise(worldSeed + 3);
         simplexRivers = new SimplexNoise(worldSeed + 6); simplexDetails = new SimplexNoise(worldSeed + 7);
         biomeNoise = simplexBiomes; tempNoise = new SimplexNoise(worldSeed + 4); moistureNoise = new SimplexNoise(worldSeed + 5);
    } catch(e) { console.error("Error inicializando Simplex Noise:", e); }

    try {
        if (typeof THREE.GLTFLoader !== 'function') throw new Error("THREE.GLTFLoader no está definido.");
        gltfLoader = new THREE.GLTFLoader();
        console.log("GLTFLoader inicializado.");
    } catch (e) { console.error("¡Error inicializando GLTFLoader!", e); updateLoadingProgress(0,"Error: Falta GLTFLoader."); return; }

    statsMonitor = null;
    try {
        if (typeof Stats === 'function') {
            statsMonitor = new Stats();
            if (statsMonitor && statsMonitor.dom instanceof HTMLElement) {
                const statsElement = statsMonitor.dom;
                statsElement.style.position = 'fixed'; statsElement.style.left = '10px'; statsElement.style.bottom = '10px';
                statsElement.style.top = 'auto'; statsElement.style.right = 'auto'; statsElement.style.zIndex = '10000';
                statsElement.style.opacity = '0.85'; statsElement.style.display = 'none';
                if (!statsElement.parentNode) document.body.appendChild(statsElement);
            } else { statsMonitor = null; }
        } else { statsMonitor = null; }
    } catch(e) { console.error("Error inicializando Stats.js:", e); statsMonitor = null; }

    loadPerformanceOptions();

    // Define los pasos de inicialización, incluyendo la precarga
    const initializationSteps = [
        { task: initGameDataDefinitions, message: "Descifrando Pergaminos Antiguos..." },
        { task: setupThreeJS, message: "Forjando los Planos Elementales..." },
        { task: preloadPreviewAssets, message: "Preparando Avatares..." }, // Carga modelos de preview
        { task: preloadCoreAssets, message: "Forjando Estructuras..." }, // NUEVO: Carga modelos edificios/texturas
        { task: () => ChunkManager.init(scene, worldData), message: "Delimitando las Fronteras..." },
        { task: setupInitialPlayerState, message: "Invocando al Héroe Elegido..." },
        { task: setupUI, message: "Grabando Runas en la Interfaz..." },
        { task: setupEventListeners, message: "Afinando los Sentidos del Mundo..." },
        { task: preloadInitialChunks, message: "Preparando el Terreno Inicial..." }, // Carga chunks iniciales
        { task: finalizeInitialization, message: "¡Eldravar Despierta!" }
    ];

    // Ajustar porcentajes para la barra de carga
    const totalSteps = initializationSteps.length;
    let progressIncrements = [];
    // Asignar porcentajes (puedes ajustar estos valores)
    progressIncrements = [ 5,  5, 10, 25, 5,  5,  5,  5, 25, 10]; // Suma 100

    // Correr la secuencia
    runInitializationSequence(initializationSteps, progressIncrements, 0);
}

async function runInitializationSequence(steps, increments, initialProgress) {
    console.log("--- Iniciando runInitializationSequence ---");
    let currentProgress = initialProgress;

    for (let i = 0; i < steps.length; i++) {
        const step = steps[i];
        const increment = increments[i] || (100 / steps.length); // Fallback si falta incremento
        const message = step.message || `Paso ${i + 1}`;
        console.log(`Ejecutando paso ${i+1}/${steps.length}: ${message} (Progreso: ${currentProgress.toFixed(0)}% + ${increment.toFixed(0)}%)`);

        try {
            // --- Lógica Especial para Pasos de Precarga con Callback ---
            if (step.task === preloadCoreAssets || step.task === preloadInitialChunks) {
                console.log(`   -> Llamando a tarea asíncrona con callback: ${step.task.name}`);
                await step.task(updateLoadingProgress, currentProgress, increment);
                 console.log(`   -> Tarea asíncrona ${step.task.name} completada.`);
            } else {
                // --- Tareas Síncronas o Asíncronas sin Callback ---
                updateLoadingProgress(currentProgress, message); // Actualizar antes de empezar
                const result = step.task();
                if (result instanceof Promise) {
                     console.log(`   -> Esperando promesa de ${step.task.name}...`);
                    await result; // Esperar si la tarea es asíncrona
                     console.log(`   -> Promesa de ${step.task.name} resuelta.`);
                } else {
                    console.log(`   -> Tarea síncrona ${step.task.name} ejecutada.`);
                }
                // Actualizar progreso DESPUÉS de tareas no-callback
                updateLoadingProgress(currentProgress + increment * 0.9, message + " - Listo."); // Mostrar progreso parcial
            }
            currentProgress += increment; // Actualizar progreso total
        } catch (error) {
            console.error(`¡Error CRÍTICO durante el paso '${message}'!`, error);
            updateLoadingProgress(currentProgress, `Error en: ${message}`);
            const loadingScreen = domCache['loading-screen'];
            if (loadingScreen instanceof HTMLElement) {
                 const errDiv = document.createElement('div');
                 errDiv.style.color = 'red'; errDiv.style.marginTop = '20px';
                 errDiv.textContent = `Error Crítico (${message}). Revisa consola (F12).`;
                 loadingScreen.appendChild(errDiv);
            }
            logMessage(`Error Crítico en '${message}'.`, "error");
            return; // Detener la secuencia
        }
    }

    updateLoadingProgress(100, "¡Inicialización Completa!");
    console.log("--- runInitializationSequence Finalizado ---");
}
    
    /**
 * Precarga los chunks alrededor del punto de spawn inicial de forma asíncrona.
 * Actualiza la UI de carga durante el proceso.
 * Marca ChunkManager.isInitialLoadingComplete = true al finalizar.
 * @param {function(number, string):void} updateLoadingUICallback - Función para actualizar la barra/texto de carga.
 * @param {number} initialProgress - Progreso inicial antes de empezar la carga de chunks.
 * @param {number} totalProgressForThisStep - Cuánto % total representa este paso de carga.
 */
async function preloadInitialChunks(updateLoadingUICallback, initialProgress, totalProgressForThisStep) {
    console.log("--- Iniciando preloadInitialChunks ---");
    if (!ChunkManager.worldDataSource || !RESPAWN_POINT) {
        console.error("preloadInitialChunks: worldData o RESPAWN_POINT no definidos.");
        updateLoadingUICallback(initialProgress + totalProgressForThisStep, "Error: Datos del mundo no encontrados.");
        ChunkManager.isInitialLoadingComplete = true; // Marcar como completo (con error) para no bloquear
        return;
    }

    const worldCs = ChunkManager.worldDataSource.chunkSize;
    const worldHalfW = ChunkManager.worldDataSource.size.width / 2;
    const worldHalfD = ChunkManager.worldDataSource.size.depth / 2;
    const spawnX = RESPAWN_POINT.x;
    const spawnZ = RESPAWN_POINT.z;

    // Calcular chunk central y chunks circundantes
    const centerChunkX = Math.floor((spawnX + worldHalfW) / worldCs);
    const centerChunkZ = Math.floor((spawnZ + worldHalfD) / worldCs);
    const radius = ChunkManager.loadRadius;
    const initialChunksToLoad = new Set();

    for (let dz = -radius; dz <= radius; dz++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const cx = centerChunkX + dx;
            const cz = centerChunkZ + dz;
            // Validar que el chunk esté dentro de los límites del mundo
            if (cx >= 0 && cx < ChunkManager.worldDataSource.numChunksX && cz >= 0 && cz < ChunkManager.worldDataSource.numChunksZ) {
                const key = `${cx}_${cz}`;
                initialChunksToLoad.add(key);
                ChunkManager.loadingQueue.add(key); // Añadir a la cola principal
            }
        }
    }

    ChunkManager.totalInitialChunks = initialChunksToLoad.size;
    ChunkManager.initialChunksLoadedCount = 0;
    ChunkManager.initialChunkKeysBeingLoaded = initialChunksToLoad; // Guardar las claves iniciales
    ChunkManager.isInitialLoadingComplete = false; // Marcar que la carga inicial ha comenzado
    console.log(`preloadInitialChunks: ${initialChunksToLoad.size} chunks iniciales añadidos a la cola.`);

    // --- Bucle de Carga Incremental Asíncrono ---
    const yieldControl = () => new Promise(resolve => setTimeout(resolve, 0)); // Ceder control al navegador

    while (ChunkManager.loadingQueue.size > 0 || ChunkManager.currentLoadingChunkKey) {
        // Procesar un paso de la carga incremental
        ChunkManager.processLoadQueueIncremental();

        // Calcular progreso basado en chunks COMPLETADOS
        const loadedCount = ChunkManager.initialChunksLoadedCount;
        const totalCount = ChunkManager.totalInitialChunks;
        const progressPercent = totalCount > 0 ? (loadedCount / totalCount) : 1;
        const overallProgress = initialProgress + progressPercent * totalProgressForThisStep;

        updateLoadingUICallback(
            overallProgress,
            `Cargando Terreno Inicial... (${loadedCount}/${totalCount}) Chunk: ${ChunkManager.currentLoadingChunkKey || 'Ninguno'}`
        );

        // Esperar un poco antes de la siguiente iteración para no bloquear
        await yieldControl();
    }

    // --- Carga Completada ---
    ChunkManager.isInitialLoadingComplete = true; // Marcar como completado
    ChunkManager.initialChunkKeysBeingLoaded = null; // Limpiar set de seguimiento
    updateLoadingUICallback(initialProgress + totalProgressForThisStep, "Terreno Inicial Cargado.");
    console.log("--- preloadInitialChunks Finalizado ---");
}

/**
 * Runs a sequence of initialization steps, updating a loading bar and text.
 * Includes preloading of preview assets and initial terrain chunks.
 * (vCombinedPreload - Full Code)
 *
 * @param {Array<{task: Function, message: string}>} steps - Array of initialization step objects.
 * @param {number} initialProgress - The starting percentage for the loading bar.
 */
async function runInitializationSteps(steps, initialProgress) {
    console.log("--- Iniciando runInitializationSteps (vCombinedPreload - Full Code) ---");
    let currentProgress = initialProgress;

    // --- 1. Get DOM Elements for Loading UI ---
    const progressBar = domCache['loading-bar'];
    const loadingTextElement = domCache['loading-text'];
    const loadingScreen = domCache['loading-screen'];

    // --- 2. Validate Essential Loading UI Elements ---
    if (!(progressBar instanceof HTMLElement) || !(loadingTextElement instanceof HTMLElement) || !(loadingScreen instanceof HTMLElement)) {
        console.error("Elementos UI de carga esenciales (#loading-screen, #loading-bar, #loading-text) no encontrados. Abortando inicialización.");
        // Optionally display an error message directly on the body if loading screen fails
        document.body.innerHTML = '<p style="color: red; text-align: center; padding-top: 50px;">Error Crítico: No se puede mostrar la pantalla de carga.</p>';
        return;
    }

    // --- 3. Define Helper Function for UI Updates ---
    const updateLoadingUI = (progress, text) => {
        const clampedProgress = Math.max(0, Math.min(100, progress));
        if (progressBar) {
            progressBar.style.width = `${clampedProgress.toFixed(1)}%`;
        }
        if (loadingTextElement) {
            loadingTextElement.textContent = text || "..."; // Default text if none provided
        }
        // Ensure loading screen is visible
        if (loadingScreen.style.display === 'none') {
            loadingScreen.style.display = 'flex';
        }
    };

    // --- 4. Initial UI State ---
    updateLoadingUI(currentProgress, "Iniciando carga...");

    // --- 5. Define and Insert Additional Preload Steps ---
    // a. Preload Preview Assets Step
    const preloadPreviewStep = {
        task: preloadPreviewAssets, // Ensure this async function is defined globally
        message: "Preparando Avatares..."
    };

    // b. Preload Initial Chunks Step (Wrapper to pass parameters)
    const preloadChunksStep = {
        task: async (currentStepProgress, stepTotalPortion) => { // Task now accepts calculated progress values
            await preloadInitialChunks(
                updateLoadingUI, // Pass the UI update callback
                currentStepProgress, // Pass the progress *before* this step starts
                stepTotalPortion // Pass how much % this step represents overall
            );
        },
        message: "Preparando el Terreno Inicial..." // Base message, preloadInitialChunks will override
    };

    // Insert steps at appropriate positions (e.g., before finalization)
    // Find the index of the 'finalizeInitialization' step or assume it's the last one
    let finalizeIndex = steps.findIndex(step => step.task === finalizeInitialization);
    if (finalizeIndex === -1) finalizeIndex = steps.length -1; // Default to before the last step

    // Insert preview preload *before* chunk preload
    steps.splice(finalizeIndex, 0, preloadPreviewStep);
    // Insert chunk preload *after* preview preload (or adjust index as needed)
    steps.splice(finalizeIndex + 1, 0, preloadChunksStep);

    // --- 6. Recalculate Progress Increments ---
    const newTotalSteps = steps.length;
    // Allocate progress percentage per step (excluding chunk preload which handles its own % internally)
    const progressRemaining = 100 - initialProgress;
    // Calculate portion for chunk preload based on estimate (e.g., 40%)
    const chunkPreloadPortionEstimate = 40; // Adjust this % as needed
    // Calculate portion for all OTHER steps
    const nonChunkStepsCount = newTotalSteps - 1; // All steps except chunk preload
    const progressForOtherSteps = progressRemaining - chunkPreloadPortionEstimate;
    const progressIncrementPerOtherStep = nonChunkStepsCount > 0 ? progressForOtherSteps / nonChunkStepsCount : 0;

    console.log(`Initialization Steps Breakdown: Total=${newTotalSteps}, ChunkPreloadPortion=${chunkPreloadPortionEstimate}%, OtherStepIncrement=${progressIncrementPerOtherStep.toFixed(1)}%`);

    // --- 7. Execute Steps Sequentially ---
    for (let i = 0; i < newTotalSteps; i++) {
        const step = steps[i];
        const msg = step.message || `Paso ${i + 1}`;
        let stepProgressPortion = progressIncrementPerOtherStep; // Default increment

        if (step === preloadChunksStep) { // Special handling for chunk preload
            stepProgressPortion = chunkPreloadPortionEstimate; // Use its pre-allocated portion
            console.log(`Executing Chunk Preload Step (Portion: ${stepProgressPortion}%)...`);
            // Update UI message *before* calling the task
            updateLoadingUI(currentProgress, msg);
            try {
                // Pass the *current* progress and the step's allocated portion
                await step.task(currentProgress, stepProgressPortion);
                // After it finishes, update the global progress
                currentProgress += stepProgressPortion;
                updateLoadingUI(currentProgress, msg + " - ¡Listo!"); // Update UI *after* completion
            } catch (error) {
                console.error(`¡Error CRÍTICO durante el paso '${msg}'!`, error);
                updateLoadingUI(currentProgress, `Error en: ${msg}`);
                const errDiv = document.createElement('div');
                errDiv.style.color = 'red'; errDiv.style.marginTop = '20px';
                errDiv.textContent = `Error Crítico (${msg}). Revisa la consola (F12).`;
                loadingScreen.appendChild(errDiv);
                logMessage(`Error Crítico en '${msg}'.`, "error");
                return; // Stop initialization on critical error
            }
        } else { // Handling for all other steps
            console.log(`Executing Step: ${msg} (Increment: ${stepProgressPortion.toFixed(1)}%). Current Progress: ${currentProgress.toFixed(1)}%`);
            updateLoadingUI(currentProgress, msg); // Show 'working on...' message
            try {
                const result = step.task();
                if (result instanceof Promise) {
                    await result; // Wait if the task is async
                }
                // Increment progress AFTER successful completion
                currentProgress += stepProgressPortion;
                updateLoadingUI(currentProgress, msg + " - ¡Listo!"); // Show completed message
            } catch (error) {
                console.error(`¡Error CRÍTICO durante el paso '${msg}'!`, error);
                updateLoadingUI(currentProgress, `Error en: ${msg}`);
                const errDiv = document.createElement('div');
                errDiv.style.color = 'red'; errDiv.style.marginTop = '20px';
                errDiv.textContent = `Error Crítico (${msg}). Revisa la consola (F12).`;
                loadingScreen.appendChild(errDiv);
                logMessage(`Error Crítico en '${msg}'.`, "error");
                return; // Stop initialization on critical error
            }
        }
    }

    // --- 8. Final Update ---
    updateLoadingUI(100, "¡Inicialización Completa!");
    console.log("--- runInitializationSteps Finalizado (vCombinedPreload - Full Code) ---");
}  
    
    function updateLoadingProgress(percentage, text) {
        const bar = domCache['loading-bar']; const loadingText = domCache['loading-text'];
        if (bar instanceof HTMLElement) bar.style.width = `${Math.min(100, Math.max(0,percentage))}%`;
        if (loadingText instanceof HTMLElement) loadingText.textContent = text;
    }

    function showLoadingScreen() {
        const loadingScreen = domCache["loading-screen"]; if (loadingScreen instanceof HTMLElement) loadingScreen.style.display = "flex";
        const startScreen = domCache["start-screen"]; if (startScreen instanceof HTMLElement) startScreen.style.display = "none";
        const charCreation = domCache["character-creation"]; if (charCreation instanceof HTMLElement) charCreation.style.display = "none";
    }
function hideLoadingScreen() {
    const loadingScreen = domCache['loading-screen'];
    if (loadingScreen instanceof HTMLElement) loadingScreen.style.display = 'none';
}

function showGameUI() {
    const sidebar = domCache['sidebar'];
    const uiContainer = domCache['ui-container'];
    // Mostrar elementos principales de la UI del juego
    if (sidebar instanceof HTMLElement) sidebar.style.display = "flex";
    if (uiContainer instanceof HTMLElement) uiContainer.style.display = "block";
    // Mostrar UI móvil si aplica (podría estar en una función separada)
    if (window.innerWidth <= 768) { // O tu breakpoint móvil
         const mobileUI = domCache['mobile-ui-container'];
         if(mobileUI instanceof HTMLElement) mobileUI.style.display = 'block';
         const mobileToggle = domCache['mobile-sidebar-toggle'];
         if(mobileToggle instanceof HTMLElement) mobileToggle.style.display = 'flex';
    }
}

    function assignDOMElements() {
        console.log("Assigning DOM elements...");
        Object.keys(domCache).forEach(key => delete domCache[key]);
        const ids = [
            "loading-screen", "loading-bar", "loading-text", "start-screen", "character-creation", "character-form",
            // Drop Panel V2 elements
            "drop-item-panel", "drop-panel-title", "close-drop-panel-button", "drop-item-icon", "drop-item-name",
            "drop-quantity-input", "drop-max-text", "drop-decrease-btn", "drop-increase-btn", "drop-quantity-max",
            "drop-confirm-specific-btn", "drop-confirm-all-btn", "drop-all-count",
            // Other panels and elements
            "death-overlay", "death-message", "respawn-prompt", "pause-indicator-overlay", "pause-text", "options-panel",
            "large-map-panel", "equipment-modal", "crafting-modal", "quests-modal", "skills-modal", "game-canvas",
            "particle-canvas", "minimap-canvas", "large-map-canvas", "mobile-minimap-canvas", "ui-container",
            "sidebar", "tabs-container", "action-buttons", "action-bar", "sidebar-modal-buttons",
            "resource-bars-container", "mobile-ui-container", "mobile-top-bar", "mobile-stats-bars",
            "mobile-bottom-controls", "joystick-container", "mobile-action-buttons", "tabs-header",
            "message-log-container", "message-log-tabs", "message-log", "status-effects-bar", "target-info",
            "minimap-container", "quest-tracker", "player-info", "player-name", "player-level", "gold-text",
            "xp-bar", "xp-text", "inventory-tab", "inventory-grid", "spells-tab", "spells-list",
            "health-bar", "health-text", "mana-bar", "mana-text", "stamina-bar", "stamina-text",
            "mobile-health-bar", "mobile-mana-bar", "mobile-stamina-bar", "equip-button", "use-button",
            "drop-button", "mobile-attack-btn", "mobile-interact-btn", "mobile-jump-btn", "mobile-sprint-toggle-btn",
            "mobile-sidebar-toggle", "mobile-sidebar-close-btn", "new-game-button", "continue-button",
            "start-game", "character-name", "dialog-panel", "dialog-npc-icon", "dialog-npc-name",
            "dialog-text", "dialog-options", "character-sheet-panel", "close-char-sheet", "char-attributes",
            "attribute-points-info", "char-health", "char-mana", "char-stamina", "char-phys-dmg", "char-magic-dmg",
            "char-defense", "char-magic-resist", "char-hit-chance", "char-crit-chance", "char-move-speed",
            "char-hp-regen", "char-mp-regen", "char-sp-regen", "shop-panel", "shop-title", "shop-player-gold",
            "close-shop", "shop-item-list", "shop-player-sell-list", "shop-buy-button", "shop-sell-button",
            "shop-quantity-selector", "shop-qty-decrease", "shop-quantity-input", "shop-qty-increase",
            "shop-qty-max", "shop-total-price", "shop-buy-qty-text", "shop-sell-qty-text",
            "shop-selected-item-details", "shop-details-placeholder", "shop-details-content",
            "shop-details-name", "shop-details-desc", "shop-details-stats", "shop-details-price", "quest-log",
            "item-tooltip", "spell-tooltip", "skill-tooltip", "recipe-tooltip", "status-tooltip",
            "equipment-tooltip", "shop-tooltip", "target-name", "target-health-bar-container", "target-health-bar",
            "close-options-button", "options-close-confirm", "volume-master", "volume-master-value", "volume-sfx",
            "volume-sfx-value", "volume-music", "volume-music-value", "volume-weather", "volume-weather-value",
            "close-large-map-button", "large-map-canvas-container", "large-map-player-coords",
            "open-equipment-button", "open-crafting-button", "open-quests-button", "open-skills-button",
            "open-map-button-sidebar", "close-equipment-modal", "close-crafting-modal", "close-quests-modal",
            "close-skills-modal", "credits-panel", "close-credits-button", "manual-panel", "close-manual-button",
            "credits-button", "manual-button", "options-button-main", "manual-tabs-header",
            "manual-controls-content", "manual-concepts-content", "manual-creatures-content", "manual-locations-content", "manual-skills-content", "open-character-sheet-button",
            "option-show-fps", "char-sheet-info", "char-sheet-name-level", "char-sheet-class",
            "option-shadow-quality",
            "option-particle-limit",
            "option-weather-effects",
            "option-pixel-ratio",
            "option-pixel-ratio-value",
            "gender-male", "gender-female", "race-selection", "class-selection",
            "character-preview-area", "char-preview-model", "character-attributes-display", "char-creation-attributes-list",
            // Modal content IDs (some might be duplicated by cacheModalContent but this ensures they are looked for)
            "equipment-slots", "recipe-list", "crafting-details", "crafting-materials", "crafting-description", "craft-button",
            "skill-points-info", "skills-list", "option-brightness", "option-brightness-value", "option-lighting-intensity", "option-lighting-intensity-value",

        ];
        let foundCount = 0, missingCount = 0; const missingIds = [];
        ids.forEach(id => { const el = document.getElementById(id); if(el){ domCache[id] = el; foundCount++; } else { domCache[id] = null; missingCount++; missingIds.push(id); } });
        if (missingCount > 0) console.warn(`Assign DOM: ${foundCount} found, ${missingCount} missing: ${missingIds.join(', ')}`);
        domCache.classOptions = document.querySelectorAll(".class-option") ?? [];
        domCache.raceOptions = document.querySelectorAll(".race-option") ?? []; 
        domCache.genderRadios = document.querySelectorAll('input[name="gender"]') ?? []; 
        domCache.tabButtons = domCache['tabs-header']?.querySelectorAll(".tab-button") ?? [];
        domCache.messageLogTabs = domCache['message-log-tabs']?.querySelectorAll(".message-log-tab") ?? [];
        domCache.actionSlots = domCache['action-bar']?.querySelectorAll(".action-slot") ?? [];
        domCache.manualTabButtons = domCache['manual-tabs-header']?.querySelectorAll(".manual-tab-button") ?? [];

        const cacheModalContent = (modalId, contentMap) => { const modal=domCache[modalId]; if(modal instanceof HTMLElement) for(const k in contentMap){const el=modal.querySelector(contentMap[k]);domCache[`modal-${modalId}-${k}`]=el;if(!el)console.warn(`Element "${contentMap[k]}" not found in #${modalId}`);}};
        cacheModalContent('equipment-modal', { equipmentSlotsContainer: '#equipment-slots', equipmentTooltip: '#equipment-tooltip' }); domCache.equipmentSlotMap = {}; const eqS = domCache['modal-equipment-modal-equipmentSlotsContainer']; if(eqS instanceof HTMLElement) eqS.querySelectorAll(".equipment-slot[data-slot]").forEach(el=>{if(el instanceof HTMLElement&&el.dataset.slot)domCache.equipmentSlotMap[el.dataset.slot]=el;if(el.id&&!domCache[el.id])domCache[el.id]=el;});
        cacheModalContent('crafting-modal', { recipeList: '#recipe-list', craftingDetails: '#crafting-details', craftingMaterials: '#crafting-materials', craftingDescription: '#crafting-description', craftButton: '#craft-button', recipeTooltip: '#recipe-tooltip' });
        cacheModalContent('quests-modal', { questLog: '#quest-log' });
        cacheModalContent('skills-modal', { skillPointsInfo: '#skill-points-info', skillsList: '#skills-list', skillTooltip: '#skill-tooltip' });
        setupCanvasContext('particle-canvas', 'particleCtx'); setupCanvasContext('minimap-canvas', 'minimapCtx'); setupCanvasContext('large-map-canvas', 'largeMapCtx'); setupCanvasContext('mobile-minimap-canvas', 'mobileMinimapCtx');
        console.log("Asignación DOM completa (vMenu).");
    }
function setupCanvasContext(canvasId, cacheKey) {
        const canvasElement = domCache[canvasId];
        if (canvasElement instanceof HTMLCanvasElement) {
            try {
                const contextOptions = (canvasId === 'particle-canvas') ? { alpha: true } : { alpha: false };
                const ctx = canvasElement.getContext('2d', contextOptions);
                if (!ctx) {
                    console.error(`getContext('2d') devolvió null para #${canvasId}.`);
                    domCache[cacheKey] = createDummyContext();
                } else {
                    // Marcar si NO es dummy para la función render
                    ctx.isDummyContext = false;
                    domCache[cacheKey] = ctx;
                }
            } catch (e) {
                console.error(`Excepción al obtener contexto para #${canvasId}:`, e);
                domCache[cacheKey] = createDummyContext();
            }
        } else {
            if (!domCache.hasOwnProperty(canvasId) || domCache[canvasId] === null) { /* console.warn(`#${canvasId} NO encontrado.`); */ }
            else { console.warn(`#${canvasId} NO es HTMLCanvasElement.`); }
            domCache[cacheKey] = createDummyContext();
        }
    }

    function initMinimap() {
        const minimapCanvas = domCache["minimap-canvas"];
        if (minimapCanvas instanceof HTMLCanvasElement) {
            minimapCanvas.width = MINIMAP_SIZE_PX; minimapCanvas.height = MINIMAP_SIZE_PX;
        }
        const mobileMinimapCanvas = domCache["mobile-minimap-canvas"];
         if (mobileMinimapCanvas instanceof HTMLCanvasElement) {
              mobileMinimapCanvas.width = 65; mobileMinimapCanvas.height = 65; // Tamaño móvil
         }
    }

    function createDummyContext() {
        const dummy = {
             canvas: { width: 0, height: 0, style: {} }, isDummyContext: true, // Flag para identificarlo
             fillStyle: '#000', strokeStyle: '#000', lineWidth: 1, globalAlpha: 1,
             clearRect: () => {}, fillRect: () => {}, strokeRect: () => {}, beginPath: () => {},
             closePath: () => {}, moveTo: () => {}, lineTo: () => {}, arc: () => {}, fill: () => {},
             stroke: () => {}, save: () => {}, restore: () => {}, translate: () => {}, rotate: () => {},
             fillText: () => {}, drawImage: () => {}, measureText: (t)=>( {width: (t||'').length * 5} ),
             createImageData: (w,h)=>({data: new Uint8ClampedArray(w*h*4), width:w, height:h}),
             putImageData: ()=>{}, getContextAttributes: ()=>({alpha:false}), // Métodos básicos no-op
             // Añadir otros métodos comunes si son llamados por el código y causan errores
        };
        dummy.canvas = { width: 0, height: 0, getContext: () => dummy, style: {} };
        return dummy;
    }

     /**
     * Configura la escena básica de Three.js, la cámara, el renderizador,
     * y los OrbitControls (configurados principalmente para zoom y damping).
     */
    function setupThreeJS() {
        console.log("--- Iniciando setupThreeJS (vEnhancedLighting) ---");

        // --- 1. Scene ---
        scene = new THREE.Scene();
        // Un color de fondo inicial, la luz/niebla lo ajustarán
        scene.background = new THREE.Color(0x1a2b3c);
        // Niebla inicial (puede ser ajustada por clima/hora del día)
        scene.fog = new THREE.Fog(0x1a2b3c, 80, 250);

        // --- 2. Camera ---
        camera = new THREE.PerspectiveCamera(
            60, // Campo de visión estándar
            window.innerWidth / window.innerHeight,
            0.1, // Near plane
            1000 // Far plane (adecuado para el tamaño del mundo)
        );
        // La posición inicial se define después de crear al jugador

        // --- 3. Renderer ---
        const gameCanvas = domCache["game-canvas"];
        if (!(gameCanvas instanceof HTMLCanvasElement)) {
            throw new Error("Canvas del juego (#game-canvas) no encontrado o no es un canvas.");
        }

        renderer = new THREE.WebGLRenderer({
            canvas: gameCanvas,
            antialias: true, // Suavizado de bordes
            alpha: false,    // El fondo no es transparente
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Limitar pixel ratio para rendimiento
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, renderPixelRatio)); // Usa la variable global de opciones
        console.log(`Renderer PixelRatio set to: ${renderer.getPixelRatio()}`);

        // *** IMPORTANT SETTINGS FOR LIGHTING/COLOR ***
        renderer.outputEncoding = THREE.sRGBEncoding; // ESSENTIAL for correct colors on display
        renderer.toneMapping = THREE.ACESFilmicToneMapping; // Good filmic default
        renderer.toneMappingExposure = gameBrightness; // Usa la variable global
        console.log(`Renderer Initial Brightness (Exposure) set to: ${renderer.toneMappingExposure}`);

        // *******************************************

        // --- 4. Shadows ---
        // Enabled/Disabled and map size adjusted based on 'shadowQuality' setting
        renderer.shadowMap.enabled = shadowQuality !== 'off';
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Good balance quality/performance
        // Map size is set dynamically in setupLighting based on shadowQuality

        // --- 5. Helpers ---
        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // --- 6. OrbitControls (Focus on Zoom/Damping) ---
        try {
            if (typeof THREE.OrbitControls === 'undefined') {
                 console.error("THREE.OrbitControls no está definido.");
                 orbitControls = null;
            } else {
                orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
                orbitControls.enableZoom = true;
                orbitControls.enableRotate = false; // Disable mouse rotation
                orbitControls.enablePan = false; // Disable mouse panning
                orbitControls.enableDamping = true;
                orbitControls.dampingFactor = 0.08;
                orbitControls.minDistance = 2.0;
                orbitControls.maxDistance = 20.0;
                orbitControls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null };
                orbitControls.touches = { ONE: THREE.TOUCH.DOLLY, TWO: null };
                // Initial target will be set after player creation
                orbitControls.target.set(0, PLAYER_HALF_HEIGHT, 0);
                console.log("OrbitControls inicializado para zoom/damping.");
            }
        } catch(e) {
            console.error("Error inicializando OrbitControls:", e);
            orbitControls = null;
        }

        console.log("Three.js inicializado correctamente (vEnhancedLighting).");
    } // --- Fin setupThreeJS ---

    
    async function loadGLBModel(path) {
        return new Promise((resolve, reject) => {
            if (!gltfLoader) { return reject(new Error("GLTFLoader no inicializado.")); }
            if (!path || typeof path !== 'string') { return reject(new Error(`Ruta de modelo inválida: ${path}`)); }
            gltfLoader.load( path,
                (gltf) => resolve(gltf), // Resolvemos con el objeto gltf completo
                 undefined, // onProgress (opcional)
                 (error) => { // onError
                     console.error(`Error cargando GLTF desde ${path}:`, error);
                     reject(error);
                 }
             );
        });
    }
    
    
    /**
 * Crea y añade un NPC a la escena y a las listas globales.
 * Carga el modelo GLB, calcula offset, aplica escala, configura userData,
 * añade marcador quest y añade el NPC a la escena y listas `world`.
 * (v6.1 - Async, llamada desde ChunkManager con Y precalculada)
 *
 * @param {string} npcType - El ID del tipo de NPC (debe existir en npcDefinitions).
 * @param {THREE.Vector3} position - La posición exacta (X, Y, Z) donde debe aparecer el NPC (Y ya calculada por ChunkManager).
 * @param {number} rotationY - La rotación inicial en radianes alrededor del eje Y.
 * @returns {Promise<THREE.Object3D | null>} Una promesa que se resuelve con el objeto NPC creado o null si falla.
 */
async function createAndAddNPC(npcType, position, rotationY) {
    // 1. --- Obtener Definición y Validar ---
    const npcDef = npcDefinitions[npcType];
    if (!npcDef) {
        console.error(`createAndAddNPC: Definición no encontrada para npcType: ${npcType}`);
        return null;
    }
    if (!npcDef.modelPath) {
        console.warn(`createAndAddNPC: NPC tipo '${npcType}' no tiene 'modelPath'. No se puede crear visualmente.`);
        return null;
    }
    if (!(position instanceof THREE.Vector3) || isNaN(position.x) || isNaN(position.y) || isNaN(position.z) ) {
        console.error(`createAndAddNPC: Posición inválida para ${npcType}:`, position);
        return null;
    }
    console.log(`[createAndAddNPC v6.1] Creando NPC tipo: ${npcType} en (${position.x.toFixed(1)}, ${position.y.toFixed(1)}, ${position.z.toFixed(1)})`);

    try {
        // 2. --- Cargar Modelo GLB ---
        // Usa la función global loadGLBModel que devuelve una promesa
        const { scene: loadedModel, animations: loadedAnimations } = await loadGLBModel(npcDef.modelPath);
        console.log(`  -> Modelo GLB cargado para ${npcType}`);

        // 3. --- Crear Grupo Padre y Posicionar ---
        const npcGroup = new THREE.Group();
        npcGroup.name = `NPC_${npcType}_${npcGroup.uuid.substring(0,4)}`; // Nombre más único
        // *** Usar la posición Y PRECALCULADA que viene del marcador ***
        npcGroup.position.copy(position);
        npcGroup.rotation.y = rotationY ?? (Math.random() * Math.PI * 2);

        // 4. --- Procesar Modelo Visual (Escala, Sombras, Rotación Interna) ---
        loadedModel.name = "NPCVisualModel";
        loadedModel.rotation.y = -Math.PI / 2; // Orientación estándar (ajustar si tu modelo viene diferente)
        loadedModel.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });

        // Aplicar escala (general o específica de definición)
        let npcScale = npcDef.scaleMultiplier || 1.7; // Usar escala de definición o un default razonable
        loadedModel.scale.set(npcScale, npcScale, npcScale);

        npcGroup.add(loadedModel); // Añadir modelo visual al grupo

        // 5. --- Añadir Marcador Quest (!) ---
        const modelBox = new THREE.Box3().setFromObject(loadedModel); // Calcular BBox DESPUÉS de escalar
        // Calcular offset basado en el tamaño real del modelo escalado
        const modelHeight = (modelBox.max.y - modelBox.min.y);
        const markerHeightOffset = modelBox.max.y + 0.4; // Posicionar encima del BBox
        const questMarkerGeom = new THREE.PlaneGeometry(0.5, 0.5);
        const questMarkerMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, side: THREE.DoubleSide, depthTest: false, depthWrite: false });
        // TODO: Reemplazar con una textura de '!' usando MeshBasicMaterial({ map: texture, ... })
        const questMarker = new THREE.Mesh(questMarkerGeom, questMarkerMat);
        questMarker.name = "QuestMarker";
        questMarker.position.y = markerHeightOffset;
        questMarker.rotation.x = 0; // Puede necesitar ajustar la rotación X/Y para encarar cámara
        questMarker.visible = false; // Oculto por defecto, updateNPCMarkers lo controla
        npcGroup.add(questMarker); // Añadir al grupo principal del NPC

        // 6. --- Configurar Animaciones ---
        let mixer = null; const animationClipsMap = {};
        if (loadedAnimations && loadedAnimations.length > 0) {
            mixer = new THREE.AnimationMixer(loadedModel);
            loadedAnimations.forEach(clip => { if (clip.name) animationClipsMap[clip.name.toLowerCase()] = clip; });
            // Buscar animación 'idle' o 'idle_base' o la primera como fallback
            const idleClip = animationClipsMap['idle'] || animationClipsMap['idle_base'] || Object.values(animationClipsMap)[0];
            if (idleClip) {
                 mixer.clipAction(idleClip).play();
                 console.log(`  -> Animación Idle ('${idleClip.name}') iniciada para ${npcType}`);
            } else { console.warn(`  -> NPC ${npcType} no tiene animación 'idle'.`); }
        }

        // 7. --- Configurar UserData (Incluyendo BoundingBox) ---
        // Calcular Bounding Box del GRUPO completo (incluye marcador) para interacción
        const groupBox = new THREE.Box3().setFromObject(npcGroup);
        npcGroup.userData = {
            type: 'npc', // Identificador clave
            npcType: npcType,
            name: npcDef.name || npcType,
            icon: npcDef.icon || 'fa-user',
            modelPath: npcDef.modelPath,
            interactable: true, // La mayoría de NPCs son interactuables
            interact: () => openDialog(npcGroup), // Acción por defecto: abrir diálogo
            mixer: mixer,
            animations: animationClipsMap,
            heightOffset: modelHeight, // Altura del modelo visual (para targeting)
            boundingBox: groupBox, // BBox del grupo para interacción/colisión
            // Añadir datos específicos si es necesario (ej: para IA)
            aiState: 'idle', // Estado inicial IA
            spawnPosition: npcGroup.position.clone() // Guardar posición inicial (importante)
            // No copiar diálogos/tienda aquí, leerlos de npcDefinitions cuando sea necesario
        };


        // 8. --- Añadir a Listas Globales y Escena ---
        scene.add(npcGroup);
        world.npcs.push(npcGroup);
        world.interactables.push(npcGroup);
        // world.objects.push(npcGroup); // NO añadir a world.objects si no es estático

        console.log(`   -> NPC ${npcDef.name || npcType} creado y añadido a escena/listas.`);
        return npcGroup; // Devolver objeto creado

    } catch (error) {
        console.error(`Error fatal creando NPC tipo '${npcType}' desde ${npcDef.modelPath}:`, error);
        return null; // Devolver null en caso de error
    }
} // Fin createAndAddNPC (v6.1)
    
  
      //===============================================================
    // FUNCTION: updateCameraPosition (COMPLETE - v6 Filter Colliders)
    //===============================================================
    /**
     * Actualiza la posición y orientación de la cámara para seguir al jugador
     * en tercera persona, manejando colisiones con el entorno de forma optimizada.
     * (v6 - Filter Collision Candidates)
     * @param {number} deltaTime - Tiempo transcurrido desde el último frame en segundos.
     */
    function updateCameraPosition(deltaTime) {
        // --- 1. Validaciones Esenciales ---
        if (!camera || !orbitControls || !playerModel || !playerState?.position) {
            if (!updateCameraPosition.warned) {
                 console.warn("updateCameraPosition: Faltan elementos esenciales (cámara, controles, jugador, posición).");
                 updateCameraPosition.warned = true;
            }
            return;
        }
        updateCameraPosition.warned = false; // Resetear advertencia si todo está bien

        // --- 2. Calcular el Punto de Mira (Target) ---
        const targetLookAtPosition = playerState.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.6, 0));
        const targetLerpFactor = Math.min(1.0, 18 * deltaTime);
        orbitControls.target.lerp(targetLookAtPosition, targetLerpFactor);

        // --- 3. Calcular la Posición DESEADA de la Cámara ---
        const currentZoomDistance = orbitControls.getDistance();
        const targetDistance = Math.max(orbitControls.minDistance, currentZoomDistance);
        const desiredOffsetDirection = cameraOffset.clone().normalize();
        desiredOffsetDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerState.rotationY);
        const desiredCameraPosition = orbitControls.target.clone().addScaledVector(desiredOffsetDirection, targetDistance);

        // --- 4. Comprobar Colisiones (Raycast Optimizado) ---
        const rayOrigin = orbitControls.target.clone().add(new THREE.Vector3(0, 0.2, 0)); // Origen un poco elevado
        const rayDirection = new THREE.Vector3().subVectors(desiredCameraPosition, rayOrigin).normalize();
        const maxRayDistance = targetDistance;

        const cameraCollisionRaycaster = window.cameraCollisionRaycaster || (window.cameraCollisionRaycaster = new THREE.Raycaster());
        cameraCollisionRaycaster.near = 0.1;
        cameraCollisionRaycaster.far = maxRayDistance + 0.1;
        cameraCollisionRaycaster.set(rayOrigin, rayDirection);

        // --- *** OPTIMIZED Collision Candidate Gathering *** ---
        const collisionCandidates = [];
        const playerChunkX = ChunkManager.playerChunkCoords.x;
        const playerChunkZ = ChunkManager.playerChunkCoords.z;
        const checkDist = 1; // Chunks a revisar

        for (let dx = -checkDist; dx <= checkDist; dx++) {
            for (let dz = -checkDist; dz <= checkDist; dz++) {
                const chunk = ChunkManager.activeChunks.get(`${playerChunkX + dx}_${playerChunkZ + dz}`);
                if (!chunk) continue;
                // a) Add Terrain Mesh
                if (chunk.terrainMesh?.visible) {
                    collisionCandidates.push(chunk.terrainMesh);
                }
                // b) Add only SPECIFIC object types marked as camera collidable
                chunk.objects?.forEach(obj => {
                    // ESTA ES LA LÍNEA PROBLEMÁTICA -> && obj.userData.cameraCollidable === true
                    if (obj && obj !== playerModel && obj.visible && obj.userData?.boundingBox && obj.userData.cameraCollidable === true) { // <<<--- CHECK THE FLAG
                        collisionCandidates.push(obj);
                    }
                });
            }
        }
        const validCandidates = [...new Set(collisionCandidates.filter(o => o != null))]; // Filter nulls and duplicates
        // --- *** END OPTIMIZED Gathering *** ---

        let collisionDistance = maxRayDistance; // Default distance

        // Perform Raycast against the filtered candidates
        if (validCandidates.length > 0) { // Only raycast if there's anything to hit
             // console.log(`[CamCollision] Raycasting against ${validCandidates.length} candidates.`); // DEBUG
             try {
                 const intersects = cameraCollisionRaycaster.intersectObjects(validCandidates, true);
                 if (intersects.length > 0) {
                     // Find the first *actual* collision (not triggers, etc.)
                     const firstValidIntersect = intersects.find(intersect => !intersect.object.userData?.isTrigger);
                     if (firstValidIntersect) {
                         collisionDistance = firstValidIntersect.distance;
                         // console.log(`[CamCollision] Hit ${firstValidIntersect.object.name || firstValidIntersect.object.userData?.type} at ${collisionDistance.toFixed(2)}m`); // DEBUG
                     }
                 }
             } catch (e) { console.error("Error in camera collision raycast:", e); }
        } else {
             // console.log("[CamCollision] No relevant collision candidates found."); // DEBUG
        }


        // --- 5. Calcular Posición FINAL de la Cámara (Same as before) ---
        const minimumCameraTargetDistance = 1.5;
        const collisionBuffer = 0.3;
        const finalDistance = Math.max(minimumCameraTargetDistance, collisionDistance - collisionBuffer);
        const finalCameraPosition = orbitControls.target.clone().addScaledVector(rayDirection, finalDistance);

        // --- 6. Ajuste Vertical Final (Same as before) ---
        const finalCamTerrainHeight = ChunkManager.getTerrainHeightAt(finalCameraPosition.x, finalCameraPosition.z);
        const minHeightAboveTerrain = 0.5;
        finalCameraPosition.y = Math.max(finalCameraPosition.y, finalCamTerrainHeight + minHeightAboveTerrain);

        // --- 7. Aplicar Posición Suavizada (Lerp) (Same as before) ---
        const positionLerpFactor = Math.min(1.0, 20 * deltaTime);
        camera.position.lerp(finalCameraPosition, positionLerpFactor);

        // --- 8. Forzar Orientación (Same as before) ---
        camera.lookAt(orbitControls.target);

        // --- 9. OrbitControls Update (Handled in main loop) ---

    } // --- Fin updateCameraPosition (v6) ---
    updateCameraPosition.warned = false;
    
    async function setupSceneContent() {
        console.log("--- Iniciando setupSceneContent ---");
        setupLighting();
        createWater(); // El agua global se mantiene por ahora
        // createWorldObjects(); // Objetos estáticos ahora manejados por ChunkManager

        console.log("   -> Iniciando cargas paralelas...");
        try {
            await Promise.all([
                createPlayer(),
                createNPCs(), // NPCs se añadirán a world.npcs
            ]);
            console.log("   -> Cargas paralelas completadas.");
        } catch (error) {
             console.error("Error crítico durante la carga paralela de personajes:", error); throw error;
        }

        // createInteractables(); // Recursos/cofres generados por ChunkManager al cargar
        setupWeatherSystem();

        if (playerModel) { camera.lookAt(playerModel.position); }
        console.log("--- setupSceneContent Finalizado ---");
    }

    //==================================================
    // FUNCTION: setupThreeJS (MODIFICADA)
    //==================================================
    function setupThreeJS() {
        console.log("--- Iniciando setupThreeJS (vEnhancedLighting + Brightness) ---");

        // --- 1. Scene ---
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2b3c);
        scene.fog = new THREE.Fog(0x1a2b3c, 80, 250);

        // --- 2. Camera ---
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        // --- 3. Renderer ---
        const gameCanvas = domCache["game-canvas"];
        if (!(gameCanvas instanceof HTMLCanvasElement)) { throw new Error("Canvas del juego (#game-canvas) no encontrado o no es un canvas."); }
        renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, renderPixelRatio));
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        // *** APLICAR BRILLO INICIAL ***
        renderer.toneMappingExposure = gameBrightness; // Usa la variable global
        console.log(`Renderer Initial Brightness (Exposure) set to: ${renderer.toneMappingExposure}`);

        // --- 4. Shadows ---
        renderer.shadowMap.enabled = shadowQuality !== 'off';
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // --- 5. Helpers ---
        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // --- 6. OrbitControls ---
        try {
            if (typeof THREE.OrbitControls === 'undefined') { console.error("THREE.OrbitControls no está definido."); orbitControls = null; }
            else { orbitControls = new THREE.OrbitControls(camera, renderer.domElement); /* ... configuración orbit controls ... */ orbitControls.enableZoom = true; orbitControls.enableRotate = false; orbitControls.enablePan = false; orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.08; orbitControls.minDistance = 2.0; orbitControls.maxDistance = 20.0; orbitControls.mouseButtons = { LEFT: null, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: null }; orbitControls.touches = { ONE: THREE.TOUCH.DOLLY, TWO: null }; orbitControls.target.set(0, PLAYER_HALF_HEIGHT, 0); console.log("OrbitControls inicializado para zoom/damping."); }
        } catch(e) { console.error("Error inicializando OrbitControls:", e); orbitControls = null; }

        console.log("Three.js inicializado correctamente (vEnhancedLighting + Brightness).");
    }

function setupLighting() {
    console.log("--- Iniciando setupLighting (vLightingIntensity + BaseIntensity) ---");
    const lightsToRemove = [];
    scene.traverse(obj => { if (obj.isLight) { lightsToRemove.push(obj); } });
    lightsToRemove.forEach(light => scene.remove(light));

    const baseHemisphereIntensity = 0.75;
    const skyColor = 0xc8daec; const groundColor = 0x907b6a;
    const hemisphereLight = new THREE.HemisphereLight(skyColor, groundColor, baseHemisphereIntensity * lightingIntensityFactor);
    hemisphereLight.position.set(0, 50, 0);
    hemisphereLight.userData = { type: 'hemisphere', baseIntensity: baseHemisphereIntensity };
    scene.add(hemisphereLight);

    const baseAmbientIntensity = 0.35;
    const ambient = new THREE.AmbientLight(0xffffff, baseAmbientIntensity * lightingIntensityFactor);
    ambient.userData = { type: 'ambient', baseIntensity: baseAmbientIntensity };
    scene.add(ambient);

    const baseSunIntensity = 1.4;
    const sunLight = new THREE.DirectionalLight(0xffffff, baseSunIntensity * lightingIntensityFactor);
    sunLight.position.set(100, 120, 80);
    sunLight.castShadow = (shadowQuality !== 'off');
    sunLight.userData = { type: 'sun', baseIntensity: baseSunIntensity };
    if (sunLight.castShadow) { const mapSize = shadowQuality === 'high' ? 2048 : (shadowQuality === 'medium' ? 1024 : 512); sunLight.shadow.mapSize.width = mapSize; sunLight.shadow.mapSize.height = mapSize; sunLight.shadow.camera.near = 1; sunLight.shadow.camera.far = 350; const shadowCamSize = WORLD_SIZE * 0.6; sunLight.shadow.camera.left = -shadowCamSize; sunLight.shadow.camera.right = shadowCamSize; sunLight.shadow.camera.top = shadowCamSize; sunLight.shadow.camera.bottom = -shadowCamSize; sunLight.shadow.bias = -0.001; }
    scene.add(sunLight);
    if(!sunLight.target.parent) scene.add(sunLight.target);

    const baseMoonIntensity = 0.25;
    const moonLight = new THREE.DirectionalLight(0x9ab8d4, baseMoonIntensity * lightingIntensityFactor);
    moonLight.position.set(-100, 100, -60);
    moonLight.castShadow = false;
    moonLight.userData = { type: 'moon', baseIntensity: baseMoonIntensity };
    scene.add(moonLight);
    if(!moonLight.target.parent) scene.add(moonLight.target);

    playerLight = new THREE.PointLight(0xffb87c, 0, 12, 1.8);
    playerLight.castShadow = false; playerLight.userData = { type: 'player_light' };
    scene.add(playerLight);
    console.log("--- setupLighting (vLightingIntensity + BaseIntensity) Finalizado ---");
} 
    
    
    function createWater() {
        const geometry = new THREE.PlaneGeometry(WORLD_SIZE * 1.5, WORLD_SIZE * 1.5);
        const material = new THREE.MeshStandardMaterial({ color: 0x336699, transparent: true, opacity: 0.80, roughness: 0.15, metalness: 0.1 });
        world.water = new THREE.Mesh(geometry, material); world.water.rotation.x = -Math.PI / 2; world.water.position.y = WATER_LEVEL;
        world.water.receiveShadow = true; world.water.userData = { type: 'water' }; scene.add(world.water);
    }

/**
 * Obtiene la altura final del terreno en coordenadas del mundo.
 * Delega la llamada al ChunkManager.
 */
 function getTerrainHeight(x, z) {
    if (typeof ChunkManager !== 'undefined' && ChunkManager.getTerrainHeightAt) {
        return ChunkManager.getTerrainHeightAt(x, z);
    } else {
        console.warn("getTerrainHeight: ChunkManager no disponible, usando fallback WATER_LEVEL.");
        return WATER_LEVEL; // WATER_LEVEL debe ser una constante global
    }
}


/**
 * Obtiene el nombre del bioma en coordenadas del mundo.
 * Delega la llamada al ChunkManager y luego busca el nombre.
 */
function getBiome(x, z) {
    if (typeof ChunkManager !== 'undefined' && ChunkManager.getBiomeIdAt && typeof worldData !== 'undefined' && worldData.getBiomeName) {
        const biomeId = ChunkManager.getBiomeIdAt(x, z);
        return worldData.getBiomeName(biomeId);
    } else {
         console.warn("getBiome: ChunkManager o worldData no disponibles, usando fallback 'grassland'.");
        return 'grassland';
    }
}


/**
 * Calcula la influencia (0 a 1) de las carreteras en un punto dado.
 * Necesita worldData.roadSegments definido y precalculado en ChunkManager.init.
 */
function getRoadInfluence(x, z) {
    let maxInfluence = 0;
    const roadSegments = worldData?.roadSegments;
    if (!Array.isArray(roadSegments) || roadSegments.length === 0) return 0;
    const roadWidthSq = ROAD_WIDTH * ROAD_WIDTH; // ROAD_WIDTH es una constante global
    if (roadWidthSq <= 0) return 0;

    for (const segment of roadSegments) {
        const p1 = segment.start; const p2 = segment.end;
        if (!p1 || !p2) continue;
        const dx = p2.x - p1.x; const dz = p2.z - p1.z; const lenSq = dx * dx + dz * dz;
        if (lenSq < 0.0001) { // Segmento es un punto
             const distSq = (x - p1.x)**2 + (z - p1.z)**2;
             maxInfluence = Math.max(maxInfluence, Math.max(0, 1 - distSq / roadWidthSq));
             continue;
        }
        let t = ((x - p1.x) * dx + (z - p1.z) * dz) / lenSq;
        t = Math.max(0, Math.min(1, t)); // Limitar al segmento
        const closestX = p1.x + t * dx; const closestZ = p1.z + t * dz;
        const distSq = (x - closestX)**2 + (z - closestZ)**2;
        maxInfluence = Math.max(maxInfluence, Math.max(0, 1 - distSq / roadWidthSq));
    }
    return maxInfluence;
}


/**
 * Crea el objeto 3D del jugador REAL para el juego, cargando dinámicamente su modelo GLB
 * basado en la raza y género seleccionados FINALMENTE en `playerState`.
 * Incluye fallback visual si la carga falla.
 * (v11 - CORREGIDO para usar playerState en carga inicial)
 */
async function createPlayer() {
    const functionName = "createPlayer (v11 - Game Start)";
    console.log(`--- Iniciando ${functionName} ---`);

    // --- 1. Limpieza del Modelo Anterior (Igual que antes) ---
    if (playerModel && playerModel.parent) {
        // ... (código de limpieza idéntico a la versión anterior) ...
        const oldVisual = playerModel.getObjectByName("PlayerVisualModel") || playerModel.getObjectByName("PlayerVisualFallbackGLB") || playerModel.getObjectByName("PlayerFallbackVisualCylinder");
        if (oldVisual && playerState.mixer && playerState.mixer.getRoot() === oldVisual) {
            try { playerState.mixer.stopAllAction(); } catch(e) { console.warn("Error deteniendo mixer del jugador anterior:", e); }
        }
        scene.remove(playerModel);
    }
    playerModel = null;
    playerMeshes = {};
    playerState.mixer = null;
    playerState.animations = {};

    // --- 2. Crear Grupo Padre (Igual que antes) ---
    playerModel = new THREE.Group();
    playerModel.name = "Player";
    if (!playerState.position || !(playerState.position instanceof THREE.Vector3)) { playerState.position = new THREE.Vector3().copy(RESPAWN_POINT); }
    if (typeof playerState.rotationY !== 'number' || isNaN(playerState.rotationY)) { playerState.rotationY = Math.PI; }
    playerModel.position.copy(playerState.position);
    playerModel.rotation.y = playerState.rotationY;
    scene.add(playerModel);

    // --- 3. Definir Collider Lógico (Igual que antes) ---
    const playerSize = new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2);
    playerCollider = new THREE.Box3( new THREE.Vector3(-playerSize.x/2, -PLAYER_HALF_HEIGHT, -playerSize.z/2), new THREE.Vector3(playerSize.x/2, PLAYER_HALF_HEIGHT, playerSize.z/2) );
    // La posición del collider se actualiza en updatePlayer

    // --- 4. Cargar Modelo GLB (Dinámico - *** CORRECCIÓN AQUÍ ***) ---
    let modelPath = ''; // Para logs
    let visualModelLoaded = false;
    let loadedVisualModel = null;
    let loadedAnimations = [];

    try {
        if (!gltfLoader) throw new Error("GLTFLoader no inicializado.");

        // *** ¡¡LA CLAVE ESTÁ AQUÍ!! ***
        // Usar la raza y género guardados en playerState DESPUÉS de la selección
        const finalRace = playerState.race || 'human'; // Usa el estado actual o un default seguro
        const finalGender = playerState.gender || 'male'; // Usa el estado actual o un default seguro
        console.log(`[${functionName}] Usando estado FINAL: Race=${finalRace}, Gender=${finalGender}`);

        // Generar la ruta con los valores FINALES
        modelPath = getPlayerModelPath(finalRace, finalGender); // Llama a la función helper con el estado correcto
        // *** ¡¡FIN DE LA CORRECCIÓN CLAVE!! ***

        console.log(`[${functionName}] Intentando cargar modelo: ${modelPath}`);
        const gltf = await loadGLBModel(modelPath);
        if (!gltf || !gltf.scene) throw new Error(`Modelo GLTF principal inválido o sin escena en: ${modelPath}`);

        loadedVisualModel = gltf.scene;
        loadedAnimations = gltf.animations;
        loadedVisualModel.name = "PlayerVisualModel";
        console.log(`[${functionName}] Modelo GLB principal '${modelPath}' cargado con éxito.`);
        visualModelLoaded = true;

    } catch (error) {
        // --- 5. Manejo de Errores y Fallback (Igual que antes) ---
        const fallbackModelPath = 'models/characters/human_male.glb';
        console.error(`[${functionName}] !¡!¡! FALLÓ CARGA MODELO JUGADOR '${modelPath}' !¡!¡! Intentando fallback...`, error);
        logMessage("Error: No se pudo cargar el modelo del jugador.", "error");
        try {
            console.log(`   -> Intentando fallback GLB: ${fallbackModelPath}`);
            const fallbackGltf = await loadGLBModel(fallbackModelPath);
            if (fallbackGltf && fallbackGltf.scene) {
                loadedVisualModel = fallbackGltf.scene;
                loadedAnimations = fallbackGltf.animations;
                loadedVisualModel.name = "PlayerVisualFallbackGLB";
                console.log("   -> Fallback GLB cargado.");
                visualModelLoaded = true;
            } else { throw new Error("Fallback GLB inválido."); }
        } catch (fallbackLoadError) {
             console.error("   -> Fallo al cargar fallback GLB. Creando cilindro.", fallbackLoadError);
            try {
                const fallbackGeom = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 8);
                const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xff0000, name: "FallbackMaterialCylinder" });
                const fallbackMesh = new THREE.Mesh(fallbackGeom, fallbackMat);
                fallbackMesh.name = "PlayerFallbackVisualCylinder"; fallbackMesh.castShadow = true;
                if (playerModel instanceof THREE.Group) playerModel.add(fallbackMesh);
                console.log("   -> Fallback visual (cilindro rojo) añadido.");
            } catch (cylinderError) { console.error("   -> Error crítico creando fallback cilindro:", cylinderError); }
        }
    }

    // --- 6. Procesar Modelo Visual Cargado (Si se cargó un GLB - Igual que antes) ---
    if (visualModelLoaded && loadedVisualModel) {
        // ... (código para ajustar material, escala, rotación, animaciones, anclajes - idéntico a v10.1) ...
        loadedVisualModel.traverse((child) => { /* ... ajustar materiales ... */ });
        const playerScaleFactor = 1.8;
        loadedVisualModel.scale.set(playerScaleFactor, playerScaleFactor, playerScaleFactor);
        loadedVisualModel.rotation.y = -Math.PI / 2;
        playerModel.add(loadedVisualModel);

        if (loadedAnimations?.length > 0) {
            playerState.mixer = new THREE.AnimationMixer(loadedVisualModel);
            loadedAnimations.forEach(clip => { if(clip.name) { playerState.animations[clip.name.toLowerCase()] = clip; } });
            playPlayerAnimation('idle'); // Usa la función global playPlayerAnimation
        } else { playerState.mixer = null; playerState.animations = {}; }

        // Configurar anclajes
        const weaponHandNode = loadedVisualModel.getObjectByName("WeaponHand_R") || loadedVisualModel.getObjectByName("mixamorigRightHand");
        const shieldHandNode = loadedVisualModel.getObjectByName("ShieldHand_L") || loadedVisualModel.getObjectByName("mixamorigLeftHand");
        if (weaponHandNode) { playerMeshes.weaponHand = weaponHandNode; }
        else { playerMeshes.weaponHand = new THREE.Object3D(); /* ... crear fallback ... */ loadedVisualModel.add(playerMeshes.weaponHand); }
        if (shieldHandNode) { playerMeshes.shieldHand = shieldHandNode; }
        else { playerMeshes.shieldHand = new THREE.Object3D(); /* ... crear fallback ... */ loadedVisualModel.add(playerMeshes.shieldHand); }

        // Aplicar equipo visual inicial (importante que se haga después de cargar el modelo correcto)
        updatePlayerAppearance();
    }

    // --- 7. Crear Luz del Jugador (Igual que antes) ---
    if (!playerLight) {
         playerLight = new THREE.PointLight(0xffaa55, 0, 10, 1.8); scene.add(playerLight);
    }

    console.log(`--- ${functionName} Finalizado ---`);
} // Fin createPlayer (v11)
    
    
    
async function createNPCs() {
        console.log("--- Iniciando createNPCs (v5 - Con Marcador Quest) ---");
        // Limpiar NPCs anteriores
        if (world.npcs && world.npcs.length > 0) {
            console.log(`Limpiando ${world.npcs.length} NPCs anteriores...`);
            world.npcs.forEach(npc => {
                if (npc.userData?.mixer) npc.userData.mixer.stopAllAction();
                if (npc.parent) scene.remove(npc);
                // Remover de listas globales
                const interactableIndex = world.interactables.indexOf(npc); if(interactableIndex > -1) world.interactables.splice(interactableIndex, 1);
                const worldObjectIndex = world.objects.indexOf(npc); if(worldObjectIndex > -1) world.objects.splice(worldObjectIndex, 1); // Remover de objects si se añadió
            });
        }
        world.npcs = []; // Resetear array
        console.log("NPCs anteriores limpiados.");

        // Preparar promesas de carga
        const loadPromises = [];
        Object.entries(npcDefinitions).forEach(([npcType, npcDef]) => {
            if (!npcDef.modelPath) {
                console.warn(`NPC tipo '${npcType}' (${npcDef.name}) NO tiene 'modelPath'. Saltando.`);
                return; // Saltar si no hay modelo definido
            }

            const npcLoadPromise = new Promise(async (resolve) => {
                try {
                    // a. Cargar Modelo
                    const gltf = await loadGLBModel(npcDef.modelPath);
                    const loadedModel = gltf.scene;
                    const loadedAnimations = gltf.animations;

                    // b. Encontrar Posición Válida
                    let x, z, terrainY, finalY; let positionFound = false; let attempts = 0; const maxAttempts = 35;
                    if (npcDef.spawnPosition) { // Usar posición fija si se define
                         x = npcDef.spawnPosition.x; z = npcDef.spawnPosition.z;
                         terrainY = ChunkManager.getTerrainHeightAt(x, z);
                         positionFound = true;
                    } else { // Buscar posición en ciudad o aleatoria
                        while (!positionFound && attempts < maxAttempts) {
                             attempts++;
                             const cityData = worldData.cities.find(c => c.id === (npcDef.spawnCityId || 'ullathorpe')); // Ciudad por defecto o específica
                             let basePosX = RESPAWN_POINT.x, basePosZ = RESPAWN_POINT.z; // Fallback si no hay ciudad
                             let spawnRadius = 15;
                             if (cityData) { basePosX = cityData.center.x; basePosZ = cityData.center.z; spawnRadius = cityData.radius * 0.9; }
                             const angle = Math.random() * Math.PI * 2;
                             const distance = Math.random() * spawnRadius;
                             x = basePosX + Math.cos(angle) * distance; z = basePosZ + Math.sin(angle) * distance;
                             terrainY = ChunkManager.getTerrainHeightAt(x, z);
                             const biome = getBiome(x, z);
                             if (terrainY >= WATER_LEVEL && biome !== 'water') {
                                 // Simple check para no spawnear encima de otros NPCs
                                 let tooClose = world.npcs.some(existingNpc => existingNpc.position.distanceToSquared(new THREE.Vector3(x,terrainY,z)) < 2*2);
                                 if (!tooClose) positionFound = true;
                             }
                        }
                        if (!positionFound) { console.warn(`No se encontró posición válida para ${npcDef.name}, usando fallback.`); x = RESPAWN_POINT.x + (Math.random()-0.5)*3; z = RESPAWN_POINT.z + (Math.random()-0.5)*3; terrainY = ChunkManager.getTerrainHeightAt(x, z); if(terrainY < WATER_LEVEL) terrainY = WATER_LEVEL + 0.1;}
                    }

                    // c. Calcular Offset Pivote y Y Final
                    const modelBox = new THREE.Box3().setFromObject(loadedModel);
                    const pivotOffsetY = -modelBox.min.y; // Distancia base modelo a pivote
                    const definedHeightOffset = npcDef.heightOffset; // Permitir override en definición
                    const finalHeightOffset = (typeof definedHeightOffset === 'number') ? definedHeightOffset : pivotOffsetY;
                    finalY = terrainY + finalHeightOffset;

                    // d. Crear Grupo y Posicionar
                    const npcGroup = new THREE.Group(); npcGroup.name = `NPC_${npcType}`;
                    npcGroup.position.set(x, finalY, z); npcGroup.rotation.y = npcDef.spawnRotationY ?? (Math.random() * Math.PI * 2); // Rotación específica o aleatoria

                    // e. Procesar Modelo Visual
                    loadedModel.name = "NPCVisualModel"; loadedModel.rotation.y = -Math.PI / 2; // Corregir orientación si es necesario
                    loadedModel.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
                    let npcScale = 1.0; // Escala base
                    if (npcDef.scaleMultiplier) { npcScale = npcDef.scaleMultiplier; }
                    else { /* Escalas por defecto si se necesita */ }
                    loadedModel.scale.set(npcScale, npcScale, npcScale);
                    npcGroup.add(loadedModel);

                     // f. Añadir Marcador Quest '!'
                    const questMarkerGeom = new THREE.PlaneGeometry(0.5, 0.5);
                    const questMarkerMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.9, side: THREE.DoubleSide, depthTest: false, depthWrite: false });
                    // TODO: Usar textura '!' en lugar de color plano
                    const questMarker = new THREE.Mesh(questMarkerGeom, questMarkerMat); questMarker.name = "QuestMarker";
                    questMarker.position.y = (modelBox.max.y - modelBox.min.y) * npcScale + 0.4; // Encima del bounding box escalado
                    questMarker.rotation.y = Math.PI; questMarker.visible = false;
                    npcGroup.add(questMarker); // Añadir al grupo principal del NPC

                    // g. Configurar Animaciones
                    let mixer = null; const animationClipsMap = {};
                    if (loadedAnimations && loadedAnimations.length > 0) {
                        mixer = new THREE.AnimationMixer(loadedModel);
                        loadedAnimations.forEach(clip => { if(clip.name) animationClipsMap[clip.name.toLowerCase()] = clip; });
                        const idleClip = animationClipsMap['idle'] || animationClipsMap['idle_base'] || Object.values(animationClipsMap)[0];
                        if (idleClip) mixer.clipAction(idleClip).play();
                    }

                    // h. Configurar UserData
                    npcGroup.userData = {
                        type: 'npc', npcType: npcType, name: npcDef.name || npcType, icon: npcDef.icon || 'fa-user',
                        modelPath: npcDef.modelPath, interactable: true, interact: () => openDialog(npcGroup),
                        mixer: mixer, animations: animationClipsMap, heightOffset: finalHeightOffset,
                        // Añadir datos específicos si es necesario (ej: para IA)
                        patrolPoints: npcDef.patrolPoints || [], currentPatrolIndex: 0, aiState: 'idle',
                        spawnPosition: npcGroup.position.clone() // Guardar posición inicial
                    };
                    resolve(npcGroup); // Éxito
                } catch (error) { console.error(`Error procesando NPC tipo '${npcType}' desde ${npcDef.modelPath}:`, error); resolve(null); }
            });
            loadPromises.push(npcLoadPromise);
        }); // Fin forEach npcDefinitions

        // Esperar Cargas y Añadir a Escena/Listas
        console.log(`Esperando la carga de ${loadPromises.length} modelos de NPC...`);
        const loadedNPCResults = await Promise.all(loadPromises);
        console.log("Carga de modelos NPC completada.");
        let addedCount = 0;
        loadedNPCResults.forEach(npc => {
            if (npc instanceof THREE.Group) { scene.add(npc); world.npcs.push(npc); world.interactables.push(npc); world.objects.push(npc); /* Añadir a objects para colisión general */ addedCount++; }
        });
        console.log(`--- Fin createNPCs(). ${addedCount} NPCs añadidos. ---`);
    } // Fin createNPCs

    // function createWorldObjects() { /* --- ELIMINADA --- */ } // Objetos ahora en ChunkManager

    function getCityAtPosition(x, z) {
        for (const city of (worldData.cities || [])) { // Asegurar que cities existe
            const radius = city.radius || CITY_RADIUS;
            if ((x - city.center.x)**2 + (z - city.center.z)**2 < radius**2) {
                return city.id;
            }
        }
        return null;
    }
    
    
    async function preloadCoreAssets(updateLoadingUICallback, startProgress, progressPortion) {
    const functionName = "preloadCoreAssets";
    console.log(`--- ${functionName} Started ---`);
    let loadedCount = 0;
    const assetsToLoad = [];

    // 1. Gather Building Models
    const uniqueBuildingIds = new Set();
    (worldData?.cities || []).forEach(city => {
        (city.districts || []).forEach(district => {
            (district.buildings || []).forEach(building => {
                if (building.id && BUILDING_SCALES[building.id]?.modelPath) {
                    uniqueBuildingIds.add(building.id);
                } else if (building.id && !BUILDING_SCALES[building.id]?.modelPath) {
                    console.warn(`[${functionName}] No modelPath found for building ID: ${building.id}`);
                }
            });
        });
    });
    uniqueBuildingIds.forEach(id => {
        assetsToLoad.push({ type: 'building', id: id, path: BUILDING_SCALES[id].modelPath });
    });
    console.log(`[${functionName}] Buildings to load: ${uniqueBuildingIds.size}`);

    // 2. Gather POI Models
    const uniquePoiIds = new Set();
     (worldData?.specialLocations || []).forEach(loc => {
         const visualId = loc.visualDefId || loc.id;
         if (visualId && (loc.type === 'landmark' || loc.type === 'shrine') && POI_SCALES[visualId]?.modelPath) {
             uniquePoiIds.add(visualId);
         }
     });
     uniquePoiIds.forEach(id => {
         assetsToLoad.push({ type: 'poi', id: id, path: POI_SCALES[id].modelPath });
     });
     console.log(`[${functionName}] POIs to load: ${uniquePoiIds.size}`);

     // 3. Gather Dungeon Entrance Models
     const uniqueDungeonEntranceIds = new Set();
      (worldData?.specialLocations || []).forEach(loc => {
          const visualId = loc.visualDefId || loc.id;
          if (visualId && loc.type === 'dungeon_entrance' && DUNGEON_ENTRANCE_SCALES[visualId]?.modelPath) {
              uniqueDungeonEntranceIds.add(visualId);
          }
      });
      uniqueDungeonEntranceIds.forEach(id => {
          assetsToLoad.push({ type: 'dungeon_entrance', id: id, path: DUNGEON_ENTRANCE_SCALES[id].modelPath });
      });
      console.log(`[${functionName}] Dungeon Entrances to load: ${uniqueDungeonEntranceIds.size}`);

    // 4. Add Terrain Detail Texture
    assetsToLoad.push({ type: 'texture', id: 'terrain_detail', path: 'textures/terrain_detail.jpg' }); // Ajusta la ruta
    assetsToLoad.push({ type: 'texture', id: 'terrain_normal', path: 'textures/terrain_normal.jpg' }); // Ajusta la ruta (Opcional)

    // 5. Execute Loading
    const totalAssets = assetsToLoad.length;
    if (totalAssets === 0) {
        console.log(`[${functionName}] No core assets identified for preloading.`);
        areCoreAssetsPreloaded = true;
        updateLoadingUICallback(startProgress + progressPortion, "Assets preloaded.");
        return;
    }

    console.log(`[${functionName}] Total core assets to preload: ${totalAssets}`);
    const textureLoader = new THREE.TextureLoader();

    const loadPromises = assetsToLoad.map(asset => {
        return new Promise(async (resolve) => {
            try {
                if (asset.type === 'texture') {
                    textureLoader.load(
                        asset.path,
                        (texture) => {
                            texture.wrapS = texture.wrapT = THREE.RepeatWrapping; // Enable repeating
                            textureCache[asset.id] = texture;
                            loadedCount++;
                            updateLoadingUICallback(startProgress + (loadedCount / totalAssets) * progressPortion, `Loading Textures... (${loadedCount}/${totalAssets})`);
                            console.log(`   - Texture loaded: ${asset.id}`);
                            resolve();
                        },
                        undefined,
                        (err) => {
                            console.error(`Failed to load texture ${asset.id} from ${asset.path}:`, err);
                            resolve(); // Resolve even on error to not block loading
                        }
                    );
                } else { // Building, POI, Entrance
                    const gltf = await loadGLBModel(asset.path); // Reutiliza tu función de carga GLB
                    if (gltf && gltf.scene) {
                        if (asset.type === 'building') preloadedBuildingModels[asset.id] = gltf.scene;
                        else if (asset.type === 'poi') preloadedPOIs[asset.id] = gltf.scene;
                        else if (asset.type === 'dungeon_entrance') preloadedDungeonEntrances[asset.id] = gltf.scene;
                        console.log(`   - Model loaded: ${asset.type} - ${asset.id}`);
                    } else {
                        console.warn(`Failed to load or invalid GLTF for ${asset.type} ${asset.id}`);
                    }
                    loadedCount++;
                    updateLoadingUICallback(startProgress + (loadedCount / totalAssets) * progressPortion, `Loading Models... (${loadedCount}/${totalAssets})`);
                    resolve();
                }
            } catch (error) {
                console.error(`Error preloading ${asset.type} ${asset.id} from ${asset.path}:`, error);
                resolve(); // Continue loading other assets
            }
        });
    });

    await Promise.all(loadPromises);
    areCoreAssetsPreloaded = true;
    console.log(`--- ${functionName} Finished. Preloaded ${loadedCount}/${totalAssets} core assets. ---`);
    updateLoadingUICallback(startProgress + progressPortion, "Core assets loaded.");
}

/**
 * Carga y configura de forma asíncrona un modelo 3D para un edificio funcional.
 * Utiliza un switch para determinar la ruta del modelo GLB basado en el buildingId.
 * Aplica sombras y calcula un tamaño aproximado para userData.
 * Incluye un fallback visual si la carga falla o el ID es desconocido.
 * (v3 - Async, Completa con todos los IDs mencionados)
 *
 * @param {string} buildingId - El ID del edificio (ej: 'house_small', 'inn', 'blacksmith', 'castle_wall_section').
 * @returns {Promise<THREE.Object3D | null>} Una promesa que se resuelve con el objeto 3D del edificio
 *          (usualmente un THREE.Group conteniendo la escena del GLTF) o null si la carga falla críticamente.
 *          Puede resolver con un placeholder visual si la carga de un modelo específico falla.
 */
async function createFunctionalBuilding(buildingId) {
    console.log(`[createFunctionalBuilding v3] Solicitado: ${buildingId}`);
    let modelPath = null;
    let fallbackSize = { w: 4, h: 5, d: 4 }; // Tamaño por defecto para fallback

    // --- Mapeo de IDs a rutas de archivo GLB ---
    // Asegúrate que estas rutas coincidan con tu estructura de carpetas
    switch (buildingId) {
        // --- Viviendas ---
        case 'house_small': modelPath = 'models/buildings/house_small.glb'; fallbackSize={w:4,h:5,d:4}; break;
        case 'house_medium': modelPath = 'models/buildings/house_medium.glb'; fallbackSize={w:6,h:6,d:5}; break;
        case 'house_large': modelPath = 'models/buildings/house_large.glb'; fallbackSize={w:8,h:7,d:7}; break;
        case 'mansion_small': modelPath = 'models/buildings/mansion_small.glb'; fallbackSize={w:10,h:8,d:9}; break; // Necesita modelo
        case 'shack_simple': modelPath = 'models/buildings/shack_simple.glb'; fallbackSize={w:3,h:3,d:3}; break; // Necesita modelo
        case 'house_ruined': modelPath = 'models/buildings/house_ruined.glb'; fallbackSize={w:4,h:4,d:4}; break; // Para ciudad abandonada

        // --- Funcionales ---
        case 'inn': modelPath = 'models/buildings/inn.glb'; fallbackSize={w:8,h:7,d:10}; break;
        case 'blacksmith': modelPath = 'models/buildings/blacksmith.glb'; fallbackSize={w:6,h:5,d:7}; break;
        case 'temple': modelPath = 'models/buildings/temple.glb'; fallbackSize={w:7,h:8,d:9}; break;
        case 'temple_large': modelPath = 'models/buildings/temple_large.glb'; fallbackSize={w:12,h:15,d:14}; break;
        case 'library': modelPath = 'models/buildings/library.glb'; fallbackSize={w:9,h:8,d:11}; break;
        case 'library_small': modelPath = 'models/buildings/library_small.glb'; fallbackSize={w:6,h:7,d:6}; break;
        case 'shop_generic': modelPath = 'models/buildings/shop_generic.glb'; fallbackSize={w:5,h:5,d:6}; break;
        case 'shop_potion': modelPath = 'models/buildings/shop_potion.glb'; fallbackSize={w:4,h:5,d:4}; break; // Necesita modelo
        case 'shop_books': modelPath = 'models/buildings/shop_books.glb'; fallbackSize={w:5,h:6,d:5}; break; // Necesita modelo
        case 'alchemist_lab': modelPath = 'models/buildings/alchemist_lab.glb'; fallbackSize={w:6,h:6,d:6}; break;
        case 'guild_hall_small': modelPath = 'models/buildings/guild_hall_small.glb'; fallbackSize={w:8,h:7,d:9}; break; // Necesita modelo
        case 'guild_hall_medium': modelPath = 'models/buildings/guild_hall_medium.glb'; fallbackSize={w:12,h:9,d:14}; break; // Necesita modelo

        // --- Mercado ---
        case 'market_stalls': modelPath = 'models/buildings/market_stalls.glb'; fallbackSize={w:3,h:2.5,d:2}; break;
        case 'market_stalls_desert': modelPath = 'models/buildings/market_stalls_desert.glb'; fallbackSize={w:3.5,h:3,d:2.5}; break;

        // --- Militares / Guardia ---
        case 'guard_tower_small': modelPath = 'models/buildings/guard_tower_small.glb'; fallbackSize={w:3,h:8,d:3}; break;
        case 'barracks': modelPath = 'models/buildings/barracks.glb'; fallbackSize={w:10,h:6,d:12}; break;
        case 'barracks_small': modelPath = 'models/buildings/barracks_small.glb'; fallbackSize={w:7,h:5,d:8}; break;
        case 'armory_small': modelPath = 'models/buildings/armory_small.glb'; fallbackSize={w:4,h:4,d:5}; break; // Necesita modelo

        // --- Castillo ---
        case 'castle_wall_section': modelPath = 'models/buildings/castle_wall_section.glb'; fallbackSize={w:10,h:7,d:2}; break;
        case 'castle_tower': modelPath = 'models/buildings/castle_tower.glb'; fallbackSize={w:5,h:12,d:5}; break;
        case 'castle_gatehouse': modelPath = 'models/buildings/castle_gatehouse.glb'; fallbackSize={w:8,h:10,d:6}; break;
        case 'castle_keep': modelPath = 'models/buildings/castle_keep.glb'; fallbackSize={w:15,h:20,d:18}; break; // Necesita modelo

        // --- Puerto ---
        case 'dock_section': modelPath = 'models/buildings/dock_section.glb'; fallbackSize={w:8,h:1,d:3}; break;
        case 'warehouse': modelPath = 'models/buildings/warehouse.glb'; fallbackSize={w:10,h:7,d:15}; break;
        case 'warehouse_small': modelPath = 'models/buildings/warehouse_small.glb'; fallbackSize={w:7,h:6,d:10}; break;

        // --- Tribales / Orcos / Goblins ---
        case 'orc_hut_large': modelPath = 'models/buildings/orc_hut_large.glb'; fallbackSize={w:6,h:5,d:6}; break;
        case 'orc_hut_small': modelPath = 'models/buildings/orc_hut_small.glb'; fallbackSize={w:4,h:3.5,d:4}; break;
        case 'orc_tent': modelPath = 'models/buildings/orc_tent.glb'; fallbackSize={w:3.5,h:3,d:4}; break;
        case 'desert_tent': modelPath = 'models/buildings/desert_tent.glb'; fallbackSize={w:4,h:3,d:4.5}; break;
        case 'goblin_shack': modelPath = 'models/buildings/goblin_shack.glb'; fallbackSize={w:3,h:3,d:3.5}; break;
        case 'crude_tent': modelPath = 'models/buildings/crude_tent.glb'; fallbackSize={w:3,h:2.5,d:3.5}; break; // Para bandidos/campamentos

        // --- Ruinas ---
        case 'ruined_wall_section': modelPath = 'models/buildings/ruined_wall_section.glb'; fallbackSize={w:8,h:4,d:1.5}; break;
        case 'ruined_tower_fragment': modelPath = 'models/buildings/ruined_tower_fragment.glb'; fallbackSize={w:3,h:6,d:3}; break;
        case 'ruined_temple_large': modelPath = 'models/buildings/ruined_temple_large.glb'; fallbackSize={w:15,h:10,d:15}; break; // Necesita modelo
        case 'ruined_crypt': modelPath = 'models/buildings/ruined_crypt.glb'; fallbackSize={w:4,h:3,d:5}; break; // Necesita modelo
        case 'mausoleum_ruined': modelPath = 'models/buildings/mausoleum_ruined.glb'; fallbackSize={w:6,h:5,d:7}; break; // Necesita modelo
        case 'tower_ruined': modelPath = 'models/buildings/tower_ruined.glb'; fallbackSize={w:5,h:9,d:5}; break;

        // --- Otros (Estaciones Crafteo, Props Grandes) ---
        case 'anvil': modelPath = 'models/props/anvil.glb'; fallbackSize={w:0.8,h:0.6,d:0.4}; break; // Objeto
        case 'loom': modelPath = 'models/props/loom.glb'; fallbackSize={w:1.2,h:1.5,d:0.8}; break; // Objeto
        case 'bonfire': modelPath = 'models/props/bonfire.glb'; fallbackSize={w:1.5,h:1,d:1.5}; break; // Objeto
        case 'fountain': modelPath = 'models/props/fountain.glb'; fallbackSize={w:3,h:2,d:3}; break; // Objeto
        case 'totem_pole_large': modelPath = 'models/props/totem_pole_large.glb'; fallbackSize={w:0.8,h:5,d:0.8}; break; // Objeto
        case 'totem_pole_small': modelPath = 'models/props/totem_pole_small.glb'; fallbackSize={w:0.5,h:3,d:0.5}; break; // Objeto
        case 'planter_box_prop': modelPath = 'models/props/planter_box_prop.glb'; fallbackSize={w:0.5,h:3,d:0.5}; break; // Objeto
        case 'training_dummy': modelPath = 'models/props/training_dummy.glb'; fallbackSize={w:0.5,h:1.6,d:0.5}; break; // Objeto
        case 'training_dummy': modelPath = 'models/props/training_dummy.glb'; fallbackSize={w:0.5,h:1.6,d:0.5}; break; // Objeto
        case 'weapon_rack': modelPath = 'models/props/weapon_rack.glb'; fallbackSize={w:1.5,h:1.2,d:0.4}; break; // Objeto
        case 'crane_simple': modelPath = 'models/props/crane_simple.glb'; fallbackSize={w:2,h:5,d:4}; break; // Objeto
        case 'city_wall_section': modelPath = 'models/buildings/city_wall_section.glb'; fallbackSize={w:10,h:6,d:1.8}; break; // Muro ciudad genérico
        case 'city_gate_simple': modelPath = 'models/buildings/city_gate_simple.glb'; fallbackSize={w:6,h:7,d:3}; break; // Puerta ciudad genérica
        case 'mage_tower_modest': modelPath = 'models/buildings/mage_tower_modest.glb'; fallbackSize={w:6,h:10,d:6}; break;
        case 'academy_building': modelPath = 'models/buildings/academy_building.glb'; fallbackSize={w:12,h:9,d:15}; break; // Necesita modelo
        // --- Props que podrían considerarse 'edificios' si son grandes ---
        // case 'statue_scholar': modelPath = 'models/props/statue_scholar.glb'; break;

        default:
            console.warn(`Modelo no definido para buildingId: ${buildingId}. Usando placeholder.`);
            // O asignar un placeholder genérico:
             modelPath = 'models/buildings/placeholder_building.glb';
    }

    // --- Cargar Modelo o Crear Fallback ---
    try {
        let model;
        if (modelPath) {
            const gltf = await loadGLBModel(modelPath); // Esperar carga
            model = gltf.scene;
            model.name = `Building_${buildingId}`; // Asignar nombre basado en ID
            console.log(`  -> Modelo GLB cargado para ${buildingId}`);
        } else {
            // --- Crear Fallback Visual si no hay path o falló ---
            console.log(`  -> Creando fallback para ${buildingId}`);
            const fallbackGeom = new THREE.BoxGeometry(fallbackSize.w, fallbackSize.h, fallbackSize.d);
            const fallbackMat = new THREE.MeshStandardMaterial({ color: 0x888888, wireframe: true, name: `FallbackMat_${buildingId}` });
            const fallbackMesh = new THREE.Mesh(fallbackGeom, fallbackMat);
            fallbackMesh.name = `Fallback_${buildingId}`;
            // Centrar el fallback verticalmente
            fallbackMesh.position.y = fallbackSize.h / 2;
            model = fallbackMesh; // Usar el fallback como modelo
        }

        // --- Configuraciones Comunes (Sombras, UserData) ---
        model.traverse(child => {
            if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;
            }
        });

        // Calcular BBox y añadir a userData
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3();
        box.getSize(size);
        model.userData = {
            buildingType: buildingId, // Guardar el ID original
            width: size.x,
            depth: size.z,
            height: size.y,
            // Puedes añadir más datos específicos aquí si los necesitas
        };
        // console.log(`   -> UserData configurado para ${buildingId}: size=(${size.x.toFixed(1)}, ${size.y.toFixed(1)}, ${size.z.toFixed(1)})`);

        return model; // Devolver la escena cargada o el fallback

    } catch (error) {
        console.error(`Error fatal cargando/procesando modelo ${buildingId} (${modelPath || 'fallback'}):`, error);
        // Crear y devolver un fallback aún más simple en caso de error catastrófico
        const errorGeom = new THREE.BoxGeometry(2, 2, 2);
        const errorMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const errorMesh = new THREE.Mesh(errorGeom, errorMat);
        errorMesh.name = `ERROR_LOAD_${buildingId}`;
        errorMesh.position.y = 1;
        return errorMesh; // Devolver cubo rojo de error
    }
}

/**
 * Carga y configura de forma asíncrona un modelo 3D para un Punto de Interés (POI).
 * Usa un switch basado en visualDefId para determinar la ruta del modelo GLB.
 * Aplica sombras y userData básico. Incluye fallback visual.
 * (v1 - Async)
 * @param {string} visualDefId - El ID visual del POI (ej: 'wizard_tower_ruined', 'health_shrine_model').
 * @returns {Promise<THREE.Object3D | null>} Promesa que resuelve con el modelo o null/fallback.
 */
async function createPOIModel(visualDefId) {
    console.log(`[createPOIModel v1] Solicitado: ${visualDefId}`);
    let modelPath = null;
    let fallbackSize = { w: 3, h: 5, d: 3 }; // Tamaño fallback genérico

    // --- Mapeo de IDs Visuales a Rutas ---
    switch (visualDefId) {
        // Landmarks
        case "wizard_tower_ruined": modelPath = 'models/pois/wizard_tower_ruined.glb'; fallbackSize={w:6,h:12,d:6}; break;
        case "farmhouse_ruined":    modelPath = 'models/pois/farmhouse_ruined.glb'; fallbackSize={w:5,h:4,d:6}; break;
        case "elfic_tree_large":    modelPath = 'models/pois/elfic_tree_large.glb'; fallbackSize={w:4,h:10,d:4}; break;
        case "bandit_camp_props":   modelPath = 'models/pois/bandit_camp_props.glb'; fallbackSize={w:8,h:3,d:8}; break;
        case "orc_watchtower_model": modelPath = 'models/pois/orc_watchtower.glb'; fallbackSize={w:4,h:9,d:4}; break;
        case "lighthouse_model":    modelPath = 'models/pois/lighthouse.glb'; fallbackSize={w:5,h:15,d:5}; break;
        case "shipwreck_model":     modelPath = 'models/pois/shipwreck.glb'; fallbackSize={w:12,h:4,d:5}; break;
        case "standing_stones_model": modelPath = 'models/pois/standing_stones.glb'; fallbackSize={w:7,h:4,d:7}; break;
        case "giant_skeleton_bones": modelPath = 'models/pois/giant_skeleton.glb'; fallbackSize={w:10,h:3,d:4}; break;
        case "volcanic_vent_effect": modelPath = 'models/pois/volcanic_vent.glb'; fallbackSize={w:2,h:1,d:2}; break;
        case "stone_bridge_ruined": modelPath = 'models/pois/stone_bridge_ruined.glb'; fallbackSize={w:4,h:3,d:10}; break;
        case "oasis_model":         modelPath = 'models/pois/oasis.glb'; fallbackSize={w:10,h:5,d:10}; break;
        case "waterfall_with_cave": modelPath = 'models/pois/waterfall_with_cave.glb'; fallbackSize={w:5,h:8,d:4}; break;
        case "graveyard_small":     modelPath = 'models/pois/graveyard_small.glb'; fallbackSize={w:8,h:2,d:10}; break;

        // Shrines (Modelos base o específicos)
        case "shrine_health": case "shrine_mana": case "shrine_strength": case "shrine_wisdom": case "shrine_magic_res":
            modelPath = 'models/shrines/shrine_base.glb'; // Usar modelo base
            fallbackSize={w:1.2, h:2.5, d:1.2};
            break;
        case "shrine_ruined":
            modelPath = 'models/shrines/shrine_ruined.glb'; // Modelo específico ruinas
            fallbackSize={w:1.5, h:2, d:1.5};
            break;

        // Fallback genérico
        case "placeholder_landmark": case "placeholder_shrine":
             modelPath = 'models/pois/placeholder_landmark.glb'; fallbackSize={w:2,h:3,d:2}; break;
        default:
            console.warn(`Modelo POI no definido para visualDefId: ${visualDefId}. Usando placeholder.`);
            modelPath = null; // Forzar fallback si no coincide
    }

    try {
        let model;
        if (modelPath) {
            const gltf = await loadGLBModel(modelPath);
            model = gltf.scene;
            model.name = `POI_${visualDefId}`;
            console.log(`  -> Modelo GLB cargado para POI ${visualDefId}`);
        } else {
            // --- Crear Fallback Visual ---
            console.log(`  -> Creando fallback para POI ${visualDefId}`);
            const fallbackGeom = new THREE.BoxGeometry(fallbackSize.w, fallbackSize.h, fallbackSize.d);
            const fallbackMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, wireframe: true, name: `FallbackMat_${visualDefId}` });
            const fallbackMesh = new THREE.Mesh(fallbackGeom, fallbackMat);
            fallbackMesh.name = `Fallback_${visualDefId}`;
            // Centrar el fallback verticalmente (base en Y=0)
            fallbackMesh.position.y = fallbackSize.h / 2;
            model = fallbackMesh;
        }

        // --- Configuraciones Comunes ---
        model.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
        // Calcular BBox y añadir a userData
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3(); box.getSize(size);
        model.userData = {
            poiType: visualDefId, // Guardar el ID visual
            width: size.x, depth: size.z, height: size.y,
            // Marcar como 'landmark' o 'shrine' para lógica específica si es necesario
            type: visualDefId.includes('shrine') ? 'shrine' : 'landmark'
        };

        return model;

    } catch (error) {
        console.error(`Error fatal cargando/procesando POI ${visualDefId} (${modelPath || 'fallback'}):`, error);
        // Crear y devolver un fallback aún más simple en caso de error catastrófico
        const errorGeom = new THREE.BoxGeometry(1, 1, 1);
        const errorMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Verde error POI
        const errorMesh = new THREE.Mesh(errorGeom, errorMat);
        errorMesh.name = `ERROR_LOAD_POI_${visualDefId}`;
        errorMesh.position.y = 0.5;
        return errorMesh;
    }
}


    /**
     * NEW FUNCTION: Preloads all character preview models.
     * Call this during the initial game loading sequence.
     * @returns {Promise<void>}
     */
    async function preloadPreviewAssets() {
        const functionName = "preloadPreviewAssets";
        console.log(`[${functionName}] Starting preview model preloading...`);
        const previewModelPaths = {}; // Object to store paths { 'race_gender': 'path/to/model.glb' }

        // Populate previewModelPaths (adjust paths as needed)
        for (const raceId in raceDefinitions) {
            for (const gender of ['male', 'female']) {
                const key = `${raceId}_${gender}`;
                // Use the existing helper function to ensure consistent path generation
                try {
                     previewModelPaths[key] = getPlayerModelPath(raceId, gender);
                } catch (e) {
                     console.warn(`[${functionName}] Could not generate path for ${key}:`, e);
                }
            }
        }

        console.log(`[${functionName}] Found ${Object.keys(previewModelPaths).length} models to preload.`);

        const loadPromises = Object.entries(previewModelPaths).map(async ([key, path]) => {
            if (!path) {
                 console.warn(`[${functionName}] No path defined for key: ${key}, skipping.`);
                 return; // Skip if path is missing
            }
            try {
                // console.log(`[${functionName}]   Loading: ${key} from ${path}`); // DEBUG
                const gltf = await loadGLBModel(path); // Use existing loader
                if (gltf && gltf.scene) {
                    // Store the loaded scene (THREE.Group) in our cache
                    // Detach from original parent if necessary (though loadGLBModel usually returns detached)
                    if(gltf.scene.parent) gltf.scene.parent.remove(gltf.scene);
                    preloadedPreviewModels[key] = gltf.scene;
                    console.log(`[${functionName}]   SUCCESS: Preloaded ${key}`);
                } else {
                    console.warn(`[${functionName}]   WARNING: Loaded GLTF for ${key} is invalid or has no scene.`);
                    preloadedPreviewModels[key] = null; // Mark as failed/unavailable
                }
            } catch (error) {
                console.error(`[${functionName}]   ERROR preloading ${key} from ${path}:`, error);
                preloadedPreviewModels[key] = null; // Mark as failed
            }
        });

        await Promise.all(loadPromises); // Wait for all models to attempt loading
        isPreviewPreloadingComplete = true;
        console.log(`[${functionName}] Preview model preloading finished. ${Object.values(preloadedPreviewModels).filter(m => m).length} models loaded successfully.`);
    }
    /**
     * Crea un grupo de puestos de mercado simples.
     * @param {number} count - Número de puestos a crear.
     * @returns {THREE.Group}
     */
    function createMarketStallsGroup(count) {
        const mainGroup = new THREE.Group();
        const stallWidth = 3, stallHeight = 2.5, stallDepth = 2;
        const spacing = 4.0;

        for (let i = 0; i < count; i++) {
             const group = new THREE.Group();
             const woodColor = 0xcd853f; // Peru
             const clothColor = new THREE.Color(0xfffaf0).lerp(new THREE.Color(0xff0000), Math.random() * 0.6).getHex(); // Telas variadas
             const material = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.9 });
             const clothMat = new THREE.MeshStandardMaterial({ color: clothColor, side: THREE.DoubleSide, roughness: 0.8 });

             const stallBase = new THREE.Mesh(new THREE.BoxGeometry(stallWidth, 0.2, stallDepth), material);
             stallBase.position.y = 1.0; group.add(stallBase);
             const awningGeom = new THREE.PlaneGeometry(stallWidth*1.1, stallDepth*1.1);
             const awning = new THREE.Mesh(awningGeom, clothMat);
             awning.position.y = stallHeight; awning.rotation.x = -Math.PI/7; group.add(awning);
             const postGeom = new THREE.CylinderGeometry(0.1, 0.1, stallHeight, 4);
             const post1 = new THREE.Mesh(postGeom, material); post1.position.set(-stallWidth/2*0.8, stallHeight/2, -stallDepth/2*0.8); group.add(post1);
             const post2 = new THREE.Mesh(postGeom, material); post2.position.set(stallWidth/2*0.8, stallHeight/2, -stallDepth/2*0.8); group.add(post2);

             // Posicionar cada puesto relativo al grupo principal
             group.position.x = (i - (count - 1) / 2) * spacing;
             group.rotation.y = (Math.random() - 0.5) * 0.3; // Ligera variación
             group.traverse(c => { if(c.isMesh) { c.castShadow = true; c.receiveShadow = true; }});
             mainGroup.add(group);
        }
        mainGroup.userData = { buildingType: 'marketStalls', width: count * spacing, depth: stallDepth };
        return mainGroup;
    }


    /**
     * Crea un modelo 3D para una estación de crafteo.
     * @param {'forge' | 'workbench' | 'loom' | 'alchemy_pot'} stationType
     * @returns {THREE.Group | null}
     */
    function createCraftingStationModel(stationType) {
        const group = new THREE.Group();
        let mesh = null;
        let material;

        try { // Envolver en try-catch por si THREE no está listo
            switch(stationType) {
                case 'forge':
                    material = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6, metalness: 0.3 });
                    const forgeBase = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 1), material);
                    forgeBase.position.y = 0.4; group.add(forgeBase);
                    const anvilGeom = new THREE.BoxGeometry(0.8, 0.3, 0.4); // Yunque simple
                    const anvil = new THREE.Mesh(anvilGeom, new THREE.MeshStandardMaterial({color: 0x666677, metalness: 0.8, roughness: 0.4}));
                    anvil.position.y = 0.8 + 0.15; group.add(anvil);
                    mesh = group; break;
                case 'workbench':
                     material = new THREE.MeshStandardMaterial({ color: 0x9d7a5a, roughness: 0.8 });
                     const benchTop = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.15, 0.8), material); benchTop.position.y = 1.0; group.add(benchTop);
                     const legGeomW = new THREE.BoxGeometry(0.15, 1.0, 0.15);
                     const leg1W = new THREE.Mesh(legGeomW, material); leg1W.position.set(-0.8, 0.5, -0.3); group.add(leg1W);
                     const leg2W = new THREE.Mesh(legGeomW, material); leg2W.position.set( 0.8, 0.5, -0.3); group.add(leg2W);
                     const leg3W = new THREE.Mesh(legGeomW, material); leg3W.position.set(-0.8, 0.5, 0.3); group.add(leg3W);
                     const leg4W = new THREE.Mesh(legGeomW, material); leg4W.position.set( 0.8, 0.5, 0.3); group.add(leg4W);
                     mesh = group; break;
                case 'loom':
                     material = new THREE.MeshStandardMaterial({ color: 0xad9c8a, roughness: 0.8 });
                     const frameGeomL = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                     const frame1L = new THREE.Mesh(frameGeomL, material); frame1L.position.set(-0.5, 0.75, -0.5); group.add(frame1L);
                     const frame2L = new THREE.Mesh(frameGeomL, material); frame2L.position.set( 0.5, 0.75, -0.5); group.add(frame2L);
                     const frame3L = new THREE.Mesh(frameGeomL, material); frame3L.position.set(-0.5, 0.75, 0.5); group.add(frame3L);
                     const frame4L = new THREE.Mesh(frameGeomL, material); frame4L.position.set( 0.5, 0.75, 0.5); group.add(frame4L);
                     const topBarL = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 0.1), material); topBarL.position.set(0, 1.45, -0.5); group.add(topBarL);
                     const topBar2L = topBarL.clone(); topBar2L.position.z = 0.5; group.add(topBar2L);
                     mesh = group; break;
                case 'alchemy_pot':
                     material = new THREE.MeshStandardMaterial({ color: 0x607D8B, roughness: 0.7 });
                     const potGeom = new THREE.CylinderGeometry(0.4, 0.3, 0.6, 12);
                     const pot = new THREE.Mesh(potGeom, material); pot.position.y = 0.3; group.add(pot);
                     mesh = group; break;
                default: return null;
            }
            if (mesh) {
                 mesh.userData.type = 'crafting_station';
                 mesh.userData.stationType = stationType;
                 mesh.traverse(c=>{ if(c.isMesh) c.castShadow = true; }); // Activar sombras
            }
            return mesh;
        } catch (e) {
            console.error("Error creando modelo de estación de crafteo:", e);
            return null;
        }
    }


    //======================================================
    // FUNCTION: createTreeModel (COMPLETE - vTrunkColliderWorld)
    //======================================================
    function createTreeModel(options = { type: 'oak' }) {
        const group = new THREE.Group();
        group.name = `TreeGroup_${options.type}`;

        const trunkHeight = 2 + Math.random() * 1.5;
        const trunkRadius = 0.2 + Math.random() * 0.15;
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9, name: `TrunkMat_${options.type}` });
        const trunkGeom = new THREE.CylinderGeometry(trunkRadius * 0.8, trunkRadius, trunkHeight, 8);
        const trunk = new THREE.Mesh(trunkGeom, trunkMat);
        trunk.name = "TreeTrunk";
        trunk.position.y = trunkHeight / 2; // Base at group's y=0
        trunk.castShadow = true;
        group.add(trunk);

        // --- Leaves ---
        const leavesMat = new THREE.MeshStandardMaterial({ color: options.type === 'pine' ? 0x225522 : 0x338833, roughness: 0.8, name: `LeavesMat_${options.type}` });
        let leaves;
        if (options.type === 'pine') { /* ... pine leaves ... */ const coneHeight=trunkHeight*1.5; const coneRadius=trunkRadius*4; const leavesGeom=new THREE.ConeGeometry(coneRadius,coneHeight,8); leaves=new THREE.Mesh(leavesGeom,leavesMat); leaves.position.y = trunkHeight+coneHeight*0.4; }
        else { /* ... oak leaves ... */ const leavesSize=trunkHeight*0.8+Math.random()*0.5; const leavesGeom=new THREE.IcosahedronGeometry(leavesSize,1); leaves=new THREE.Mesh(leavesGeom,leavesMat); leaves.position.y=trunkHeight+leavesSize*0.3; }
        leaves.name = "TreeLeaves";
        leaves.castShadow = true;
        leaves.receiveShadow = false;
        group.add(leaves);

        // --- *** IMPORTANT: Bounding Box Calculation AFTER POSITIONING *** ---
        // The BBox calculation needs the tree's FINAL world position.
        // This will be set later in ChunkManager._instanceSingleObject.
        // So, we will store the trunk *reference* and calculate the Box3 later.
        group.userData = {
            type: 'scenery_tree',
            treeType: options.type,
            isResource: true, // Assuming all procedural trees are resources for now
            resourceDefId: 'wood_tree_common', // Link to resource def
            resourceType: 'wood',
            depleted: false,
            trunkRef: trunk, // <<< STORE TRUNK REFERENCE
            boundingBox: null, // <<< Initialize as null, will be calculated later
            colliderType: 'trunk'
            // id will be set in ChunkManager._instanceSingleObject if needed for state saving
        };
        // -----------------------------------------------------------------

        return group;
    }
    
    function createRockModel(options = { size: 1 }) {
        const mat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.85 });
        // Usar Dodecahedron o Icosahedron para variedad
        const geom = Math.random() > 0.5 ? new THREE.IcosahedronGeometry(options.size / 2, 0) : new THREE.DodecahedronGeometry(options.size / 2, 0);
        const pos = geom.attributes.position;
        // Deformación sutil para irregularidad
        for (let i = 0; i < pos.count; i++) {
            const noise = 1.0 + (Math.random() - 0.5) * 0.4; // +/- 20% de deformación
            pos.setXYZ(i, pos.getX(i) * noise, pos.getY(i) * noise, pos.getZ(i) * noise);
        }
        geom.computeVertexNormals();
        const rock = new THREE.Mesh(geom, mat);
        rock.castShadow = true; rock.receiveShadow = true;
        // La posición Y se ajusta en createWorldObjects para que la base toque el suelo
        return rock;
    }

    function createSimpleRuinModel(options) {
        const group = new THREE.Group();
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x777788, roughness: 0.9 });
        const wallThickness = 0.4;
        let currentAngle = options.baseRotationY || 0;
        group.position.copy(options.position || new THREE.Vector3(0,0,0)); // Posicionar grupo en la base Y
        for (let i = 0; i < options.wallCount; i++) {
            const wallLen = options.wallLength * (0.8 + Math.random() * 0.4);
            const wallH = options.wallHeight * (0.6 + Math.random() * 0.4);
            const wallGeom = new THREE.BoxGeometry(wallLen, wallH, wallThickness);
            const wall = new THREE.Mesh(wallGeom, wallMat);
            const radius = wallLen / 2 * (i > 0 ? 1.0 : 0.5); // Ajustar radio para conectar mejor
            // Posicionar pared relativa al centro del grupo, base en y=0
            wall.position.set(Math.sin(currentAngle) * radius, wallH / 2, Math.cos(currentAngle) * radius);
            wall.rotation.y = currentAngle;
            wall.castShadow = true; wall.receiveShadow = true;
            group.add(wall);
             // Opcional: Añadir arco si se especifica
             if (options.arch && Math.random() > 0.6) {
                 const archHeight = wallH * 0.6;
                 const archWidth = wallLen * 0.5;
                 // Simular un arco con un cilindro tumbado (muy simplificado)
                 const archGeom = new THREE.CylinderGeometry(archHeight/2, archHeight/2, wallThickness*1.1, 8, 1, false, 0, Math.PI);
                 archGeom.rotateX(Math.PI/2);
                 const arch = new THREE.Mesh(archGeom, wallMat);
                 arch.position.y = archHeight / 2; // Centrar arco en la pared
                 wall.add(arch); // Añadir como hijo de la pared
             }

            currentAngle += (Math.PI / 2) * (0.8 + Math.random() * 0.4); // Siguiente ángulo
        }
        return group;
    }

    function createShrineModel(effectType) {
         const group = new THREE.Group();
         const baseMat = new THREE.MeshStandardMaterial({color: 0xaaaaaa, roughness: 0.7});
         const crystalMat = new THREE.MeshStandardMaterial({
             color: effectType === 'heal_player_full' ? 0x00ff00 : (effectType === 'regen_mana_buff' ? 0x00aaff : 0xffff00),
             emissive: effectType === 'heal_player_full' ? 0x00cc00 : (effectType === 'regen_mana_buff' ? 0x0088ff : 0xccaa00),
             emissiveIntensity: 0.5, transparent: true, opacity: 0.8, roughness: 0.3
         });
         const baseGeom = new THREE.CylinderGeometry(0.6, 0.8, 0.4, 8);
         const base = new THREE.Mesh(baseGeom, baseMat);
         base.position.y = 0.2; group.add(base);
         const pillarGeom = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 6);
         const pillar = new THREE.Mesh(pillarGeom, baseMat);
         pillar.position.y = 0.4 + 0.6; group.add(pillar);
         const crystalGeom = new THREE.OctahedronGeometry(0.4, 0);
         const crystal = new THREE.Mesh(crystalGeom, crystalMat);
         crystal.position.y = 0.4 + 1.2 + 0.3; group.add(crystal);
         group.traverse(c=>{ if(c.isMesh) c.castShadow=true; });
         return group;
    }
    
    
    
/**
 * Crea el objeto interactuable para salir del dungeon actual.
 * Lo posiciona cerca del punto de entrada del jugador.
 * (v2 - Añade a world.objects)
 * @param {object} dungeonDef - La definición del dungeon actual.
 */
function createDungeonExitPoint(dungeonDef) {
    if (!dungeonDef || !dungeonDef.startPos || !world.dungeon) { /*...*/ return; }

    const offset = dungeonDef.exitPosOffset || { x: 0, z: -1.5 };
    const exitPosition = new THREE.Vector3(
        dungeonDef.startPos.x + offset.x,
        dungeonDef.startPos.y + 0.1, // Ligeramente sobre el suelo (Y=0)
        dungeonDef.startPos.z + offset.z
    );

    // Visual (Portal simple)
    const exitGeometry = new THREE.PlaneGeometry(1.2, 2.2);
    const exitMaterial = new THREE.MeshStandardMaterial({
        color: 0x66ccff, emissive: 0x3399dd, emissiveIntensity: 0.6,
        side: THREE.DoubleSide, transparent: true, opacity: 0.65
    });
    const exitMesh = new THREE.Mesh(exitGeometry, exitMaterial);
    exitMesh.position.copy(exitPosition);
    exitMesh.position.y += 1.1; // Centrar portal verticalmente
    // Orientar para que mire hacia el centro (aproximadamente)
    exitMesh.lookAt(new THREE.Vector3(dungeonDef.startPos.x, exitMesh.position.y, dungeonDef.startPos.z));
    exitMesh.name = `DungeonExit_${dungeonDef.id}`;

    exitMesh.userData = {
        type: 'dungeon_exit',
        name: `Salir a ${worldData.cities.find(c=>c.dungeons?.includes(dungeonDef.id))?.name || 'Superficie'}`, // Nombre más descriptivo
        interactable: true,
        interact: exitDungeon,
        dungeonId: dungeonDef.id, // <<< IMPORTANTE: Marcar como parte del dungeon
        boundingBox: new THREE.Box3().setFromObject(exitMesh) // <<< AÑADIR BBox
    };

    scene.add(exitMesh);
    world.interactables.push(exitMesh);
    world.objects.push(exitMesh); // <<< AÑADIR a world.objects para colisión

    console.log(`[Dungeon] Exit point created for ${dungeonDef.id}`);
}


/**
 * Carga y configura de forma asíncrona un modelo 3D para una Entrada de Dungeon.
 * Usa un switch basado en visualDefId para determinar la ruta del modelo GLB.
 * Aplica sombras y userData básico. Incluye fallback visual.
 * (NUEVA - Async)
 * @param {string} visualDefId - El ID visual de la entrada (ej: 'cave_entrance_dark', 'crypt_door_stone').
 * @returns {Promise<THREE.Object3D | null>} Promesa que resuelve con el modelo o null/fallback.
 */
async function createDungeonEntranceModel(visualDefId) {
    console.log(`[createDungeonEntranceModel] Solicitado: ${visualDefId}`);
    let modelPath = null;
    let fallbackSize = { w: 3, h: 4, d: 2 }; // Tamaño fallback genérico

    // --- Mapeo de IDs Visuales a Rutas ---
    switch (visualDefId) {
        case "cave_entrance_dark":      modelPath = 'models/dungeons/entrances/cave_dark.glb'; fallbackSize={w:4,h:3,d:2}; break;
        case "crypt_door_stone":      modelPath = 'models/dungeons/entrances/crypt_door.glb'; fallbackSize={w:2.5,h:3.5,d:1}; break;
        case "mountain_cave_large":   modelPath = 'models/dungeons/entrances/cave_mountain.glb'; fallbackSize={w:5,h:5,d:3}; break;
        case "cave_entrance_small":   modelPath = 'models/dungeons/entrances/cave_small.glb'; fallbackSize={w:2,h:2,d:1.5}; break;
        case "mine_entrance_wooden":  modelPath = 'models/dungeons/entrances/mine_entrance.glb'; fallbackSize={w:3,h:3.5,d:2}; break;
        case "ruined_archway":        modelPath = 'models/dungeons/entrances/ruined_arch.glb'; fallbackSize={w:4,h:5,d:1}; break;
        case "cave_entrance_reinforced":modelPath = 'models/dungeons/entrances/cave_reinforced.glb'; fallbackSize={w:4,h:3.5,d:2.5}; break;
        case "sewer_grate":           modelPath = 'models/dungeons/entrances/sewer_grate.glb'; fallbackSize={w:1.5,h:0.2,d:1.5}; break

        // Fallback genérico
        case "placeholder_dungeon_entrance":
             modelPath = 'models/dungeons/entrances/placeholder.glb'; fallbackSize={w:3,h:4,d:2}; break;
        default:
            console.warn(`Modelo Entrada Dungeon no definido para visualDefId: ${visualDefId}. Usando placeholder.`);
            modelPath = null; // Forzar fallback si no coincide
    }

    try {
        let model;
        if (modelPath) {
            const gltf = await loadGLBModel(modelPath);
            model = gltf.scene;
            model.name = `DungeonEntrance_${visualDefId}`;
            console.log(`  -> Modelo GLB cargado para Dungeon Entrance ${visualDefId}`);
        } else {
            console.log(`  -> Creando fallback para Dungeon Entrance ${visualDefId}`);
            const fallbackGeom = new THREE.BoxGeometry(fallbackSize.w, fallbackSize.h, fallbackSize.d);
            const fallbackMat = new THREE.MeshStandardMaterial({ color: 0x666677, wireframe: true, name: `FallbackMat_${visualDefId}` });
            const fallbackMesh = new THREE.Mesh(fallbackGeom, fallbackMat);
            fallbackMesh.name = `Fallback_${visualDefId}`;
            fallbackMesh.position.y = fallbackSize.h / 2;
            model = fallbackMesh;
        }

        // --- Configuraciones Comunes ---
        model.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
        const box = new THREE.Box3().setFromObject(model); const size = new THREE.Vector3(); box.getSize(size);
        model.userData = {
            entranceType: visualDefId, // Guardar ID visual
            width: size.x, depth: size.z, height: size.y,
            type: 'dungeon_entrance' // Asegurar tipo para lógica de interacción
        };

        return model;
    } catch (error) {
        console.error(`Error fatal cargando/procesando Entrada Dungeon ${visualDefId} (${modelPath || 'fallback'}):`, error);
        const errorGeom = new THREE.BoxGeometry(1, 1, 1); const errorMat = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // Magenta error dungeon
        const errorMesh = new THREE.Mesh(errorGeom, errorMat); errorMesh.name = `ERROR_LOAD_DUNGEON_${visualDefId}`; errorMesh.position.y = 0.5;
        return errorMesh;
    }
} 
    
    function createSimpleRuinPiece(subType = 'wall') {
         const mat = new THREE.MeshStandardMaterial({color: 0x777788, roughness: 0.9});
         let geom;
         if (subType === 'pillar') { geom = new THREE.CylinderGeometry(0.3, 0.3, 1.5 + Math.random(), 6); }
         else { geom = new THREE.BoxGeometry(1.5 + Math.random() * 2, 0.8 + Math.random() * 1.2, 0.4); }
         const piece = new THREE.Mesh(geom, mat);
         piece.position.y = (subType === 'pillar' ? (1.5 + Math.random()) / 2 : (0.8 + Math.random() * 1.2) / 2);
         piece.rotation.y = Math.random() * Math.PI * 2;
         piece.rotation.x = (Math.random() - 0.5) * 0.2;
         piece.rotation.z = (Math.random() - 0.5) * 0.2;
         piece.castShadow = true; piece.receiveShadow = true;
         return piece;
    }

/**
     * Crea y posiciona los enemigos en el mundo basados en las zonas de spawn definidas en worldData.
     * Carga modelos GLB, calcula offsets, aplica escala, configura animaciones, IA básica y loot.
     * Utiliza las definiciones de enemySpawns en worldData.
     * (v5 - Async, Spawn Zones, Rotation, Pivot/Height Offset, Scale)
     */
    async function createEnemies() {
        console.log("--- Iniciando createEnemies (v5 - Spawn Zones) ---");
        // Limpiar enemigos anteriores
        if (world.enemies && world.enemies.length > 0) {
            console.log(`Limpiando ${world.enemies.length} enemigos anteriores...`);
            world.enemies.forEach(enemy => {
                if (enemy.userData?.mixer) enemy.userData.mixer.stopAllAction();
                if (enemy.userData?.respawnTimeoutId) clearTimeout(enemy.userData.respawnTimeoutId);
                if (enemy.userData?.deathFinishListener && enemy.userData?.mixer) enemy.userData.mixer.removeEventListener('finished', enemy.userData.deathFinishListener);
                if (enemy.parent) scene.remove(enemy);
                // Remover de otras listas si es necesario (ej: world.objects)
                const worldObjectIndex = world.objects.indexOf(enemy); if(worldObjectIndex > -1) world.objects.splice(worldObjectIndex, 1);
            });
        }
        world.enemies = []; // Resetear array
        console.log("Enemigos anteriores limpiados.");

        // Iterar sobre las definiciones de spawn
        const spawnDefinitions = worldData.enemySpawns || [];
        console.log(`Procesando ${spawnDefinitions.length} definiciones de spawn...`);
        const loadPromises = [];

        spawnDefinitions.forEach(spawnDef => {
            const enemyType = spawnDef.type;
            const enemyDef = enemyDefinitions[enemyType];
            if (!enemyDef || !enemyDef.modelPath) {
                console.warn(`Definición o modelPath no encontrado para tipo enemigo '${enemyType}' en spawnDef. Saltando.`);
                return; // Saltar esta definición si falta el tipo o modelo
            }

            const count = spawnDef.count || 1;
            const center = spawnDef.center || { x: 0, z: 0 };
            const radius = spawnDef.radius || 10; // Radio de spawn
            const respawnTime = spawnDef.respawn || (enemyDef.isUnique ? UNIQUE_ENEMY_RESPAWN_TIME : ENEMY_RESPAWN_TIME);

            for (let i = 0; i < count; i++) {
                const enemyLoadPromise = new Promise(async (resolve) => {
                    try {
                        // a. Cargar Modelo
                        const gltf = await loadGLBModel(enemyDef.modelPath);
                        const loadedModel = gltf.scene;
                        const loadedAnimations = gltf.animations;

                        // b. Encontrar Posición Válida dentro del área de spawn
                        let x, z, terrainY, finalY; let positionFound = false; let attempts = 0; const maxAttemptsPos = 25;
                        while (!positionFound && attempts < maxAttemptsPos) {
                             attempts++;
                             const angle = Math.random() * Math.PI * 2;
                             const distance = Math.random() * radius;
                             x = center.x + Math.cos(angle) * distance;
                             z = center.z + Math.sin(angle) * distance;
                             terrainY = ChunkManager.getTerrainHeightAt(x, z);
                             const biome = getBiome(x,z); // Para evitar spawn en agua dentro del radio

                             if (terrainY >= WATER_LEVEL && biome !== 'water') {
                                 // Check simple para no spawnear muy pegados
                                 let tooClose = world.enemies.some(existingNpc => existingNpc.position.distanceToSquared(new THREE.Vector3(x,terrainY,z)) < 1.5*1.5);
                                 if (!tooClose) positionFound = true;
                             }
                        }
                        if (!positionFound) { resolve(null); return; } // No se pudo colocar en el área

                        // c. Calcular Offset Pivote y Y Final
                        const modelBox = new THREE.Box3().setFromObject(loadedModel);
                        const pivotOffsetY = -modelBox.min.y;
                        const definedHeightOffset = enemyHeightOffsets[enemyType];
                        const finalHeightOffset = (typeof definedHeightOffset === 'number') ? definedHeightOffset : pivotOffsetY;
                        finalY = terrainY + finalHeightOffset;

                        // d. Crear Grupo y Posicionar
                        const enemyGroup = new THREE.Group(); enemyGroup.name = `Enemy_${enemyType}_${i}`;
                        enemyGroup.position.set(x, finalY, z);
                        enemyGroup.rotation.y = Math.random() * Math.PI * 2; // Rotación inicial aleatoria

                        // e. Procesar Modelo Visual
                        loadedModel.name = "EnemyVisualModel"; loadedModel.rotation.y = -Math.PI / 2;
                        loadedModel.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
                        let scale = enemyDef.scaleMultiplier || 1.0; // Usar escala definida o default 1
                        loadedModel.scale.set(scale, scale, scale);
                        enemyGroup.add(loadedModel);

                        // f. Configurar Animaciones
                        let mixer = null; const animationClipsMap = {};
                        if (loadedAnimations?.length > 0) { mixer = new THREE.AnimationMixer(loadedModel); loadedAnimations.forEach(clip => { if(clip.name) animMap[c.name.toLowerCase()]=c;}); const idle = animMap['idle']||animMap['idle_base']||Object.values(animMap)[0]; if(idle)mixer.clipAction(idle).play(); }

                        // g. Configurar UserData Completo
                        enemyGroup.userData = {
                            type: 'enemy', enemyType: enemyType, name: enemyDef.name || enemyType,
                            health: enemyDef.health || 30, maxHealth: enemyDef.health || 30,
                            damage: enemyDef.damage || { min: 3, max: 6 },
                            attackCooldown: enemyDef.attackCooldown || 2000, attackRange: enemyDef.attackRange || 2.0,
                            xp: enemyDef.xp || 10, loot: enemyDef.loot || [], equipmentLoot: enemyDef.equipmentLoot || [],
                            equipmentLootChance: enemyDef.equipmentLootChance || 0.05, lootChance: enemyDef.lootChance || 0.3,
                            resistances: enemyDef.resist || {}, isDead: false, isProcessingDeath: false, isAggro: false,
                            lastAttackTime: 0, aiState: 'idle', wanderTarget: null, target: null,
                            spawnPosition: enemyGroup.position.clone(), // Guardar pos de spawn
                            maxWanderDistance: radius * 1.5, // Permitir alejarse un poco del radio
                            respawnTime: respawnTime, // Usar tiempo del spawnDef o isUnique
                            isUnique: enemyDef.isUnique || false,
                            heightOffset: finalHeightOffset, mixer: mixer, animations: animationClipsMap,
                            deathAnimationClips: findAnimationClips(loadedAnimations, ['Death', 'Die', 'Fall', 'death', 'die', 'fall']),
                            isKnockedBack: false, knockbackVelocity: new THREE.Vector3(),
                            abilities: enemyDef.abilities || [], lastAbilityTime: {},
                            hitRadius: enemyDef.hitRadius || 0.7,
                            detectionRange: enemyDef.detectionRange || 18, // Añadir rangos configurables
                            loseAggroRange: enemyDef.loseAggroRange || 30,
                            fleeHealthPercent: enemyDef.fleeHealthPercent, // Puede ser undefined
                            canFlee: enemyDef.canFlee !== false, // Puede huir por defecto
                        };
                        resolve(enemyGroup); // Éxito
                    } catch (error) { console.error(`Error procesando enemigo tipo '${enemyType}' desde ${enemyDef.modelPath}:`, error); resolve(null); }
                });
                loadPromises.push(enemyLoadPromise);
            } // fin for count
        }); // fin forEach spawnDefinitions

        // Esperar Cargas y Añadir
        console.log(`Esperando la carga de ${loadPromises.length} modelos de enemigos...`);
        const loadedEnemyResults = await Promise.all(loadPromises);
        console.log("Carga de modelos de enemigos completada.");
        let addedCount = 0;
        loadedEnemyResults.forEach(enemy => {
            if (enemy instanceof THREE.Group) { scene.add(enemy); world.enemies.push(enemy); world.objects.push(enemy); addedCount++; }
        });
        console.log(`--- Fin createEnemies(). ${addedCount} enemigos añadidos desde ${spawnDefinitions.length} definiciones de spawn. ---`);
    } // Fin createEnemies (v5)


    /**
     * Busca y devuelve clips de animación de un array por sus nombres (insensible a mayúsculas/minúsculas).
     * @param {THREE.AnimationClip[] | undefined | null} animationsArray - El array de animaciones donde buscar.
     * @param {string[]} namesToFind - Un array de nombres de animación a buscar (ej: ['Death', 'Die']).
     * @returns {THREE.AnimationClip[]} Un array con los clips encontrados. Devuelve array vacío si no encuentra nada o si la entrada es inválida.
     */
    function findAnimationClips(animationsArray, namesToFind) {
        const foundClips = [];
        // Validar entradas
        if (!Array.isArray(animationsArray) || animationsArray.length === 0 || !Array.isArray(namesToFind) || namesToFind.length === 0) {
            return foundClips; // Devolver array vacío si no hay animaciones o nombres a buscar
        }
        // Convertir nombres a buscar a minúsculas para comparación insensible
        const namesLower = namesToFind.map(name => name.toLowerCase());

        animationsArray.forEach(clip => {
            // Verificar que el clip y su nombre existan
            if (clip && clip.name && typeof clip.name === 'string') {
                // Comparar nombre del clip (en minúsculas) con la lista de nombres buscados
                if (namesLower.includes(clip.name.toLowerCase())) {
                    foundClips.push(clip); // Añadir clip si coincide
                }
            } else {
                // console.warn("Se encontró una animación inválida o sin nombre en el array."); // Opcional
            }
        });
        return foundClips; // Devolver array de clips encontrados (puede estar vacío)
    }

    // function createInteractables() { /* --- ELIMINADA --- */ } // Recursos/Cofres generados por ChunkManager

    /**
     * Crea un modelo 3D para un cofre interactuable.
     * Incluye una base y una tapa separada dentro de un grupo pivote para animación.
     * @returns {THREE.Group} El grupo que contiene el modelo del cofre.
     */
    function createChestModel() {
        const group = new THREE.Group();
        group.name = "Chest"; // Identificador

        // Materiales
        const woodColor = 0x966F33; // Marrón madera
        const metalColor = 0xaaaaaa; // Gris metálico
        const baseMat = new THREE.MeshStandardMaterial({ color: woodColor, roughness: 0.8, metalness: 0.1 });
        const metalMat = new THREE.MeshStandardMaterial({ color: metalColor, metalness: 0.7, roughness: 0.4 });

        // Dimensiones
        const width = 0.8, height = 0.5, depth = 0.5;
        const lidHeight = 0.15;
        const bandThickness = 0.05;

        // Base del cofre
        const baseGeom = new THREE.BoxGeometry(width, height - lidHeight, depth);
        const base = new THREE.Mesh(baseGeom, baseMat);
        base.position.y = (height - lidHeight) / 2; // Centrar la base verticalmente
        base.castShadow = true; base.receiveShadow = true;
        base.name = "chestBase";
        group.add(base);

        // Pivote para la tapa (en la bisagra trasera)
        const lidPivot = new THREE.Group();
        lidPivot.name = "lidPivot";
        lidPivot.position.set(0, height - lidHeight, -depth / 2); // Posicionar en la parte superior trasera de la base
        group.add(lidPivot);

        // Tapa del cofre
        const lidGeom = new THREE.BoxGeometry(width, lidHeight, depth);
        const lid = new THREE.Mesh(lidGeom, baseMat);
        lid.name = "lid";
        lid.position.set(0, lidHeight / 2, depth / 2); // Posicionar relativo al pivote para que gire correctamente
        lid.castShadow = true;
        lidPivot.add(lid); // Añadir tapa al grupo pivote

        // Bandas metálicas decorativas (opcional)
        const bandGeomH = new THREE.BoxGeometry(bandThickness, height - lidHeight + 0.01, bandThickness); // Bandas verticales
        const bandGeomV = new THREE.BoxGeometry(width + 0.01, bandThickness, bandThickness); // Bandas horizontales
        const bandGeomLid = new THREE.BoxGeometry(width + 0.01, bandThickness, bandThickness); // Bandas en la tapa

        // Bandas en la base
        const bandLeft = new THREE.Mesh(bandGeomH, metalMat); bandLeft.position.set(-width/2 + bandThickness/2, 0, 0); base.add(bandLeft);
        const bandRight = new THREE.Mesh(bandGeomH, metalMat); bandRight.position.set(width/2 - bandThickness/2, 0, 0); base.add(bandRight);
        const bandFront = new THREE.Mesh(bandGeomV, metalMat); bandFront.position.set(0, 0, depth/2 - bandThickness/2); base.add(bandFront);
        const bandBack = new THREE.Mesh(bandGeomV, metalMat); bandBack.position.set(0, 0, -depth/2 + bandThickness/2); base.add(bandBack);

        // Bandas en la tapa
        const bandLidFront = new THREE.Mesh(bandGeomLid, metalMat); bandLidFront.position.set(0, 0, depth/2 - bandThickness/2); lid.add(bandLidFront);
        const bandLidBack = new THREE.Mesh(bandGeomLid, metalMat); bandLidBack.position.set(0, 0, -depth/2 + bandThickness/2); lid.add(bandLidBack);

        // El grupo se posiciona con su base en y=0
        return group;
    }

    /**
     * Crea un modelo 3D para un nodo de recurso recolectable.
     * @param {'ore' | 'herb' | 'crystal' | 'wood'} resourceType - El tipo general de recurso.
     * @param {string} [defId=''] - El ID específico de la definición (ej: 'iron_vein').
     * @returns {THREE.Mesh | null} La malla del nodo de recurso o null si el tipo es desconocido.
     */
    function createResourceNodeModel(resourceType = 'ore', defId = '') {
        let geometry;
        let color = 0x888888; // Gris por defecto
        let emissiveColor = 0x000000;
        let emissiveIntensity = 0;
        let scale = 1.0;
        let yPosOffset = 0.2; // Offset base para que no esté enterrado

        // Determinar geometría y color base por TIPO
        switch(resourceType) {
            case 'ore':
                 geometry = new THREE.IcosahedronGeometry(0.3, 0); // Forma de roca/mena
                 color = 0x777777; break;
            case 'herb':
                 geometry = new THREE.ConeGeometry(0.2, 0.5, 6); // Forma de planta simple
                 color = 0x22aa22; yPosOffset = 0.25; break;
            case 'crystal':
                 geometry = new THREE.OctahedronGeometry(0.3, 0); // Forma de cristal
                 color = 0x88aaff; yPosOffset = 0.15; emissiveIntensity = 0.2; break;
             case 'wood': // Para árboles (no se crean nodos separados, se aplica a árboles)
                  console.warn("createResourceNodeModel no debe llamarse para 'wood'. Se aplica a árboles existentes.");
                  return null; // No crear malla separada para madera
            default:
                 geometry = new THREE.SphereGeometry(0.2, 8, 6); // Fallback
        }

        // Ajustar color/emisión basado en la DEFINICIÓN específica (si existe)
        const definition = resourceDefinitions[defId];
        if (definition) {
             if (defId.includes('iron')) color = 0x9d9d9d;
             else if (defId.includes('copper')) color = 0xb87333;
             else if (defId.includes('silver')) { color = 0xc0c0c0; emissiveColor=0xffffff; emissiveIntensity=0.1; }
             else if (defId.includes('gold')) { color = 0xffd700; emissiveColor=0xfff000; emissiveIntensity=0.2; }
             else if (defId.includes('healing_herb')) color = 0x33cc33;
             else if (defId.includes('mana_herb')) { color = 0x6666ff; emissiveColor=0x8888ff; emissiveIntensity=0.15; }
             else if (defId.includes('magic_crystal')) { color = 0xaaaaff; emissiveColor=0xccccff; emissiveIntensity=0.4; }
        }
        // Si no se estableció un color emisivo específico, usar el color base
        if (emissiveIntensity > 0 && emissiveColor === 0x000000) {
             emissiveColor = color;
        }

        const material = new THREE.MeshStandardMaterial({
             color: color,
             roughness: 0.7,
             metalness: defId.includes('ingot') ? 0.5 : 0.1, // Más metálico para lingotes
             emissive: emissiveColor,
             emissiveIntensity: emissiveIntensity
        });

        const nodeMesh = new THREE.Mesh(geometry, material);
        nodeMesh.castShadow = true; nodeMesh.receiveShadow = true;
        nodeMesh.position.y = yPosOffset; // Posicionar base sobre el suelo
        // Rotación aleatoria para variedad
        nodeMesh.rotation.set(Math.random() * Math.PI * 0.2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 0.2);
        nodeMesh.scale.setScalar(scale);
        nodeMesh.name = `ResourceNode_${defId || resourceType}`;

        // Adjuntar Bounding Box para colisiones si es necesario
        nodeMesh.geometry.computeBoundingBox();
        nodeMesh.userData = {
            boundingBox: nodeMesh.geometry.boundingBox.clone().applyMatrix4(nodeMesh.matrixWorld) // Caja inicial en coords mundo
        };


        return nodeMesh;
    }

    function setupWeatherSystem() {
        world.weatherSystem.particles = [];
        world.weatherSystem.setWeather = function(type, intensity = 0.5) {
            this.type = type; this.intensity = intensity; this.active = type !== 'clear';
            this.particles.forEach(p => scene.remove(p)); // Limpiar partículas 3D anteriores si se usan
            this.particles = [];
            AudioManager.stopWeatherSound(); // Detener sonido anterior

            if (this.active) {
                const particleCount = Math.floor(MAX_WEATHER_PARTICLES * intensity);
                for (let i = 0; i < particleCount; i++) {
                     this.particles.push(createWeatherParticle(type));
                     // Si usas partículas 3D, añadir a la escena aquí:
                     // scene.add(this.particles[i]);
                }
                AudioManager.playWeatherSound(type);
            }

            // Aplicar efectos globales de niebla/etc.
            gameState.weather = type; gameState.weatherIntensity = intensity;
            let targetFogNear = 100, targetFogFar = 300, targetFogColor = 0x10151b; // Valores por defecto (día claro)
            const sunAngle = (gameState.timeOfDay - 0.25) * Math.PI * 2;
            const sunHeight = Math.sin(sunAngle);
            const nightColor = new THREE.Color(0x050810);
            const dayColor = new THREE.Color(0x10151b);
            const lerpFactor = (Math.max(0, sunHeight) + 1) / 2;
            targetFogColor = new THREE.Color().lerpColors(nightColor, dayColor, lerpFactor).getHex();


            if (type === 'rain') {
                targetFogFar = 200 - 100 * intensity;
                targetFogNear = 50 - 30 * intensity;
                targetFogColor = new THREE.Color(targetFogColor).lerp(new THREE.Color(0x506070), 0.4).getHex(); // Tinte gris azulado
            } else if (type === 'snow') {
                targetFogFar = 150 - 80 * intensity;
                targetFogNear = 30 - 20 * intensity;
                targetFogColor = new THREE.Color(targetFogColor).lerp(new THREE.Color(0xddddff), 0.5).getHex(); // Tinte blanco frío
            }

            if (scene.fog instanceof THREE.Fog) {
                 scene.fog.near = targetFogNear;
                 scene.fog.far = targetFogFar;
                 scene.fog.color.setHex(targetFogColor);
            }
             // Podrían añadirse efectos en el jugador/entorno (ropa mojada, nieve acumulada simple)
        };
        world.weatherSystem.update = function(deltaTime) {
            if (!this.active || !playerModel) return;
            const playerPos = playerState.position; // Usar estado lógico
            const areaRadius = 50;
            this.particles.forEach(particle => {
                particle.position.y -= particle.speed * deltaTime;
                if (this.type === 'snow') {
                    particle.position.x += (Math.random() - 0.5) * 1.2 * deltaTime; // Más movimiento lateral nieve
                    particle.position.z += (Math.random() - 0.5) * 1.2 * deltaTime;
                }
                const terrainHeight = ChunkManager.getTerrainHeightAt(particle.position.x, particle.position.z);
                // Resetear si cae por debajo del terreno O se aleja mucho del jugador
                if (particle.position.y < terrainHeight || particle.position.distanceToSquared(playerPos) > (areaRadius + 20)**2) {
                    const angle = Math.random() * Math.PI * 2; const distance = Math.random() * areaRadius;
                    particle.position.x = playerPos.x + Math.cos(angle) * distance;
                    particle.position.z = playerPos.z + Math.sin(angle) * distance;
                    particle.position.y = playerPos.y + 25 + Math.random() * 15; // Resetear altura
                    // Resetear velocidad horizontal si es nieve?
                }
            });
        };
        world.weatherSystem.setWeather('clear', 0); // Empezar con clima despejado
        console.log("Sistema de clima configurado.");
    }

    function createWeatherParticle(type) {
        // Ahora devuelve un objeto simple con datos, el renderizado es 2D
        const playerPos = playerState.position; // Usar estado lógico
        const areaRadius = 50; const angle = Math.random() * Math.PI * 2; const distance = Math.random() * areaRadius;
        return {
            position: new THREE.Vector3( playerPos.x + Math.cos(angle) * distance, playerPos.y + 25 + Math.random() * 15, playerPos.z + Math.sin(angle) * distance ),
            speed: type === 'rain' ? (20 + Math.random() * 8) : (3.0 + Math.random() * 4.0),
            size: type === 'rain' ? (0.8 + Math.random() * 1.4) : (1.5 + Math.random() * 2.5),
            color: type === 'rain' ? `rgba(180, 190, 230, ${0.5 + Math.random() * 0.3})` : `rgba(240, 245, 255, ${0.6 + Math.random() * 0.3})`,
            alpha: type === 'rain' ? (0.5 + Math.random() * 0.3) : (0.6 + Math.random() * 0.3)
        };
    }

    function projectToScreen(position) {
        if (!camera) return null;
        const vector = position.clone().project(camera);
        const x = ((vector.x + 1) / 2) * window.innerWidth;
        const y = (-(vector.y - 1) / 2) * window.innerHeight;
        // Permitir un pequeño margen fuera de pantalla para partículas que entran/salen
        if (vector.z > 1 || x < -50 || x > window.innerWidth + 50 || y < -50 || y > window.innerHeight + 50) return null;
        return { x, y };
    }

    function setupInitialPlayerState() {
        console.log("--- setupInitialPlayerState (v2.6) ---");
        // Ya deberíamos tener playerState.race, playerState.gender, playerState.class
        // y playerState.attributes calculados por las funciones de selección

        // Resetear estado lógico base (mantener posición/rotación)
        playerState.velocity.set(0, 0, 0);
        playerState.onGround = true; playerState.isDodging = false; playerState.isInvulnerable = false;
        playerState.level = 1; playerState.xp = 0; playerState.xpToNextLevel = BASE_XP_REQ;
        playerState.gold = 25;
        playerState.attributePoints = 0;
        // Puntos de habilidad base + bonus trabajador
        playerState.skillPoints = SKILL_POINTS_PER_LEVEL + (playerState.class === 'worker' ? 1 : 0);
        playerState.statusEffects = []; gameState.isGhost = false;
        initializePlayerSkills(); // Configura skills base y resetea assignedPoints
        playerState.knownRecipes = ['spoon_craft', 'stone_bullet_craft'];
        playerState.equipment = {}; inventory.items = []; inventory.selectedItemIndex = null;
        playerState.actionSlots.fill(null);
        playerState.trackedQuestId = null;

        // Equipar items y spells iniciales según CLASE
        equipInitialItemsForClass(playerState.class);
        if (itemDefinitions.health_potion) addItemToInventory('health_potion', 5);
        if (itemDefinitions.mana_potion) addItemToInventory('mana_potion', 2);

        // Calcular stats DERIVADOS finales (basados en atributos ya calculados y equipo)
        updatePlayerStats();
        playerState.stats.health = playerState.stats.maxHealth;
        playerState.stats.mana = playerState.stats.maxMana;
        playerState.stats.stamina = playerState.stats.maxStamina;
        playerState.manaCostMultiplier = 1.0;

        // Sincronizar modelo 3D (debería existir y estar en la escena)
        if (playerModel instanceof THREE.Group) {
            const groundY = ChunkManager.getTerrainHeightAt(playerState.position.x, playerState.position.z);
            playerState.position.y = groundY + PLAYER_HALF_HEIGHT; // Asegurar Y correcta
            playerModel.position.copy(playerState.position);
            playerModel.rotation.y = playerState.rotationY;
            updatePlayerAppearance(); // Aplicar equipo visual inicial
            // Restaurar apariencia normal (si venía de carga/fantasma)
            const playerVisualModel = playerModel.getObjectByName("PlayerVisualModel");
  if (playerVisualModel) {
                 playerVisualModel.traverse(child => {
                      if (child.isMesh && child.material instanceof THREE.Material) {
                          // Restaurar propiedades guardadas o valores por defecto
                          const originalProps = child.userData?.originalMaterialProperties;
                          if (originalProps) {
                              child.material.color.setHex(originalProps.color); child.material.emissive.setHex(originalProps.emissive);
                              child.material.emissiveIntensity = originalProps.emissiveIntensity; child.material.opacity = originalProps.opacity;
                              child.material.transparent = originalProps.transparent; child.material.depthWrite = true;
                              delete child.userData.originalMaterialProperties; // Limpiar datos guardados
                          } else { // Fallback
                               child.material.opacity = 1.0; child.material.transparent = false; child.material.depthWrite = true;
                          }
                          delete child.material.clonedForDeathAnim; // Limpiar flags
                          delete child.material.clonedForDeathAnimFallback;
                      }
                 });
             }
             const healthBar = domCache['health-bar']; if (healthBar instanceof HTMLElement) healthBar.classList.remove('ghost-mode');
        } else { console.error("setupInitialPlayerState: playerModel no definido al finalizar."); }
        console.log("Estado inicial del jugador configurado con Raza/Clase.");
    }

    function equipInitialItemsForClass(charClass) {
        playerState.equipment = {}; // Limpiar equipo anterior
        let weaponId = 'unarmed'; let chestId = 'cloth_shirt'; let legsId = 'cloth_pants'; let spellId = null;

        // Asignar equipo base según la clase
        switch (charClass) {
            case 'warrior': weaponId = 'iron_sword'; chestId = 'leather_armor'; legsId = 'leather_pants'; break;
            case 'mage': weaponId = 'wizard_staff'; chestId = 'mage_robe'; legsId = 'mage_pants'; spellId = 'magic_arrow'; break;
            case 'paladin': weaponId = 'iron_mace'; chestId = 'chainmail_vest'; legsId = 'chainmail_leggings'; spellId = 'heal_light'; break;
            case 'hunter': weaponId = 'short_bow'; chestId = 'hunter_tunic'; legsId = 'hunter_leggings'; break;
            case 'assassin': weaponId = 'iron_dagger'; chestId = 'rogue_vest'; legsId = 'rogue_pants'; break;
            case 'worker': weaponId = 'wood_axe'; chestId = 'worker_shirt'; legsId = 'worker_trousers'; break;
        }

        // Intentar equipar cada pieza si la definición existe
        if (itemDefinitions[weaponId]) playerState.equipment.weapon = { ...itemDefinitions[weaponId], id: weaponId };
        if (itemDefinitions[chestId]) playerState.equipment.chest = { ...itemDefinitions[chestId], id: chestId };
        if (itemDefinitions[legsId]) playerState.equipment.legs = { ...itemDefinitions[legsId], id: legsId };
        // Añadir casco/botas base si se definen
        if (itemDefinitions['leather_boots']) playerState.equipment.feet = { ...itemDefinitions['leather_boots'], id: 'leather_boots' };
        if (itemDefinitions['leather_cap']) playerState.equipment.head = { ...itemDefinitions['leather_cap'], id: 'leather_cap' };

        // Asignar hechizo inicial si corresponde
        spells.known = [];
        if (spellId && spellDefinitions[spellId]) {
             spells.known = [{ ...spellDefinitions[spellId], id: spellId, cooldownRemaining: 0 }];
        }
         console.log(`Items iniciales para ${charClass}:`, playerState.equipment);
         console.log(`Hechizos iniciales para ${charClass}:`, spells.known);
    }

    function initializePlayerSkills() {
        playerState.skills = {};
        playerState.assignedSkillPoints = {}; // Guardar puntos asignados por separado
        Object.keys(skillDefinitions).forEach(skillId => {
            // Nivel inicial siempre 1, XP 0
            playerState.skills[skillId] = {
                 level: 1,
                 xp: 0,
                 xpToNext: calculateSkillXPForLevel(skillId, 2), // XP para nivel 2
                 assignedPoints: 0, // Puntos asignados a esta skill
                 // naturalPointsEarned: 0 // Ya no es necesario trackear natural vs asignado así
            };
            playerState.assignedSkillPoints[skillId] = 0; // Inicializar
        });
         // Dar skill inicial de apuñalar a asesino
         if (playerState.class === 'assassin' && playerState.skills.stab) {
             playerState.skills.stab.level = 10; // Empezar con nivel base
             playerState.skills.stab.xp = 0;
             playerState.skills.stab.xpToNext = calculateSkillXPForLevel('stab', 11);
         }
         console.log("Skills inicializadas:", playerState.skills);
    }

    function setupJoystickListeners() {
        if (!joystickManager) { return; }
        joystickManager.on('start', (evt, nipple) => { joystickActive = true; });
        joystickManager.on('move', (evt, data) => { if (data?.vector) { joystickVector.x = data.vector.x; joystickVector.y = data.vector.y; joystickMagnitude = data.force; } });
        joystickManager.on('end', (evt, nipple) => { joystickActive = false; joystickVector.x = 0; joystickVector.y = 0; joystickMagnitude = 0; });
        console.log("Listeners del Joystick configurados.");
    }

function setupUI() {
    console.log("Configurando UI y listeners (vVisualOptions)...");
    const inventoryGrid = domCache["inventory-grid"];
    if (inventoryGrid instanceof HTMLElement) {
         inventoryGrid.innerHTML = '';
         for (let i = 0; i < inventory.maxItems; i++) {
             const slot = document.createElement('div'); slot.className = 'inventory-slot'; slot.dataset.index = i.toString();
             slot.addEventListener('click', () => selectInventoryItem(i));
             slot.addEventListener('contextmenu', (e) => { e.preventDefault(); handleInventoryContextMenu(i, e); });
             inventoryGrid.appendChild(slot);
         }
    }

    domCache.tabButtons?.forEach(button => { if (button instanceof HTMLElement && button.dataset.tab) { const t=button.dataset.tab; button.addEventListener('click', ()=>switchTab(t)); } });
    if (domCache.tabButtons?.length > 0) switchTab('inventory');

    domCache.messageLogTabs?.forEach(tab => { if (tab instanceof HTMLElement && tab.dataset.filter) { if (tab.currentClickListener) tab.removeEventListener('click', tab.currentClickListener); const filter = tab.dataset.filter; tab.currentClickListener = () => setMessageLogFilter(filter); tab.addEventListener('click', tab.currentClickListener); } });

    const actionButtonsMap = { "equip-button": equipSelectedItem, "use-button": useOrCastSelectedItem, "drop-button": dropSelectedItem };
    for(const [id, fn] of Object.entries(actionButtonsMap)) { const b = domCache[id]; if (b instanceof HTMLButtonElement) b.addEventListener("click", fn); }

    const menuButtonsMap = { "new-game-button": showCharacterCreation, "continue-button": loadGame, "credits-button": openCreditsPanel, "manual-button": openManualPanel, "options-button-main": openOptionsMenu };
    for(const [id, fn] of Object.entries(menuButtonsMap)) { const b = domCache[id]; if (b instanceof HTMLElement) { if(b.currentClickListener) b.removeEventListener('click', b.currentClickListener); b.currentClickListener = fn; b.addEventListener("click", fn); } else { console.warn(`Botón de menú #${id} no encontrado.`); } }

    const mobileAttackBtn = domCache['mobile-attack-btn']; if (mobileAttackBtn) { mobileAttackBtn.addEventListener('touchstart', handleMobileAttackStart); mobileAttackBtn.addEventListener('touchend', handleMobileAttackEnd); mobileAttackBtn.addEventListener('touchcancel', handleMobileAttackEnd); }
    const mobileInteractBtn = domCache['mobile-interact-btn']; if (mobileInteractBtn) mobileInteractBtn.addEventListener('touchstart', handleMobileInteract);
    const mobileJumpBtn = domCache['mobile-jump-btn']; if (mobileJumpBtn) mobileJumpBtn.addEventListener('touchstart', handleMobileJump);
    const mobileSprintBtn = domCache['mobile-sprint-toggle-btn']; if (mobileSprintBtn) mobileSprintBtn.addEventListener('touchstart', handleMobileSprintToggle);
    const mobileSidebarToggleBtn = domCache['mobile-sidebar-toggle']; if (mobileSidebarToggleBtn) mobileSidebarToggleBtn.addEventListener('click', toggleMobileSidebar);
    const mobileCloseSidebarBtn = domCache['mobile-sidebar-close-btn']; if (mobileCloseSidebarBtn) mobileCloseSidebarBtn.addEventListener('click', handleMobileCloseSidebar);

    const joystickContainer = domCache['joystick-container'];
    if (joystickContainer && typeof nipplejs !== 'undefined') { try { const options = { zone: joystickContainer, mode: 'static', position: { left: '50%', top: '50%' }, color: 'rgba(255, 255, 255, 0.5)', size: 100, threshold: 0.1, fadeTime: 250, multitouch: false, maxNumberOfNipples: 1, dataOnly: false, restJoystick: true, shape: 'circle' }; joystickManager = nipplejs.create(options); setupJoystickListeners(); } catch(e) { console.error("Error inicializando nipplejs:", e); joystickManager = null; } } else if (typeof nipplejs === 'undefined') { console.warn("nipplejs no definido."); } else { console.warn("Contenedor joystick no encontrado."); }

    const closeButtonMap = { "close-char-sheet": toggleCharacterSheet, "close-shop": closeShop, "close-options-button": closeOptionsMenu, "options-close-confirm": closeOptionsMenu, "close-large-map-button": closeLargeMap, "close-equipment-modal": closeEquipmentModal, "close-crafting-modal": closeCraftingModal, "close-quests-modal": closeQuestsModal, "close-skills-modal": closeSkillsModal, "close-credits-button": closeCreditsPanel, "close-manual-button": closeManualPanel, "close-drop-panel-button": closeDropItemPanel, "quantity-prompt-close": hideDropQuantityPrompt };
    for(const [id, fn] of Object.entries(closeButtonMap)) { const b = domCache[id]; if (b instanceof HTMLElement) { if(b.currentClickListener) b.removeEventListener('click', b.currentClickListener); b.currentClickListener = fn; b.addEventListener("click", fn); } else { console.warn(`Botón de cierre #${id} no encontrado.`); } }

    const playerInfoDiv = domCache["player-info"]; if (playerInfoDiv instanceof HTMLElement) playerInfoDiv.addEventListener("click", toggleCharacterSheet);
    const minimapContainer = domCache['minimap-container']; if (minimapContainer instanceof HTMLElement) minimapContainer.addEventListener('click', openLargeMap);
    const sidebarMapButton = domCache['open-map-button-sidebar']; if (sidebarMapButton instanceof HTMLElement) sidebarMapButton.addEventListener('click', openLargeMap);
    const sidebarModalButtonMap = { "open-equipment-button": openEquipmentModal, "open-crafting-button": openCraftingModal, "open-quests-button": openQuestsModal, "open-skills-button": openSkillsModal, "open-character-sheet-button": toggleCharacterSheet };
    for(const [id, fn] of Object.entries(sidebarModalButtonMap)) { const b = domCache[id]; if (b instanceof HTMLButtonElement) b.addEventListener("click", fn); }
    const craftButton = domCache['modal-crafting-modal-craftButton'] || domCache['craft-button']; if (craftButton instanceof HTMLButtonElement) craftButton.addEventListener('click', craftSelectedItem);

    const setupSliderListener = (type, handler, minVal, maxVal, stepVal, storageKey, globalVarName, isPercentage = true) => {
        const slider = domCache[`option-${type}`]; const valueEl = domCache[`option-${type}-value`];
        if (slider instanceof HTMLInputElement && valueEl instanceof HTMLElement) {
             slider.min = minVal.toString(); slider.max = maxVal.toString(); slider.step = stepVal.toString();
             const listener = () => {
                 let numericValue = parseFloat(slider.value);
                 let displayValue = numericValue;
                 if(isPercentage) {
                     window[globalVarName] = numericValue / 100; // Guardar como factor
                     valueEl.textContent = `${Math.round(numericValue)}%`;
                 } else {
                     window[globalVarName] = numericValue; // Guardar valor directo
                     valueEl.textContent = numericValue.toString();
                 }
                 handler({ target: slider }); // Llama al handler específico
                 localStorage.setItem(storageKey, window[globalVarName].toString());
             };
             if (slider.currentListener) slider.removeEventListener('input', slider.currentListener);
             slider.addEventListener('input', listener); slider.currentListener = listener;
             // Inicializar valor del slider desde la variable global
             let initialSliderValue = isPercentage ? window[globalVarName] * 100 : window[globalVarName];
             slider.value = initialSliderValue.toString();
             // Actualizar texto inicial
             valueEl.textContent = isPercentage ? `${Math.round(initialSliderValue)}%` : initialSliderValue.toString();
        } else { console.warn(`Slider/Value para '${type}' no encontrado.`); }
    };
    // Volumen
    setupSliderListener('master', (e)=>AudioManager.setVolume('master', parseInt(e.target.value,10)/100), 0, 100, 1, 'volume_master', 'masterVolume');
    setupSliderListener('sfx', (e)=>AudioManager.setVolume('sfx', parseInt(e.target.value,10)/100), 0, 100, 1, 'volume_sfx', 'sfxVolume');
    setupSliderListener('music', (e)=>AudioManager.setVolume('music', parseInt(e.target.value,10)/100), 0, 100, 1, 'volume_music', 'musicVolume');
    setupSliderListener('weather', (e)=>AudioManager.setVolume('weather', parseInt(e.target.value,10)/100), 0, 100, 1, 'volume_weather', 'weatherVolume');
    // Visuales
    setupSliderListener('brightness', handleBrightnessChange, 50, 150, 5, 'option_brightness', 'gameBrightness');
    setupSliderListener('lighting-intensity', handleLightingIntensityChange, 0, 150, 5, 'option_lightingIntensity', 'lightingIntensityFactor');
    setupSliderListener('pixel-ratio', (e) => handlePixelRatioChange(parseInt(e.target.value,10)/100), 50, 150, 10, 'option_pixelRatio', 'renderPixelRatio');

    // Checkboxes
    const setupCheckboxListener = (type, handler, storageKey, globalVarName) => {
         const checkbox = domCache[`option-${type}`];
         if (checkbox instanceof HTMLInputElement) {
             const listener = () => { window[globalVarName] = checkbox.checked; handler({target: checkbox}); localStorage.setItem(storageKey, checkbox.checked.toString()); };
             if(checkbox.currentListener) checkbox.removeEventListener('change', checkbox.currentListener);
             checkbox.addEventListener('change', listener); checkbox.currentListener = listener;
             checkbox.checked = window[globalVarName]; // Set initial state
         } else { console.warn(`Checkbox para '${type}' no encontrado.`); }
    };
    setupCheckboxListener('show-fps', handleFPSToggle, 'option_showFPS', 'showFPS');
    setupCheckboxListener('weather-effects', handleWeatherEffectsToggle, 'option_weatherEffects', 'weatherEffectsEnabled');

    // Selects
    const setupSelectListener = (type, handler, storageKey, globalVarName) => {
         const select = domCache[`option-${type}`];
         if (select instanceof HTMLSelectElement) {
             const listener = () => { window[globalVarName] = select.value; handler({target: select}); localStorage.setItem(storageKey, select.value); };
             if(select.currentListener) select.removeEventListener('change', select.currentListener);
             select.addEventListener('change', listener); select.currentListener = listener;
             select.value = window[globalVarName]; // Set initial state
         } else { console.warn(`Select para '${type}' no encontrado.`); }
    };
    setupSelectListener('shadow-quality', handleShadowQualityChange, 'option_shadowQuality', 'shadowQuality');
    setupSelectListener('particle-limit', handleParticleLimitChange, 'option_particleLimit', 'particleLimit');


    if (document.body.globalClickListener) document.body.removeEventListener('click', document.body.globalClickListener);
    document.body.globalClickListener = (event) => { const t = event.target; if (t instanceof Element && !t.closest('#sidebar') && !t.closest('#mobile-ui-container') && !t.closest('.tooltip') && !t.closest('.modal-panel') && !t.closest('#options-panel') && !t.closest('#credits-panel') && !t.closest('#manual-panel')) { if (inventory.selectedItemIndex !== null) deselectInventoryItem(); if (spells.selectedSpellIndex !== null) deselectSpell(); } };
    document.body.addEventListener('click', document.body.globalClickListener);

    domCache.actionSlots?.forEach((slot, index) => { if (slot instanceof HTMLElement) slot.addEventListener('click', () => useActionSlot(index)); });

    domCache.manualTabButtons?.forEach(button => { if (button instanceof HTMLElement && button.dataset.manualTab) { const tabId = button.dataset.manualTab; button.addEventListener('click', () => switchManualTab(tabId)); } });
    if(domCache.manualTabButtons?.length > 0) { const firstTabId = domCache.manualTabButtons[0].dataset.manualTab; if(firstTabId) switchManualTab(firstTabId); }

    console.log("Configuración UI completa (con opciones visuales/performance).");
}
    
    function handleInventoryContextMenu(index, event) {
        if (index < 0 || index >= inventory.items.length) return;
        const item = inventory.items[index]; if (!item) return;
        const itemDef = itemDefinitions[item.id]; if(!itemDef) return;
        // Simplificado: Usar confirm para asignar a hotbar
        if (confirm(`Item: ${itemDef.name}\n\n[OK] = Equipar/Usar\n[Cancelar] = Asignar a Ranura 1?`)) {
            selectInventoryItem(index); useOrCastSelectedItem();
        } else {
             const assignData = { type: 'item', id: item.id, icon: itemDef.icon };
             assignToActionSlot(assignData, 0); // Asignar a slot 0
        }
    }


/**
     * Configura los listeners de eventos principales para teclado, ratón, redimensionado, etc.
     * (v3 - Limpieza y listener canvas directo)
     */
    function setupEventListeners() {
        console.log("Configurando listeners de eventos (v3 - Limpieza)...");

        // Limpiar listeners anteriores para evitar duplicados
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
        window.removeEventListener('mousemove', handleUIMouseMove);
        window.removeEventListener('mousedown', handleMouseDown);
        window.removeEventListener('resize', handleResize);
        document.removeEventListener('visibilitychange', handleVisibilityChange);

        // Listeners principales
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('mousemove', handleUIMouseMove);
        window.addEventListener('mousedown', handleMouseDown); // Listener global
        window.addEventListener('resize', handleResize);
        document.addEventListener('visibilitychange', handleVisibilityChange);

        const gameCanvas = domCache['game-canvas'];
        if (gameCanvas instanceof HTMLElement) {
            // Limpiar listeners específicos del canvas antes de añadir
            if (gameCanvas.currentContextMenuListener) gameCanvas.removeEventListener('contextmenu', gameCanvas.currentContextMenuListener);
            if (gameCanvas.currentMouseDownListener) gameCanvas.removeEventListener('mousedown', gameCanvas.currentMouseDownListener);

            // Añadir listeners específicos del canvas
            gameCanvas.currentContextMenuListener = (e) => e.preventDefault();
            gameCanvas.addEventListener('contextmenu', gameCanvas.currentContextMenuListener);

            gameCanvas.currentMouseDownListener = handleMouseDown; // Guardar referencia
            gameCanvas.addEventListener('mousedown', gameCanvas.currentMouseDownListener);
             console.log("   -> Listener 'mousedown' añadido directamente al canvas.");
        } else {
            console.error("setupEventListeners: #game-canvas no encontrado o no es HTMLElement.");
        }

        const startButton = domCache["start-game"];
        if (startButton instanceof HTMLButtonElement) {
             if (startButton.currentClickListener) startButton.removeEventListener('click', startButton.currentClickListener);
             startButton.currentClickListener = createCharacter;
             startButton.addEventListener("click", createCharacter);
        } else { console.warn("setupEventListeners: Botón #start-game no encontrado."); }

        // Listeners Creación Personaje
        domCache.raceOptions?.forEach(option => {
             if (option instanceof HTMLElement) {
                 if (option.currentClickListener) option.removeEventListener('click', option.currentClickListener);
                 option.currentClickListener = () => selectRace(option);
                 option.addEventListener('click', option.currentClickListener);
             }
        });
        domCache.classOptions?.forEach(option => {
             if (option instanceof HTMLElement) {
                 if (option.currentClickListener) option.removeEventListener('click', option.currentClickListener);
                 option.currentClickListener = () => selectClass(option);
                 option.addEventListener('click', option.currentClickListener);
             }
        });
        domCache.genderRadios?.forEach(radio => {
             if (radio instanceof HTMLInputElement) {
                 if (radio.currentChangeListener) radio.removeEventListener('change', radio.currentChangeListener);
                 radio.currentChangeListener = () => selectGender(radio);
                 radio.addEventListener('change', radio.currentChangeListener);
             }
        });

        console.log("Listeners de eventos configurados completamente (v3).");
    } // Fin setupEventListeners (v3)

    /**
     * Actualiza la animación (flotación, rotación) de los items en el suelo.
     * Itera sobre world.items y llama a la función userData.update si existe.
     * @param {number} deltaTime - El tiempo transcurrido desde el último frame.
     */
    function updateWorldItemsAnimation(deltaTime) {
        // Iterar sobre la lista de items en el suelo
        world.items.forEach(itemObject => {
            // Verificar que el objeto y sus datos/función de update existan
            if (itemObject && itemObject.userData && typeof itemObject.userData.update === 'function') {
                try {
                    // Llamar a la función de update específica del item, pasando deltaTime
                    itemObject.userData.update(deltaTime);
                } catch (error) {
                    // Loguear error si la función de update falla
                    console.error(`Error actualizando animación para item ${itemObject.name || itemObject.uuid}:`, error);
                    // Opcional: Eliminar la función de update si causa errores persistentemente para evitar spam
                    // delete itemObject.userData.update;
                }
            }
        });
    }
    
function selectRace(selectedOptionEl) {
    if (!selectedOptionEl?.dataset?.race) return;
    const raceId = selectedOptionEl.dataset.race;

    // 1. Actualizar UI: Quitar 'selected' de todos, añadir al clickeado
    domCache.raceOptions?.forEach(option => option.classList.remove('selected'));
    selectedOptionEl.classList.add('selected');

    // 2. Actualizar Estado Interno
    playerState.race = raceId;

    // 3. Recalcular y Mostrar Atributos
    updateCharacterCreationAttributes();

    // 4. === AÑADIR ESTA LÍNEA ===
    updateCharacterPreviewModel(); // Llama a la función que carga/actualiza el preview

    // 5. Sonido (Opcional)
    AudioManager.playSound('ui_confirm', 0.3);
}

/**
 * Maneja la selección de una clase.
 * @param {HTMLElement} selectedOptionEl - El elemento .class-option clickeado.
 */
function selectClass(selectedOptionEl) {
    if (!selectedOptionEl?.dataset?.class) return;
    const classId = selectedOptionEl.dataset.class;

    // 1. Actualizar UI
    domCache.classOptions?.forEach(option => option.classList.remove('selected'));
    selectedOptionEl.classList.add('selected');

    // 2. Actualizar Estado
    playerState.class = classId;

    // 3. Recalcular y Mostrar Atributos
    updateCharacterCreationAttributes(); // <-- ¡MUY IMPORTANTE!

    // 4. Sonido
    AudioManager.playSound('ui_confirm', 0.3);
}

/**
 * Maneja la selección de género.
 * @param {HTMLInputElement} selectedRadio - El input radio que cambió.
 */
function selectGender(selectedRadio) {
    if (!selectedRadio || !selectedRadio.checked) return;

    // 1. Actualizar Estado (la UI se actualiza sola por CSS :checked)
    playerState.gender = selectedRadio.value;

    // 2. Recalcular y Mostrar Atributos
    updateCharacterCreationAttributes();

    // 3. === AÑADIR ESTA LÍNEA ===
    updateCharacterPreviewModel(); // Llama a la función que carga/actualiza el preview

    // 4. Sonido
    AudioManager.playSound('ui_confirm', 0.3);
}


/**
 * Updates the character preview model using PRELOADED assets.
 * Cleans up the previous model, clones the requested preloaded model,
 * positions/scales it, and starts its idle animation.
 * Handles cases where the preloaded model might be missing.
 * (v2 - Preloading & Vertical Fix)
 */
async function updateCharacterPreviewModel() {
    const functionName = "updateCharacterPreviewModel (v2 - Preload)";
    console.log(`[${functionName}] Updating preview for ${playerState.race}_${playerState.gender}`);

    // --- 1. Validate Preview Environment ---
    if (!previewScene || !previewRenderer || !previewCamera) {
        console.error(`[${functionName}] Preview environment not ready.`);
        const previewContainer = domCache['char-preview-model'];
        if (previewContainer instanceof HTMLElement) {
            previewContainer.innerHTML = `<p style="color: red;">Preview no inicializado.</p>`;
        }
        return;
    }

    const previewContainer = domCache['char-preview-model'];
    if (!(previewContainer instanceof HTMLElement)) {
        console.error(`[${functionName}] Preview container not found.`);
        return;
    }

    // --- 2. *SYNCHRONOUS* Cleanup of Previous Model ---
    const modelIdentifier = "PreviewCharacterModel"; // Consistent name
    const existingModel = previewScene.getObjectByName(modelIdentifier);

    if (existingModel) {
        console.log(`[${functionName}] Removing previous model: ${existingModel.name}`);
        if (previewMixer) {
            try { previewMixer.stopAllAction(); } catch(e) {}
            previewMixer = null;
        }
        previewScene.remove(existingModel);
        // Optional: Dispose geometry/materials if clones are heavily modified (less critical now)
        // existingModel.traverse(child => { /* ... dispose ... */ });
        console.log(`[${functionName}] Previous model removed.`);
    }
    // Clear any previous error messages
    const errorMsgElement = previewContainer.querySelector('p.preview-error-message');
    if (errorMsgElement) errorMsgElement.remove();
    // Ensure canvas is present
    if (previewRenderer && !previewContainer.contains(previewRenderer.domElement)) {
        previewContainer.appendChild(previewRenderer.domElement);
    }

    // --- 3. Get Preloaded Model ---
    if (!isPreviewPreloadingComplete) {
         console.warn(`[${functionName}] Preview models not yet preloaded. Waiting might be needed.`);
         previewContainer.innerHTML = `<p class="preview-error-message" style="color: orange;">Cargando Avatares...</p>`;
         // Optionally, wait or queue the update
         // setTimeout(() => updateCharacterPreviewModel(), 500); // Simple retry
         return;
    }

    const modelKey = `${playerState.race}_${playerState.gender}`;
    const preloadedModelTemplate = preloadedPreviewModels[modelKey];

    // --- 4. Handle Missing Preloaded Model ---
    if (!preloadedModelTemplate) {
        console.error(`[${functionName}] FAILED: Preloaded model for key '${modelKey}' not found in cache.`);
        previewContainer.innerHTML = `<p class="preview-error-message" style="color: red;">Error: Modelo no cargado<br>(${modelKey})</p>`;
        if (previewRenderer?.domElement?.parentNode === previewContainer) {
            previewContainer.removeChild(previewRenderer.domElement); // Hide canvas on error
        }
        return;
    }

    // --- 5. Clone and Configure the Model Instance ---
    let modelInstance;
    try {
        console.log(`[${functionName}] Cloning preloaded model for ${modelKey}`);
        modelInstance = preloadedModelTemplate.clone(); // *** CLONE IT ***
        modelInstance.name = modelIdentifier; // Assign name to the clone

        // a. Apply Scale
        const previewScaleFactor = 1.5; // Adjust as needed
        modelInstance.scale.set(previewScaleFactor, previewScaleFactor, previewScaleFactor);

        // b. Center and Adjust Vertical Position (CRUCIAL FIX)
        modelInstance.updateMatrixWorld(true); // Ensure world matrix is up-to-date for bbox
        const box = new THREE.Box3().setFromObject(modelInstance);
        const center = box.getCenter(new THREE.Vector3());
        const verticalOffsetToBase = -box.min.y; // Amount to shift up so base is at Y=0

        // Apply centering horizontally/depth-wise, and adjust Y to place base at origin
        modelInstance.position.set(-center.x, verticalOffsetToBase, -center.z);

        // c. Apply Initial Rotation
        modelInstance.rotation.y = Math.PI * 0.15; // Slight turn

        // d. Setup Animation Mixer for the CLONE
        if (preloadedModelTemplate.animations && preloadedModelTemplate.animations.length > 0) {
            previewMixer = new THREE.AnimationMixer(modelInstance); // Mixer for the clone
            const animationsMap = {};
            preloadedModelTemplate.animations.forEach(clip => { if(clip.name) animationsMap[clip.name.toLowerCase()] = clip; });
            const idleClip = animationsMap['idle'] || animationsMap['idle_base'] || Object.values(animationsMap)[0];
            if (idleClip) {
                previewMixer.clipAction(idleClip).play();
                console.log(`[${functionName}] Idle animation started for clone.`);
            } else {
                previewMixer = null;
            }
        } else {
            previewMixer = null;
        }

        // e. Add the CLONE to the Preview Scene
        previewScene.add(modelInstance);
        console.log(`[${functionName}] Cloned model instance added to previewScene.`);

    } catch (cloneOrSetupError) {
        console.error(`[${functionName}] Error cloning or setting up model instance for ${modelKey}:`, cloneOrSetupError);
        previewContainer.innerHTML = `<p class="preview-error-message" style="color: red;">Error al preparar<br>vista previa.</p>`;
        if (previewRenderer?.domElement?.parentNode === previewContainer) {
            previewContainer.removeChild(previewRenderer.domElement);
        }
        return;
    }

    console.log(`[${functionName}] Preview update finished successfully for ${modelKey}.`);
}

/**
 * Calcula y actualiza los atributos base mostrados en la pantalla de creación.
 * (DEBES TENER ESTA FUNCIÓN O UNA SIMILAR EN TU CÓDIGO)
 */
function updateCharacterCreationAttributes() {
    const listElement = domCache['char-creation-attributes-list'];
    if (!(listElement instanceof HTMLElement)) {
        console.error("Elemento #char-creation-attributes-list no encontrado.");
        return;
    }

    const selectedRaceId = playerState.race || 'human';
    const selectedClassId = playerState.class || 'warrior'; // Asegurar un valor por defecto

    const raceDef = raceDefinitions[selectedRaceId];
    const classDef = classBaseAttributes[selectedClassId]; // Usar la tabla de atributos base de clase

    if (!raceDef || !classDef) {
        console.error(`Definición inválida para raza '${selectedRaceId}' o clase '${selectedClassId}'.`);
        listElement.innerHTML = '<li>Error al calcular atributos.</li>'; // Mostrar error
        return;
    }

    // Calcular atributos combinados
    const finalAttributes = {};
    for (const attrKey in classDef) {
        finalAttributes[attrKey] = (classDef[attrKey] || BASE_STAT) + (raceDef.modifiers[attrKey] || 0);
    }

    // Actualizar el playerState AHORA (importante para cuando se cree el personaje)
    playerState.attributes = finalAttributes;

    // Actualizar la lista en la UI
    let htmlContent = '';
    for (const attrKey in finalAttributes) {
        const attrName = getAttributeName(attrKey); // Usa tu función helper
        const attrValue = finalAttributes[attrKey];
        htmlContent += `<li>${attrName}: <span>${attrValue}</span></li>`;
    }
    listElement.innerHTML = htmlContent;

     // console.log(`Atributos actualizados para ${selectedRaceId}/${selectedClassId}:`, finalAttributes); // DEBUG
}
    
/**
 * Construye la ruta al modelo GLB del jugador basado en raza y género.
 * Añade logs para depuración y maneja valores por defecto.
 * @param {string} race - ID de la raza (ej: 'human', 'dark_elf').
 * @param {string} gender - 'male' o 'female'.
 * @returns {string} - La ruta completa al archivo .glb esperado.
 */
function getPlayerModelPath(race, gender) {
    // Valores por defecto seguros si algo falla
    const safeRace = (race || 'human').toLowerCase().replace(/\s+/g, '_');
    const safeGender = (gender || 'female').toLowerCase(); // O 'male' si prefieres ese default

    // --- Log para verificar qué valores recibe ---
    console.log(`[getPlayerModelPath] Recibido: race='${race}', gender='${gender}' -> Usando: safeRace='${safeRace}', safeGender='${safeGender}'`);

    // Construir la ruta
    const path = `models/characters/${safeRace}_${safeGender}.glb`;

    // --- Log para verificar la ruta generada ---
    console.log(`[getPlayerModelPath] Path generado: ${path}`);

    return path;
}  
     function handleUIMouseMove(event) {
        // Actualizar posición normalizada del ratón (usada por raycaster si es necesario)
         mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
         mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

         // Actualizar posición del tooltip si está activo
         // <<< CORRECCIÓN AQUÍ: Llamar a positionTooltip >>>
         if (gameState.activeTooltip) {
            positionTooltip(gameState.activeTooltip, event); // Usar el nombre correcto de la función
         }
         // updateTooltipPosition(event); // Eliminar esta línea incorrecta
     }

    function handleResize() {
        if (!camera || !renderer) return; const width = window.innerWidth; const height = window.innerHeight;
        renderer.setSize(width, height); camera.aspect = width / height; camera.updateProjectionMatrix();
        const pCanvas = domCache['particle-canvas']; if (pCanvas instanceof HTMLCanvasElement) { pCanvas.width = width; pCanvas.height = height; }
    }

    function handleVisibilityChange() { if (document.hidden && gameState.isPlaying && !gameState.isPaused) pauseGame(); }

    //===================================================
    // FUNCTION: handleFPSToggle (COMPLETE - vDisplay Check)
    //===================================================
    /** Handles toggling the FPS counter visibility */
    function handleFPSToggle(event) {
        // *** Check if statsMonitor exists before trying to use it ***
        if (!statsMonitor) {
             console.warn("FPS Monitor (stats.js) no está inicializado. Cannot toggle visibility.");
             // Optionally disable the checkbox if the monitor failed to init
             if (event.target instanceof HTMLInputElement) {
                 event.target.checked = false; // Uncheck it
                 event.target.disabled = true; // Disable it
                 event.target.title = "Stats.js no pudo inicializarse."; // Add tooltip
             }
             return; // Stop here
        }
        // ---------------------------------------------------------

        const checkbox = event.target;
        if (checkbox instanceof HTMLInputElement) {
            showFPS = checkbox.checked; // Update the global flag
            // *** This line controls visibility ***
            statsMonitor.dom.style.display = showFPS ? 'block' : 'none';
            // ***------------------------------***
            localStorage.setItem('option_showFPS', showFPS.toString()); // Save preference
            console.log("FPS Counter visibility set to:", showFPS);
        }
    }
    //=============================================================
    // FUNCTION: handleShadowQualityChange (COMPLETE - vEnableFlag)
    //=============================================================
    /** Handles changing the shadow quality */
    function handleShadowQualityChange(event) {
        const select = event.target;
        if (!(select instanceof HTMLSelectElement) || !renderer) return; // Added check for renderer

        shadowQuality = select.value; // Update global variable
        localStorage.setItem('option_shadowQuality', shadowQuality); // Save preference
        console.log("Shadow Quality changed to:", shadowQuality);

        let newMapSize = 0;
        let enableShadows = true; // Flag to control renderer.shadowMap.enabled

        switch (shadowQuality) {
            case 'high': newMapSize = 2048; break;
            case 'medium': newMapSize = 1024; break;
            case 'low': newMapSize = 512; break;
            case 'off':
                enableShadows = false; // <<< SET FLAG TO FALSE FOR 'off'
                newMapSize = 0; // Size 0 isn't standard, use flag instead
                break;
            default: // Fallback to medium
                shadowQuality = 'medium';
                select.value = 'medium'; // Update select element if invalid value somehow selected
                newMapSize = 1024;
                break;
        }

        // --- Apply to Renderer FIRST ---
        // Enable/Disable shadows globally on the renderer
        if (renderer.shadowMap.enabled !== enableShadows) {
            renderer.shadowMap.enabled = enableShadows;
            // When changing enabled state, materials often need updates
             scene.traverse(child => { if (child.material) child.material.needsUpdate = true; });
            console.log(`Renderer shadowMap ${enableShadows ? 'ENABLED' : 'DISABLED'}`);
        }

        // --- Apply to Lights (Only if shadows are enabled) ---
        scene.traverse((object) => {
            if (object.isDirectionalLight) { // Apply to main sun/moon lights
                if (enableShadows) {
                    // Only update map size if it actually changed
                    if (object.shadow.mapSize.width !== newMapSize) {
                        object.castShadow = true; // Ensure light casts shadow
                        object.shadow.map?.dispose(); // Dispose old map if exists
                        object.shadow.map = null;
                        object.shadow.mapSize.width = newMapSize;
                        object.shadow.mapSize.height = newMapSize;
                        console.log(`   -> Shadow map size set to ${newMapSize} for light ${object.uuid}`);
                        object.shadow.needsUpdate = true; // May help ensure update
                    }
                } else {
                    // Explicitly disable casting shadows on the light itself
                    if (object.castShadow) {
                         object.castShadow = false;
                         console.log(`   -> Disabled castShadow for light ${object.uuid}`);
                    }
                }
            }
            // Optionally disable castShadow on all other scene objects when shadows are off
             else if (object.isMesh && !enableShadows && object.castShadow) {
                 // object.castShadow = false; // You could do this, but just disabling on the light/renderer is usually enough
             } else if (object.isMesh && enableShadows && !object.castShadow && object.userData?.shouldCastShadowByDefault){
                 // Re-enable shadows for objects that should cast them (if you track this)
                 // object.castShadow = true;
             }
        });

        // Optional: Mark the renderer's shadow map for update (might not be strictly necessary)
        // if(renderer.shadowMap) renderer.shadowMap.needsUpdate = true;
    }
    
        function handleParticleLimitChange(event) {
        const select = event.target;
        if (!(select instanceof HTMLSelectElement)) return;

        particleLimit = parseInt(select.value, 10);
        if (isNaN(particleLimit)) particleLimit = 1200; // Fallback
        localStorage.setItem('option_particleLimit', particleLimit.toString()); // Save preference
        console.log("Particle Limit changed to:", particleLimit);

        // You might need to prune existing particles if the limit is lowered
        if (world.particles.length > particleLimit) {
            world.particles.splice(particleLimit); // Remove excess particles
        }
        if (world.weatherSystem?.particles.length > particleLimit) {
             world.weatherSystem.particles.splice(particleLimit);
        }
        // Note: MAX_PARTICLES might need to become a dynamic variable instead of const
        // For simplicity now, we just cap rendering/creation based on `particleLimit`
    }

    /** Handles toggling weather effects */
    function handleWeatherEffectsToggle(event) {
        const checkbox = event.target;
        if (checkbox instanceof HTMLInputElement) {
            weatherEffectsEnabled = checkbox.checked;
            localStorage.setItem('option_weatherEffects', weatherEffectsEnabled.toString()); // Save
            console.log("Weather Effects Enabled:", weatherEffectsEnabled);

            if (!weatherEffectsEnabled && world.weatherSystem?.active) {
                world.weatherSystem.setWeather('clear'); // Turn off weather if disabled
            }
            // The renderWeatherParticles function should check `weatherEffectsEnabled`
        }
    }
    
         /** Handles changing the pixel ratio */
     function handlePixelRatioChange(newRatio) {
         if (typeof newRatio !== 'number' || isNaN(newRatio)) return;
         renderPixelRatio = Math.max(0.5, Math.min(1.5, newRatio)); // Clamp between 50% and 150%
         localStorage.setItem('option_pixelRatio', renderPixelRatio.toString()); // Save
         console.log("Pixel Ratio changed to:", renderPixelRatio);
         if(renderer) {
             renderer.setPixelRatio(Math.min(window.devicePixelRatio, renderPixelRatio * window.devicePixelRatio)); // Apply adjusted ratio
              // Consider resizing renderer if needed, though usually not required just for pixel ratio
              // handleResize();
         }
     }

    /**
     * NEW FUNCTION: Preloads all character preview models.
     * Call this during the initial game loading sequence.
     * @returns {Promise<void>}
     */
    async function preloadPreviewAssets() {
        const functionName = "preloadPreviewAssets";
        console.log(`[${functionName}] Starting preview model preloading...`);
        const previewModelPaths = {}; // Object to store paths { 'race_gender': 'path/to/model.glb' }

        // Populate previewModelPaths (adjust paths as needed)
        for (const raceId in raceDefinitions) {
            for (const gender of ['male', 'female']) {
                const key = `${raceId}_${gender}`;
                // Use the existing helper function to ensure consistent path generation
                try {
                     previewModelPaths[key] = getPlayerModelPath(raceId, gender);
                } catch (e) {
                     console.warn(`[${functionName}] Could not generate path for ${key}:`, e);
                }
            }
        }

        console.log(`[${functionName}] Found ${Object.keys(previewModelPaths).length} models to preload.`);

        const loadPromises = Object.entries(previewModelPaths).map(async ([key, path]) => {
            if (!path) {
                 console.warn(`[${functionName}] No path defined for key: ${key}, skipping.`);
                 return; // Skip if path is missing
            }
            try {
                // console.log(`[${functionName}]   Loading: ${key} from ${path}`); // DEBUG
                const gltf = await loadGLBModel(path); // Use existing loader
                if (gltf && gltf.scene) {
                    // Store the loaded scene (THREE.Group) in our cache
                    // Detach from original parent if necessary (though loadGLBModel usually returns detached)
                    if(gltf.scene.parent) gltf.scene.parent.remove(gltf.scene);
                    preloadedPreviewModels[key] = gltf.scene;
                    console.log(`[${functionName}]   SUCCESS: Preloaded ${key}`);
                } else {
                    console.warn(`[${functionName}]   WARNING: Loaded GLTF for ${key} is invalid or has no scene.`);
                    preloadedPreviewModels[key] = null; // Mark as failed/unavailable
                }
            } catch (error) {
                console.error(`[${functionName}]   ERROR preloading ${key} from ${path}:`, error);
                preloadedPreviewModels[key] = null; // Mark as failed
            }
        });

        await Promise.all(loadPromises); // Wait for all models to attempt loading
        isPreviewPreloadingComplete = true;
        console.log(`[${functionName}] Preview model preloading finished. ${Object.values(preloadedPreviewModels).filter(m => m).length} models loaded successfully.`);
    }


function loadPerformanceOptions() {
    console.log("Loading performance and visual options...");
    showFPS = localStorage.getItem('option_showFPS') === 'true';
    shadowQuality = localStorage.getItem('option_shadowQuality') || 'medium';
    particleLimit = parseInt(localStorage.getItem('option_particleLimit') || '1200', 10);
    weatherEffectsEnabled = localStorage.getItem('option_weatherEffects') !== 'false';
    renderPixelRatio = parseFloat(localStorage.getItem('option_pixelRatio') || '1.0');
    gameBrightness = parseFloat(localStorage.getItem('option_brightness') || '1.0');
    lightingIntensityFactor = parseFloat(localStorage.getItem('option_lightingIntensity') || '1.0');

    gameBrightness = Math.max(0.5, Math.min(1.5, gameBrightness));
    lightingIntensityFactor = Math.max(0.0, Math.min(1.5, lightingIntensityFactor));

    if (statsMonitor) statsMonitor.dom.style.display = showFPS ? 'block' : 'none';
    const fpsCheck = domCache['option-show-fps']; if(fpsCheck instanceof HTMLInputElement) fpsCheck.checked = showFPS;
    const shadowSelect = domCache['option-shadow-quality']; if (shadowSelect instanceof HTMLSelectElement) { shadowSelect.value = shadowQuality; }
    const particleSelect = domCache['option-particle-limit']; if(particleSelect instanceof HTMLSelectElement) { particleSelect.value = particleLimit.toString(); }
    const weatherCheck = domCache['option-weather-effects']; if (weatherCheck instanceof HTMLInputElement) { weatherCheck.checked = weatherEffectsEnabled; }
    const ratioSlider = domCache['option-pixel-ratio']; if(ratioSlider instanceof HTMLInputElement) { ratioSlider.value = (renderPixelRatio * 100).toString(); updateVisualSliderValueText('pixel-ratio'); }
    const brightnessSlider = domCache['option-brightness']; if (brightnessSlider instanceof HTMLInputElement) { brightnessSlider.value = (gameBrightness * 100).toString(); updateVisualSliderValueText('brightness'); }
    const lightingSlider = domCache['option-lighting-intensity']; if (lightingSlider instanceof HTMLInputElement) { lightingSlider.value = (lightingIntensityFactor * 100).toString(); updateVisualSliderValueText('lighting-intensity'); }

    // Aplicar inmediatamente al renderer si ya existe
    if (renderer) {
        renderer.shadowMap.enabled = shadowQuality !== 'off';
        const mapSize = shadowQuality === 'high' ? 2048 : (shadowQuality === 'medium' ? 1024 : (shadowQuality === 'low' ? 512 : 0));
        if(renderer.shadowMap.enabled) { scene.traverse(obj => {if(obj.isDirectionalLight && obj.castShadow){ obj.shadow.mapSize.width = mapSize; obj.shadow.mapSize.height = mapSize;}}); }
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, renderPixelRatio * window.devicePixelRatio));
        renderer.toneMappingExposure = gameBrightness;
    }
    applyLightingIntensityFactor(); // Aplicar factor de iluminación

    console.log("Performance/visual options loaded:", { showFPS, shadowQuality, particleLimit, weatherEffectsEnabled, renderPixelRatio, gameBrightness, lightingIntensityFactor });
}
    
    
    function handleKeyDown(event) {
        // 1. Ignorar input si el foco está en un campo de texto
        if (event.target instanceof HTMLInputElement && (event.target.type === 'text' || event.target.type === 'number')) {
            return;
        }
        // 2. Ignorar si el texto del diálogo se está escribiendo
        if (gameState.isTyping) {
            return;
        }

        // 3. Manejar Teclas de UI Universales (Escape siempre funciona)
        if (event.code === 'Escape') {
            handleEscapeKey();
            return;
        }

        // --- Bloque Restringido: Acciones si NO se está jugando normal O ES FANTASMA ---
        if (!gameState.isPlaying || gameState.isPaused || gameState.isGhost) {
            // ... (lógica existente para resetear flags y manejar UI en pausa/fantasma) ...
             // Permitir ciertas teclas de UI incluso en estos estados
             switch (event.code) {
                 case 'KeyB': if (!gameState.isGhost) openEquipmentModal(); return;
                 case 'KeyC': if (!gameState.isGhost) toggleCharacterSheet(); return;
                 case 'KeyJ': openQuestsModal(); return;
                 case 'KeyK': if (!gameState.isGhost) openSkillsModal(); return;
                 case 'KeyN': if (!gameState.isGhost) openCraftingModal(); return;
                 case 'KeyM': openLargeMap(); return;
                 case 'Digit1': case 'Digit2': case 'Digit3': case 'Digit4': return; // No usar hotbar
             }
             // Permitir Input de Movimiento/Interacción como Fantasma
             if (gameState.isGhost && !gameState.isPaused) {
                 let processedGhostKey = false;
                 switch (event.code) {
                     case 'KeyW': case 'ArrowUp':    controls.moveForward = true; processedGhostKey = true; break;
                     case 'KeyS': case 'ArrowDown':  controls.moveBackward = true; processedGhostKey = true; break;
                     case 'KeyA': case 'ArrowLeft':  controls.turnLeft = true; processedGhostKey = true; break;
                     case 'KeyD': case 'ArrowRight': controls.turnRight = true; processedGhostKey = true; break;
                     case 'ShiftLeft':               controls.sprint = true; processedGhostKey = true; break;
                     case 'KeyE':
                         controls.interact = true; // Marcar interacción fantasma
                         checkGhostInteractions(); // Intentar interactuar con sacerdote
                         controls.interact = false; // Consumir flag inmediatamente para fantasma
                         processedGhostKey = true;
                         break;
                 }
                 if (processedGhostKey) return;
             }
             return; // Salir si no es estado de juego normal
        }
        // --- FIN Bloque Restringido ---


        // --- Acciones de Juego Normales (Solo si isPlaying, !isPaused, !isGhost) ---

        // 4. Manejo Tecla 'Z' (Ataque / Carga / Apuntar Arco)
        if (event.code === 'KeyZ') {
            // ... (lógica existente para ataque/carga/arco) ...
             if (playerState.isAttacking || playerState.isChargingAttack || playerState.isBlocking || gameState.isAimingWithBow || controls.isAttackKeyDown || playerState.isDodging) return;
             controls.isAttackKeyDown = true;
             const weapon = playerState.equipment.weapon; const weaponDef = weapon ? itemDefinitions[weapon.id] : null;
             if (weaponDef && weaponDef.weaponType === 'bow') { enterAimingMode(); }
             else { playerState.isChargingAttack = true; playerState.chargeAttackStartTime = Date.now(); }
            return;
        }

        // 5. Manejo Teclas de Movimiento y Otras Acciones
        switch (event.code) {
            case 'KeyW': case 'ArrowUp':    controls.moveForward = true; break;
            case 'KeyS': case 'ArrowDown':  controls.moveBackward = true; break;
            case 'KeyA': case 'ArrowLeft':  controls.turnLeft = true; break;
            case 'KeyD': case 'ArrowRight': controls.turnRight = true; break;
            case 'ShiftLeft':               controls.sprint = true; break;
            case 'Space': if (!playerState.isJumping && playerState.onGround && !playerState.isChargingAttack && !playerState.isBlocking && !playerState.isDodging) { controls.jump = true; } break;
            case 'KeyX': if (!playerState.isDodging && !playerState.isAttacking && !playerState.isChargingAttack) { controls.block = true; } break;
            case 'AltLeft': case 'AltRight': if (!playerState.isDodging && playerState.onGround && !playerState.isBlocking && !playerState.isChargingAttack && !playerState.isAttacking) { if (playerState.stats.stamina >= DODGE_STAMINA_COST) { controls.dodge = true; } else { logMessage("No tienes suficiente resistencia para esquivar.", "warning"); AudioManager.playSound('ui_error', 0.4); } } else if (!playerState.onGround) { logMessage("No puedes esquivar en el aire.", "info"); } break;
            case 'Digit1': useActionSlot(0); break; case 'Digit2': useActionSlot(1); break; case 'Digit3': useActionSlot(2); break; case 'Digit4': useActionSlot(3); break;

            // --- LÓGICA MEJORADA PARA 'E' ---
            case 'KeyE':
                controls.interact = true; // Marcar que se presionó 'E'

                // 1. Intentar interactuar con el objetivo MIRADO (resultado de checkInteractions)
                let interactedWithTarget = false;
                const currentTarget = gameState.targetEntity;
                if (currentTarget?.userData?.interactable) {
                    // Validar distancia al target MIRADO antes de interactuar
                    if (currentTarget.position.distanceToSquared(playerState.position) < INTERACT_DISTANCE_SQ * 1.1) { // Añadir pequeño margen
                        if (typeof currentTarget.userData.interact === 'function') {
                            console.log(`Interactuando con target (mirado): ${currentTarget.userData.name || currentTarget.userData.type}`); // DEBUG
                            currentTarget.userData.interact(); // Llama a la función interact (ej: openDialog, pickupItem, etc.)
                            interactedWithTarget = true;
                        }
                    } else {
                        logMessage("Demasiado lejos para interactuar.", "warning");
                        // No marcar interactedWithTarget = true si está fuera de rango
                    }
                }

                // 2. Si NO se interactuó con el target mirado, buscar items CERCANOS
                if (!interactedWithTarget) {
                    console.log("No interaction with looked-at target, checking nearby items..."); // DEBUG
                    let pickedUpNearbyItem = false;
                    // Copiar array para evitar problemas si pickupItem lo modifica
                    const nearbyItems = [...world.items];
                    for (const itemObject of nearbyItems) {
                        if (itemObject?.userData?.type === 'item_pickup' && itemObject.position) {
                             // Calcular distancia HORIZONTAL al cuadrado
                             const dx = itemObject.position.x - playerState.position.x;
                             const dz = itemObject.position.z - playerState.position.z;
                             const distSqXZ = dx * dx + dz * dz;

                             // Comprobar si está dentro del radio de recogida "bajo los pies"
                             if (distSqXZ < PICKUP_UNDERFOOT_RADIUS_SQ) {
                                 console.log(`Found nearby item: ${itemObject.userData.itemDef?.name}, attempting pickup...`); // DEBUG
                                 // *** LLAMAR A pickupItem PASANDO EL OBJETO DIRECTAMENTE ***
                                 pickupItem(itemObject);
                                 pickedUpNearbyItem = true; // Marcar que se intentó recoger
                                 break; // Detener búsqueda después de encontrar el primero cercano
                             }
                        }
                    }
                    // Si no se recogió nada cercano, limpiar flag de interacción
                    if (!pickedUpNearbyItem) {
                        controls.interact = false;
                    }
                } else {
                    // Si se interactuó con el target mirado, consumir el flag
                    controls.interact = false;
                }
                break; // Fin case 'KeyE'
                // --- FIN LÓGICA MEJORADA 'E' ---
        }
    } // Fin handleKeyDown
    
    function handleKeyUp(event) {
         // Resetear controles de movimiento independientemente del estado (fantasma o no)
         switch (event.code) {
             case 'KeyW': case 'ArrowUp': controls.moveForward = false; break;
             case 'KeyS': case 'ArrowDown': controls.moveBackward = false; break;
             case 'KeyA': case 'ArrowLeft': controls.turnLeft = false; break;
             case 'KeyD': case 'ArrowRight': controls.turnRight = false; break;
             case 'ShiftLeft': controls.sprint = false; break; // Desactivar sprint al soltar
             case 'KeyE': controls.interact = false; break; // Resetear flag de interactuar
             // Resetear otros si es necesario (salto, bloqueo)
             case 'Space': controls.jump = false; break;
             case 'KeyX': controls.block = false; break;
             case 'AltLeft': case 'AltRight': controls.dodge = false; break;
         }

         // --- Liberar Tecla Z (Solo si se está jugando normal) ---
         if (event.code === 'KeyZ' && gameState.isPlaying && !gameState.isPaused && !gameState.isGhost) {
             if (controls.isAttackKeyDown) {
                 controls.isAttackKeyDown = false;
                 const weaponDef = itemDefinitions[playerState.equipment.weapon?.id];
                 const isBowEquipped = weaponDef?.weaponType === 'bow';
                 if (!isBowEquipped && playerState.isChargingAttack) {
                     const chargeDuration = Date.now() - playerState.chargeAttackStartTime;
                     executeMeleeAttack(chargeDuration); // Ejecutar al soltar
                     playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0;
                 } else if (gameState.isAimingWithBow) {
                      // No hacer nada al soltar Z si apunta con arco
                 }
             }
             return; // Salir después de manejar Z
         }
    }
    
    
   /**
     * Maneja los eventos de clic del ratón.
     * (v4 - Lógica targeting primero, logs mejorados)
     * @param {MouseEvent} event - El objeto del evento del ratón.
     */
    function handleMouseDown(event) {
        // <<<--- LOG INICIAL: Se ejecuta esta función al hacer clic? ---<<<
        console.log(`[[[ DEBUG handleMouseDown START ]]] Button: ${event.button}, Target: ${event.target.id || event.target.tagName}, Targeting Spell: ${gameState.isTargetingSpell}, IsPlaying: ${gameState.isPlaying}, IsPaused: ${gameState.isPaused}`);

        // 1. --- Validaciones Iniciales ---
        if (!gameState.isPlaying || gameState.isPaused) {
            console.log("[DEBUG] handleMouseDown - Exiting: Not playing or paused.");
            return;
        }
        // Solo clic izquierdo (0) o derecho (2)
        if (event.button !== 0 && event.button !== 2) {
            console.log("[DEBUG] handleMouseDown - Exiting: Not left or right button.");
            return;
        }
        // Ignorar clics en UI
        const uiSelectors = '#sidebar, #mobile-ui-container, .modal-panel, #options-panel, #credits-panel, #manual-panel';
        if (event.target instanceof Element && event.target.closest(uiSelectors)) {
            console.log("[DEBUG] handleMouseDown - Exiting: Clicked on UI element.");
            return;
        }

        const isTargetingSpell = gameState.isTargetingSpell;
        const isAimingBow = gameState.isAimingWithBow;
        const clickedOnCanvas = event.target instanceof HTMLCanvasElement && event.target.id === 'game-canvas';

        console.log(`[DEBUG] handleMouseDown - State: isTargetingSpell=${isTargetingSpell}, isAimingBow=${isAimingBow}, clickedOnCanvas=${clickedOnCanvas}`);

        // --- Lógica de Apuntado (Prioridad Alta) ---
        if (isTargetingSpell) {
            // Clic Derecho O Izquierdo fuera del Canvas: Cancelar
            if (event.button === 2 || (event.button === 0 && !clickedOnCanvas)) {
                event.preventDefault();
                console.log("[DEBUG] handleMouseDown - Cancelling SPELL targeting (Right click or Left outside canvas).");
                exitSpellTargetingMode();
                return;
            }
            // Clic Izquierdo DENTRO del Canvas: Procesar Hechizo
            else if (event.button === 0 && clickedOnCanvas) {
                event.preventDefault();
                const spellDef = gameState.spellBeingTargeted;
                if (!spellDef) {
                    console.error("[DEBUG] handleMouseDown - Targeting spell but spellDef is missing!");
                    exitSpellTargetingMode(); return;
                }
                console.log(`[DEBUG] handleMouseDown - Targeting spell ${spellDef.id}, calling processSpellTargeting...`);
                processSpellTargeting(event, spellDef);
                return; // Acción de hechizo manejada
            }
        }
        // --- Fin Lógica Apuntado Hechizo ---

        // --- Lógica Apuntado Arco ---
        else if (isAimingBow) {
            // Clic Derecho O Izquierdo fuera del Canvas: Cancelar
            if (event.button === 2 || (event.button === 0 && !clickedOnCanvas)) {
                event.preventDefault();
                console.log("[DEBUG] handleMouseDown - Cancelling BOW aiming (Right click or Left outside canvas).");
                cancelAiming();
                return;
            }
            // Clic Izquierdo DENTRO del Canvas: Procesar Arco
            else if (event.button === 0 && clickedOnCanvas) {
                event.preventDefault();
                console.log("[DEBUG] handleMouseDown - Processing bow targeting...");
                processBowTargeting(event);
                return; // Acción de arco manejada
            }
        }
        // --- Fin Lógica Apuntado Arco ---

        // --- Clic Normal (Sin Apuntar) ---
        else if (event.button === 0 && clickedOnCanvas) {
            console.log("[DEBUG] handleMouseDown - Normal left click on canvas (no targeting active).");
            // Aquí iría tu lógica para ataque melee si lo inicias con clic,
            // o interacciones con el mundo si no usas 'E'.
            // Por ahora, no hace nada específico si no está apuntando.
        }
        else {
             // Otros casos (clic derecho en canvas sin apuntar, clic fuera sin apuntar)
             console.log(`[DEBUG] handleMouseDown - Click ignored (Button: ${event.button}, OnCanvas: ${clickedOnCanvas}, Targeting: ${isTargetingSpell || isAimingBow})`);
        }

        console.log("[[[ DEBUG handleMouseDown END ]]]"); // Log final
    } // Fin handleMouseDown (v4)
    
    
    /**
 * Intenta ajustar la dirección de movimiento de un enemigo para esquivar obstáculos estáticos cercanos.
 * Lanza rayos hacia los lados y al frente para detectar colisiones inminentes.
 * (v1.1 - Raycaster dedicado, obtención de obstáculos mejorada)
 * @param {THREE.Object3D} enemy - El objeto 3D del enemigo.
 * @param {THREE.Vector3} desiredDirection - La dirección de movimiento original deseada (normalizada).
 * @param {number} deltaTime - El tiempo transcurrido desde el último frame.
 * @returns {THREE.Vector3} La dirección de movimiento ajustada (o la original si no hay obstáculos).
 */
function avoidObstacles(enemy, desiredDirection, deltaTime) {
    // --- 1. Validaciones y Parámetros ---
    if (!enemy?.position || !desiredDirection || desiredDirection.lengthSq() < 0.001) {
        return desiredDirection; // Devolver dirección original si no hay datos
    }
    const enemyData = enemy.userData;
    const enemyPos = enemy.position;
    const enemyRadius = enemyData.hitRadius || 0.5; // Radio aproximado del enemigo

    // Parámetros de evasión (ajustables)
    const avoidanceDistance = enemyRadius * 3.5; // Distancia de los rayos laterales/frontales
    const sideRayAngle = Math.PI / 4.5; // Ángulo de los rayos laterales (40 grados)
    const forwardRayDistance = avoidanceDistance * 1.2; // Rayo frontal un poco más largo
    const pushStrength = 5.0 * deltaTime; // Fuerza con la que se aleja del obstáculo

    // Raycaster dedicado para evasión (evita conflictos)
    const avoidanceRaycaster = window.avoidanceRaycaster || (window.avoidanceRaycaster = new THREE.Raycaster());
    avoidanceRaycaster.near = 0.1; // Ignorar colisiones muy cercanas (dentro del enemigo)

    // Origen del rayo (ligeramente elevado)
    const rayOrigin = enemyPos.clone().add(new THREE.Vector3(0, (enemyData.heightOffset || 0.5) * 0.8, 0));

    // --- 2. Obtener Obstáculos Cercanos ---
    const collisionCandidates = [];
    const checkRadiusSq = (avoidanceDistance + enemyRadius) ** 2; // Radio cuadrado para buscar objetos

    if (gameState.currentLocation === 'world') {
        // En mundo: buscar en chunks activos
        const enemyChunkX = Math.floor((enemyPos.x + worldData.size.width/2) / worldData.chunkSize);
        const enemyChunkZ = Math.floor((enemyPos.z + worldData.size.depth/2) / worldData.chunkSize);
        for (let dx = -1; dx <= 1; dx++) {
            for (let dz = -1; dz <= 1; dz++) {
                const chunk = ChunkManager.activeChunks.get(`${enemyChunkX + dx}_${enemyChunkZ + dz}`);
                if (chunk?.objects) {
                    collisionCandidates.push(...chunk.objects.filter(o =>
                        o && o !== enemy && o !== playerModel && o.userData?.boundingBox && o.position.distanceToSquared(enemyPos) < checkRadiusSq && o.userData.type !== 'item_pickup' // <-- Excluir items
                    ));
                }
                 // Opcional: Añadir terreno del chunk si se quiere evitar chocar con paredes de terreno muy abruptas
                 // if (chunk?.terrainMesh) { collisionCandidates.push(chunk.terrainMesh); }
            }
        }
    } else {
        // En dungeon: buscar objetos del dungeon
        collisionCandidates.push(...world.objects.filter(o =>
            o && o !== enemy && o !== playerModel && o.userData?.boundingBox && o.userData.dungeonId === gameState.currentLocation && o.position.distanceToSquared(enemyPos) < checkRadiusSq && o.userData.type !== 'item_pickup'
        ));
    }

    const validObstacles = [...new Set(collisionCandidates)]; // Eliminar duplicados
    if (validObstacles.length === 0) {
        return desiredDirection; // No hay obstáculos cercanos, no hacer nada
    }

    // --- 3. Calcular Direcciones de Rayos ---
    const adjustedDirection = desiredDirection.clone(); // Empezar con la dirección deseada
    const forwardDirection = desiredDirection;
    const leftDirection = desiredDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), sideRayAngle);
    const rightDirection = desiredDirection.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -sideRayAngle);

    // --- 4. Lanzar Rayos y Ajustar Dirección ---
    let collisionDetected = false;
    const checkRay = (direction, maxDist, isSideRay = false) => {
        avoidanceRaycaster.far = maxDist;
        avoidanceRaycaster.set(rayOrigin, direction);
        try {
            const intersects = avoidanceRaycaster.intersectObjects(validObstacles, true); // Recursivo por si el obstáculo es un grupo
            if (intersects.length > 0) {
                const hit = intersects[0];
                console.log(`   [Avoidance] Hit detected by ${isSideRay ? 'side' : 'forward'} ray at dist ${hit.distance.toFixed(1)} with ${hit.object.name || hit.object.userData?.type}`); // DEBUG
                collisionDetected = true;
                if (isSideRay) {
                    // Si golpea un rayo lateral, empujar en dirección opuesta al rayo
                    const pushVector = direction.clone().negate().multiplyScalar(pushStrength / (hit.distance + 0.1)); // Empujar más fuerte si está más cerca
                    adjustedDirection.add(pushVector);
                } else {
                    // Si golpea el rayo frontal, intentar girar ligeramente
                    // Calcular vector perpendicular (en plano XZ)
                    const escapeDir = new THREE.Vector3(direction.z, 0, -direction.x).normalize();
                    // Añadir un pequeño componente de giro (aleatorio o basado en qué lado tiene más espacio)
                    adjustedDirection.addScaledVector(escapeDir, pushStrength * 0.5 * (Math.random() > 0.5 ? 1 : -1));
                }
                return true; // Hubo colisión
            }
        } catch (e) { console.error("[Avoidance] Raycast error:", e); }
        return false; // No hubo colisión
    };

    // Lanzar rayos (priorizar laterales)
    checkRay(leftDirection, avoidanceDistance, true);
    checkRay(rightDirection, avoidanceDistance, true);
    // Solo comprobar frontal si los laterales no golpearon (o como comprobación adicional)
    if (!collisionDetected) {
         checkRay(forwardDirection, forwardRayDistance, false);
    }


    // --- 5. Normalizar y Devolver ---
    if (collisionDetected && adjustedDirection.lengthSq() > 0.001) {
        adjustedDirection.normalize();
        // console.log("   [Avoidance] Direction adjusted."); // DEBUG
        return adjustedDirection;
    } else {
        // Si no hubo colisión o el ajuste resultó en vector cero, devolver original
        return desiredDirection;
    }
}

    /**
     * Procesa el raycasting y validación para lanzar un hechizo con objetivo
     * CUANDO SE ESTÁ EN MODO TARGETING. Llamada por handleMouseDown.
     * (v3 - Con Logs)
     * @param {MouseEvent} event - El evento de ratón original.
     * @param {object} spellDef - La definición del hechizo que se está apuntando.
     */
    function processSpellTargeting(event, spellDef) {
        console.log("[DEBUG] processSpellTargeting - Started for spell:", spellDef.id);

        // a. Raycasting (Configuración)
        if (!raycaster || !camera || !spellDef) {
            console.error("[DEBUG] processSpellTargeting - Raycaster, Camera, or SpellDef missing!");
            exitSpellTargetingMode(); return;
        }
        try {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            console.log("[DEBUG] processSpellTargeting - Raycaster set from camera.");
        } catch (e) {
            console.error("[DEBUG] processSpellTargeting - Error setting raycaster:", e);
            exitSpellTargetingMode(); return;
        }

        // b. Encontrar Objetivo Válido (Usa la versión CON chequeos de rango/LOS)
        console.log("[DEBUG] processSpellTargeting - Calling findValidTargetUnderCursor (Full version)...");
        const target = findValidTargetUnderCursor(spellDef); // <<<---- USA LA VERSIÓN COMPLETA AHORA
        console.log("[DEBUG] processSpellTargeting - findValidTargetUnderCursor returned:", target);

        // c. Validar si el objetivo encontrado es adecuado para ESTE hechizo
        let isValidTypeForSpell = false;
        if (target) {
            const spellTargetType = spellDef.targetType || 'any';
            const isGroundTarget = target instanceof THREE.Vector3;
            const entityData = !(target instanceof THREE.Vector3) ? target.userData : null;
            const entityType = entityData?.type;

            console.log(`[DEBUG] processSpellTargeting - Target Type: ${isGroundTarget ? 'Ground' : entityType} (${entityData?.name || 'N/A'}), Spell Requires: ${spellTargetType}`);

            // --- Reglas de Validación de Tipo (igual que antes) ---
            if (spellTargetType === 'enemy' && entityType === 'enemy' && !entityData?.isDead) isValidTypeForSpell = true;
            else if (spellTargetType === 'friendly' && (entityType === 'npc' || target === playerModel)) isValidTypeForSpell = true;
            else if (spellTargetType === 'self' && target === playerModel) isValidTypeForSpell = true;
            else if (spellTargetType === 'any' && (entityType || isGroundTarget)) isValidTypeForSpell = true;
            else if ((spellTargetType === 'ground' || spellDef.type === 'summon' || spellDef.type === 'area_effect') && isGroundTarget) isValidTypeForSpell = true;
            else if (!isGroundTarget && target === playerModel && (spellDef.type === 'buff' || spellDef.type === 'healing')) isValidTypeForSpell = true;
            // --- Fin Reglas ---

            console.log(`[DEBUG] processSpellTargeting - isValidTypeForSpell: ${isValidTypeForSpell}`);
        } else {
            console.log("[DEBUG] processSpellTargeting - Target is null.");
        }

        // d. Lanzar o Cancelar
        if (target && isValidTypeForSpell) {
            console.log("[DEBUG] processSpellTargeting - Target valid & type matches. Calling castSpellAtTarget...");
            castSpellAtTarget(spellDef, target);
        } else {
            console.log("[DEBUG] processSpellTargeting - Target invalid or type mismatch. Calling exitSpellTargetingMode...");
            if (target) { logMessage(`Objetivo inválido (${target.userData?.type || 'Suelo'}) para ${spellDef.name}.`, "warning"); }
            else { logMessage(`No se encontró un objetivo válido para ${spellDef.name}.`, "info"); }
            AudioManager.playSound('ui_error', 0.4);
            exitSpellTargetingMode(); // <<< --- CORRECCIÓN CLAVE ---
        }
        console.log("[DEBUG] processSpellTargeting - Finished.");
    } // --- Fin processSpellTargeting (v3) ---
 
  
    
/**
 * Ejecuta el lanzamiento final de un hechizo sobre un objetivo validado.
 * Consume maná, inicia cooldown, reproduce efectos y aplica el resultado del hechizo.
 * Llama a exitSpellTargetingMode DESPUÉS de iniciar el lanzamiento.
 * (v2.8 - CORREGIDO: Llama a exitSpellTargetingMode)
 * @param {object} spellDef - La definición completa del hechizo.
 * @param {THREE.Object3D | THREE.Vector3} target - El objetivo (Object3D o Vector3).
 */
function castSpellAtTarget(spellDef, target) {
    // 1. --- Validaciones ---
    if (!spellDef || !spellDef.id || !target) { console.error("castSpellAtTarget: Datos inválidos."); return; }
    const spellInstance = spells.known.find(s => s.id === spellDef.id);
    if (!spellInstance) { console.error(`Instancia hechizo ${spellDef.id} no encontrada.`); return; }
    // Permitir lanzar incluso si el cooldown acaba de terminar durante el clic
    if ((spellInstance.cooldownRemaining || 0) > 100) { /* logMessage(`${spellDef.name} en enfriamiento.`, "warning"); */ return; } // Evitar spam si se clickea rápido
    const finalManaCost = Math.floor((spellDef.manaCost || 0) * (playerState.manaCostMultiplier || 1));
    if (playerState.stats.mana < finalManaCost) { logMessage("No tienes suficiente maná.", "warning"); AudioManager.playSound('ui_error', 0.4); return; }
    if (spellDef.requiredSkillLevel) {
       const skillId = Object.keys(spellDef.requiredSkillLevel)[0]; const reqLevel = spellDef.requiredSkillLevel[skillId]; if ((playerState.skills[skillId]?.level || 0) < reqLevel) { logMessage(`Requiere Nivel ${reqLevel} de ${skillDefinitions[skillId]?.name || skillId}.`, "warning"); return; }
    }

    console.log(`Lanzando ${spellDef.name} a ${target instanceof THREE.Vector3 ? `(${target.x.toFixed(1)}, ${target.z.toFixed(1)})` : (target.userData?.name || target.uuid)}`);

    // 2. --- Consumir Recursos e Iniciar Cooldown ---
    playerState.stats.mana -= finalManaCost;
    spellInstance.cooldownRemaining = spellDef.cooldown || 0;

    // 3. --- Manejo del Tiempo de Lanzamiento (Cast Time) ---
    playerState.isCastingSpell = true;
    const castTime = spellDef.castTime || 500;
    AudioManager.playSound('spell_cast', 0.55);

    if (playerState.castingSpellTimeoutId) clearTimeout(playerState.castingSpellTimeoutId);

    playerState.castingSpellTimeoutId = setTimeout(() => {
         playerState.isCastingSpell = false;
         playerState.castingSpellTimeoutId = null;

         if (typeof spellDef.cast === 'function') {
             try {
                 spellDef.cast(playerModel, target, spellDef.id);
             } catch (e) {
                 console.error(`Error ejecutando cast() para ${spellDef.id}:`, e);
                 logMessage(`Error al lanzar ${spellDef.name}.`, "error");
                 // Considera devolver maná/resetear CD si el *efecto* falla
                 // playerState.stats.mana += finalManaCost; spellInstance.cooldownRemaining = 0;
             }
         } else {
             console.warn(`Hechizo ${spellDef.id} sin función cast().`);
             logMessage(`Error: ${spellDef.name} sin efecto.`, "error");
             // playerState.stats.mana += finalManaCost; spellInstance.cooldownRemaining = 0;
         }
         // Actualizar UI *después* de que el efecto se aplique (puede cambiar stats)
         updatePlayerUI();
         updateSpellsUI();
         updateActionButtons();

    }, castTime);

    // 4. --- Feedback Inmediato y Salir de Targeting ---
    logMessage(`Lanzando ${spellDef.name}...`, 'magic');
    updatePlayerUI(); // Reflejar coste maná
    updateSpellsUI(); // Mostrar cooldown
    updateActionButtons(); // Actualizar estado botón 'U'

    // CORRECCIÓN: Salir del modo apuntar INMEDIATAMENTE después de iniciar el casteo.
    exitSpellTargetingMode(); // <<< --- CORRECCIÓN AQUÍ ---

} // --- FIN MODIFICADA: castSpellAtTarget (v2.8) ---

function createTerrain(chunkX, chunkZ, chunkData) {
    if (!chunkData || !chunkData.heightData || !chunkData.biomeData || chunkData.worldXStart === undefined || chunkData.worldZStart === undefined) {
        console.error(`createTerrain: Faltan datos esenciales en chunkData para ${chunkX}_${chunkZ}.`, chunkData);
        return null;
    }
    if (!ChunkManager?.worldDataSource || !textureCache) {
        console.error("createTerrain: ChunkManager.worldDataSource o textureCache no disponibles.");
        return null;
    }

    const worldDataSource = ChunkManager.worldDataSource;
    const worldCs = worldDataSource.chunkSize;
    const res = worldDataSource.resolution;
    const chunkSegments = worldDataSource.verticesPerChunkEdge;
    const chunkWorldXStart = chunkData.worldXStart;
    const chunkWorldZStart = chunkData.worldZStart;

    let geometry;
    try {
        geometry = new THREE.PlaneGeometry(worldCs, worldCs, chunkSegments, chunkSegments);
        geometry.rotateX(-Math.PI / 2);
    } catch (e) {
        console.error(`Error creando PlaneGeometry para chunk ${chunkX}_${chunkZ}:`, e);
        return null;
    }

    const vertices = geometry.attributes.position.array;
    const colors = [];
    const uvs = geometry.attributes.uv.array; // Obtener UVs existentes
    const microNoise = typeof SimplexNoise !== 'undefined' ? new SimplexNoise(worldSeed + 10) : { noise2D: () => Math.random() * 0.1 - 0.05 };
    const microNoiseScale = 0.8;
    const microNoiseAmplitude = 0.06;
    const uvScale = 0.15; // Factor de escala para la textura de detalle (ajusta según sea necesario)

    const biomeColors = {};
    for (const name in worldDataSource.biomeColors) {
         try { biomeColors[name] = new THREE.Color(worldDataSource.biomeColors[name]); }
         catch (e) { console.warn(`Color inválido para bioma ${name}, usando gris.`); biomeColors[name] = new THREE.Color(0x808080); }
    }
    const defaultColor = biomeColors.grassland?.clone() || new THREE.Color(0x6b8e23);

    try {
        for (let z = 0; z <= chunkSegments; z++) {
            for (let x = 0; x <= chunkSegments; x++) {
                const vertIndex = (z * (chunkSegments + 1) + x);
                const dataIndex = vertIndex;

                const height = chunkData.heightData[dataIndex];
                if (vertices[vertIndex * 3 + 1] !== undefined && !isNaN(height)) { vertices[vertIndex * 3 + 1] = height; }
                else { vertices[vertIndex * 3 + 1] = WATER_LEVEL; }

                const biomeId = chunkData.biomeData[dataIndex];
                const biomeName = worldDataSource.getBiomeName(biomeId);
                let baseColor = biomeColors[biomeName]?.clone() || defaultColor.clone();

                if (biomeName !== 'road' && biomeName !== 'city') {
                    const worldX = chunkWorldXStart + x / res;
                    const worldZ = chunkWorldZStart + z / res;
                    const colorNoiseVal = microNoise.noise2D(worldX * microNoiseScale, worldZ * microNoiseScale) * microNoiseAmplitude;
                    baseColor.offsetHSL(colorNoiseVal * 0.1, colorNoiseVal * 0.3, colorNoiseVal * 0.6);
                }

                if (biomeName !== 'road' && biomeName !== 'city') {
                    const snowLine = BIOME_PARAMS.heightMountain * 1.05;
                    if (height > snowLine && biomeColors.snow) { const snowFactor = Math.min(1, (height - snowLine) / (TERRAIN_HEIGHT_SCALE * 0.2)); baseColor.lerp(biomeColors.snow, snowFactor * 0.9); }
                    else if (height < WATER_LEVEL + 1.0 && biomeName !== 'beach' && biomeColors.water_shallow) { const waterLerp = Math.max(0, 1.0 - (height - WATER_LEVEL) / 1.0); baseColor.lerp(biomeColors.water_shallow, waterLerp * 0.7); }
                }

                colors.push(baseColor.r, baseColor.g, baseColor.b);

                // Escalar UVs para repetir la textura
                uvs[vertIndex * 2] *= uvScale * worldCs; // Multiplicar por tamaño del chunk
                uvs[vertIndex * 2 + 1] *= uvScale * worldCs;
            }
        }
    } catch (e) { console.error(`Error durante la iteración de vértices para chunk ${chunkX}_${chunkZ}:`, e); return null; }

    try {
        geometry.computeVertexNormals();
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.attributes.uv.needsUpdate = true; // Marcar UVs como actualizados

        // Usar la textura de detalle precargada
        const detailTexture = textureCache['terrain_detail'];
        const normalTexture = textureCache['terrain_normal']; // Opcional

        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            roughness: 0.85,
            metalness: 0.05,
            map: detailTexture || null, // Aplicar textura base si se cargó
            // normalMap: normalTexture || null, // Aplicar normal map si se cargó
        });

        if (detailTexture) {
             // Estas propiedades deben estar en la textura, no en el material
             // detailTexture.wrapS = THREE.RepeatWrapping;
             // detailTexture.wrapT = THREE.RepeatWrapping;
             // La repetición se controla escalando UVs
        }

        const terrainMesh = new THREE.Mesh(geometry, material);
        terrainMesh.position.set(chunkWorldXStart + worldCs / 2, 0, chunkWorldZStart + worldCs / 2);
        terrainMesh.receiveShadow = true;
        terrainMesh.userData = { type: 'terrain_chunk', chunkKey: `${chunkX}_${chunkZ}` };

        console.log(`   -> Malla de terreno (con textura) para ${chunkX}_${chunkZ} creada.`);
        return terrainMesh;

    } catch (e) { console.error(`Error finalizando geometría/creando malla para chunk ${chunkX}_${chunkZ}:`, e); if (geometry) geometry.dispose(); return null; }
}
/**
 * Procesa el raycasting y validación para disparar una flecha con el arco.
 * Llamada por handleMouseDown cuando se hace clic izquierdo en modo apuntar arco.
 * (NUEVA - Extraída de handleMouseDown v5)
 * @param {MouseEvent} event - El evento de ratón original.
 */
function processBowTargeting(event) {
    // a. Raycasting
    if (!raycaster || !camera) { console.error("Raycaster/Cámara no inicializado!"); cancelAiming(); return; }
    try {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
    } catch(e) { console.error("  -> Error setting raycaster:", e); cancelAiming(); return; }

    // b. Obtener Objetivos Potenciales (Enemigos VIVOS y VISIBLES)
    const potentialTargets = world.enemies.filter(e => e?.userData && !e.userData.isDead && e.visible && e.position);
    if (potentialTargets.length === 0) {
         logMessage("No hay enemigos a la vista.", "info");
         cancelAiming(); return;
    }

    let validEnemyTarget = null;
    const maxBowRangeSq = 60 * 60;

    // c. Intersectar y Validar
    try {
        const intersects = raycaster.intersectObjects(potentialTargets, true);
        if (intersects.length > 0) {
            let hitObject = intersects[0].object; let targetEnemyObj = null; let depth = 0;
            while(hitObject && depth < 10) { if (hitObject.userData?.type === 'enemy') { targetEnemyObj = hitObject; break; } if (!hitObject.parent) break; hitObject = hitObject.parent; depth++; }

            if (targetEnemyObj && !targetEnemyObj.userData.isDead) {
                const targetDistanceSq = playerState.position.distanceToSquared(targetEnemyObj.position);
                if (targetDistanceSq <= maxBowRangeSq) {
                    const startPos = playerState.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.8, 0));
                    const endPos = targetEnemyObj.position.clone().add(new THREE.Vector3(0, targetEnemyObj.userData.heightOffset || 0.5, 0));
                    if (checkLineOfSight(startPos, endPos)) {
                        validEnemyTarget = targetEnemyObj;
                    } else { logMessage("Línea de visión bloqueada.", "warning"); }
                } else { logMessage("Objetivo fuera de alcance.", "warning"); }
            }
        }
    } catch(rayError) { console.error("  -> Error during bow targeting raycast:", rayError); }

    // d. Disparar o Cancelar
    if (validEnemyTarget) {
        console.log(">>> LLAMANDO A fireArrow <<<");
        fireArrow(validEnemyTarget); // Disparar
    } else {
        logMessage("Objetivo inválido para el arco.", "info");
        cancelAiming(); // Cancelar si no hay objetivo válido
    }
}

    /**
     * Procesa el raycasting y validación para lanzar un hechizo con objetivo
     * CUANDO SE ESTÁ EN MODO TARGETING. Llamada por handleMouseDown.
     * (v3 - Con Logs)
     * @param {MouseEvent} event - El evento de ratón original.
     * @param {object} spellDef - La definición del hechizo que se está apuntando.
     */
    function processSpellTargeting(event, spellDef) {
        console.log("[DEBUG] processSpellTargeting - Started for spell:", spellDef.id);

        // a. Raycasting (Configuración)
        if (!raycaster || !camera || !spellDef) {
            console.error("[DEBUG] processSpellTargeting - Raycaster, Camera, or SpellDef missing!");
            exitSpellTargetingMode(); return;
        }
        try {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            console.log("[DEBUG] processSpellTargeting - Raycaster set from camera.");
        } catch (e) {
            console.error("[DEBUG] processSpellTargeting - Error setting raycaster:", e);
            exitSpellTargetingMode(); return;
        }

        // b. Encontrar Objetivo Válido (Usa la función helper)
        console.log("[DEBUG] processSpellTargeting - Calling findValidTargetUnderCursor...");
        const target = findValidTargetUnderCursor(spellDef); // Usa versión simplificada
        console.log("[DEBUG] processSpellTargeting - findValidTargetUnderCursor returned:", target);

        // c. Validar si el objetivo encontrado es adecuado para ESTE hechizo
        let isValidTypeForSpell = false;
        if (target) {
            const spellTargetType = spellDef.targetType || 'any';
            const isGroundTarget = target instanceof THREE.Vector3;
            const entityData = !(target instanceof THREE.Vector3) ? target.userData : null;
            const entityType = entityData?.type;

            console.log(`[DEBUG] processSpellTargeting - Target Type: ${isGroundTarget ? 'Ground' : entityType} (${entityData?.name || 'N/A'}), Spell Requires: ${spellTargetType}`);

            // --- Reglas de Validación de Tipo ---
            if (spellTargetType === 'enemy' && entityType === 'enemy' && !entityData?.isDead) isValidTypeForSpell = true;
            else if (spellTargetType === 'friendly' && (entityType === 'npc' || target === playerModel)) isValidTypeForSpell = true;
            else if (spellTargetType === 'self' && target === playerModel) isValidTypeForSpell = true;
            else if (spellTargetType === 'any' && (entityType || isGroundTarget)) isValidTypeForSpell = true;
            else if ((spellTargetType === 'ground' || spellDef.type === 'summon' || spellDef.type === 'area_effect') && isGroundTarget) isValidTypeForSpell = true;
            else if (!isGroundTarget && target === playerModel && (spellDef.type === 'buff' || spellDef.type === 'healing')) isValidTypeForSpell = true;
            // --- Fin Reglas ---

            console.log(`[DEBUG] processSpellTargeting - isValidTypeForSpell: ${isValidTypeForSpell}`);
        } else {
            console.log("[DEBUG] processSpellTargeting - Target is null.");
        }

        // d. Lanzar o Cancelar
        if (target && isValidTypeForSpell) {
            console.log("[DEBUG] processSpellTargeting - Target valid & type matches. Calling castSpellAtTarget...");
            castSpellAtTarget(spellDef, target);
        } else {
            console.log("[DEBUG] processSpellTargeting - Target invalid or type mismatch. Calling exitSpellTargetingMode...");
            if (target) { logMessage(`Objetivo inválido (${target.userData?.type || 'Suelo'}) para ${spellDef.name}.`, "warning"); }
            else { logMessage(`No se encontró un objetivo válido para ${spellDef.name}.`, "info"); }
            AudioManager.playSound('ui_error', 0.4);
            exitSpellTargetingMode(); // <<< --- CORRECCIÓN CLAVE ---
        }
        console.log("[DEBUG] processSpellTargeting - Finished.");
    } // --- Fin processSpellTargeting (v3) ---
  
  
  
/**
 * Muestra el panel para seleccionar la cantidad a soltar.
 * (v6 - Manipulación directa de estilos, validación robusta)
 */
function showDropQuantityPrompt(itemId, itemName, maxQuantity, inventoryIndex) {
    console.log(`[showDropQuantityPrompt v6] Called for ${itemName} (Max: ${maxQuantity}, Index: ${inventoryIndex})`);

    const promptPanel = domCache['quantity-prompt'];
    if (!(promptPanel instanceof HTMLElement)) { console.error("[showDropQuantityPrompt] FATAL: Panel #quantity-prompt no encontrado."); return; }

    // 1. Cerrar otros modales
    closeOtherModals(); // Asegúrate que esto llama a hideDropQuantityPrompt si estaba abierto

    // 2. Guardar estado global
    currentDropItemId = itemId;
    currentDropMaxQuantity = maxQuantity;
    currentDropInventoryIndex = inventoryIndex;

    // 3. Obtener y validar elementos internos
    const titleEl = domCache['quantity-prompt-title']; const nameEl = domCache['quantity-prompt-item-name']; const maxEl = domCache['quantity-prompt-item-max']; const inputEl = domCache['quantity-prompt-input']; const decreaseBtn = domCache['quantity-prompt-decrease']; const increaseBtn = domCache['quantity-prompt-increase']; const maxBtn = domCache['quantity-prompt-max']; const confirmBtn = domCache['quantity-prompt-confirm']; const cancelBtn = domCache['quantity-prompt-cancel']; const closeBtn = domCache['quantity-prompt-close'];
    if (!titleEl || !nameEl || !maxEl || !(inputEl instanceof HTMLInputElement) || !decreaseBtn || !increaseBtn || !maxBtn || !confirmBtn || !cancelBtn || !closeBtn) { console.error("[showDropQuantityPrompt] FATAL: Faltan elementos internos del panel."); hideDropQuantityPrompt(); return; }

    // 4. Configurar UI del panel
    titleEl.textContent = `Soltar ${itemName}`; nameEl.textContent = itemName; maxEl.textContent = `Max: ${maxQuantity}`; inputEl.value = '1'; inputEl.max = maxQuantity.toString(); inputEl.min = '1';

    // 5. Limpiar y Configurar Listeners
    const setupListener = (element, event, listener) => { if(!element) return; if(element.currentListener) try { element.removeEventListener(event, element.currentListener); } catch(e){} try { element.addEventListener(event, listener); element.currentListener = listener; } catch(e){ console.error("Error adding listener:", e, element, event);} };
    setupListener(inputEl, 'change', () => updateDropQuantity(0)); setupListener(inputEl, 'input', () => updateDropQuantity(0)); setupListener(decreaseBtn, 'click', () => updateDropQuantity(-1)); setupListener(increaseBtn, 'click', () => updateDropQuantity(1)); setupListener(maxBtn, 'click', () => updateDropQuantity(Infinity)); setupListener(confirmBtn, 'click', confirmDropQuantity); setupListener(cancelBtn, 'click', hideDropQuantityPrompt); setupListener(closeBtn, 'click', hideDropQuantityPrompt);

    // Inicializar estado botones
    updateDropQuantity(0); // Llama a esto para setear disabled/enabled inicial

    // 6. *** MOSTRAR PANEL CON ESTILOS DIRECTOS ***
    promptPanel.style.display = 'flex';
    promptPanel.style.visibility = 'visible';
    promptPanel.style.opacity = '1';
    // Asegurar z-index (aunque el CSS con !important debería bastar)
    // promptPanel.style.zIndex = '2500'; // Puedes descomentar si sospechas problemas de z-index

    // 7. Verificar si realmente se muestra (para depuración)
    requestAnimationFrame(() => {
        if (promptPanel.parentElement) { // Comprueba si está en el DOM
            const styles = window.getComputedStyle(promptPanel);
            console.log(`[showDropQuantityPrompt v6] Panel styles after setting - Display: ${styles.display}, Visibility: ${styles.visibility}, Opacity: ${styles.opacity}`);
            if (styles.display !== 'flex' || styles.visibility !== 'visible' || parseFloat(styles.opacity) < 1) {
                console.error("¡PANEL AÚN NO VISIBLE CORRECTAMENTE! Verifica conflictos CSS o estructura HTML.");
            } else {
                 console.log("[showDropQuantityPrompt v6] Panel mostrado correctamente.");
            }
        } else {
            console.error("[showDropQuantityPrompt v6] Panel no encontrado en el DOM después de intentar mostrarlo.");
        }
    });


    AudioManager.playSound('ui_open', 0.3);
}

    
    
/**
 * Oculta el panel de cantidad y limpia el estado.
 * (v6 - Manipulación directa de estilos)
 */
function hideDropQuantityPrompt() {
    const promptPanel = domCache['quantity-prompt'];
    let wasVisible = false;

    if (promptPanel instanceof HTMLElement) {
         if (promptPanel.style.display !== 'none') { // Comprobar si estaba visible
              wasVisible = true;
              promptPanel.style.display = 'none'; // Ocultar
              promptPanel.style.visibility = 'hidden'; // Ocultar semánticamente
              promptPanel.style.opacity = '0'; // Hacer transparente

              // Limpiar listeners
              const inputEl = domCache['quantity-prompt-input']; const decreaseBtn = domCache['quantity-prompt-decrease']; const increaseBtn = domCache['quantity-prompt-increase']; const maxBtn = domCache['quantity-prompt-max']; const confirmBtn = domCache['quantity-prompt-confirm']; const cancelBtn = domCache['quantity-prompt-cancel']; const closeBtn = domCache['quantity-prompt-close'];
              const clearListener = (el, ev) => { if(el && el.currentListener) { try { el.removeEventListener(ev, el.currentListener); } catch(e){} el.currentListener = null;} }
              clearListener(inputEl, 'change'); clearListener(inputEl, 'input'); clearListener(decreaseBtn, 'click'); clearListener(increaseBtn, 'click'); clearListener(maxBtn, 'click'); clearListener(confirmBtn, 'click'); clearListener(cancelBtn, 'click'); clearListener(closeBtn, 'click');
         }
    }

    // Limpiar estado lógico
    currentDropItemId = null;
    currentDropMaxQuantity = 0;
    currentDropInventoryIndex = -1;

    if (wasVisible) {
         AudioManager.playSound('ui_close', 0.3);
    }
}
/**
 * Actualiza el valor del input de cantidad y habilita/deshabilita botones.
 * @param {number} change - Cambio a aplicar (+1, -1, 0 para validar, Infinity para MAX/Todo).
 */
function updateDropQuantity(change) {
    const inputEl = domCache['quantity-prompt-input'];
    const decreaseBtn = domCache['quantity-prompt-decrease'];
    const increaseBtn = domCache['quantity-prompt-increase'];
    const maxBtn = domCache['quantity-prompt-max']; // Referencia al botón MAX
    const confirmBtn = domCache['quantity-prompt-confirm']; // Referencia al botón Confirmar

    // Validar que todos los elementos existen
    if (!(inputEl instanceof HTMLInputElement) || !(decreaseBtn instanceof HTMLButtonElement) || !(increaseBtn instanceof HTMLButtonElement) || !(maxBtn instanceof HTMLButtonElement) || !(confirmBtn instanceof HTMLButtonElement)) {
        console.error("updateDropQuantity: Faltan elementos UI del panel.");
        return;
    }

    let currentValue = parseInt(inputEl.value, 10);
    if (isNaN(currentValue)) currentValue = 1;

    let newValue;
    if (change === Infinity) { // Botón MAX/Todo
        newValue = currentDropMaxQuantity;
    } else {
        newValue = currentValue + change;
    }

    // Validar límites (asegurarse de que no sea mayor que el máximo o menor que 1)
    newValue = Math.max(1, Math.min(currentDropMaxQuantity, newValue));

    inputEl.value = newValue.toString();

    // Habilitar/deshabilitar botones +/-/MAX
    decreaseBtn.disabled = newValue <= 1;
    increaseBtn.disabled = newValue >= currentDropMaxQuantity;
    maxBtn.disabled = newValue >= currentDropMaxQuantity; // Deshabilitar MAX si ya está al máximo

    // Habilitar/deshabilitar botón Confirmar (solo si la cantidad es válida)
    confirmBtn.disabled = newValue <= 0 || newValue > currentDropMaxQuantity;
}


/**
 * Confirma la acción de soltar la cantidad seleccionada.
 */
function confirmDropQuantity() {
    const inputEl = domCache['quantity-prompt-input'];
    if (!(inputEl instanceof HTMLInputElement) || currentDropInventoryIndex < 0 || !currentDropItemId) {
        console.error("confirmDropQuantity: Estado inválido o input no encontrado.");
        hideDropQuantityPrompt();
        return;
    }

    let quantityToDrop = parseInt(inputEl.value, 10);
    // Validar cantidad ANTES de proceder
    if (isNaN(quantityToDrop) || quantityToDrop <= 0 || quantityToDrop > currentDropMaxQuantity) {
        logMessage("Cantidad inválida seleccionada.", "warning");
        AudioManager.playSound('ui_error', 0.4);
        // Podrías resaltar el input en rojo o simplemente no hacer nada
        inputEl.focus(); // Poner foco en el input problemático
        return; // NO cerrar el panel si la cantidad es inválida
    }

    // Re-obtener item original justo antes de modificar inventario por seguridad
    const itemOriginal = inventory.items[currentDropInventoryIndex];
    const itemDef = itemDefinitions[currentDropItemId];

    // Doble check de consistencia
    if (!itemOriginal || itemOriginal.id !== currentDropItemId || !itemDef || itemOriginal.count < quantityToDrop) {
         console.error("Error confirmDropQuantity: Inconsistencia de datos o cantidad cambió.", itemOriginal, quantityToDrop);
         logMessage("Error al soltar el objeto.", "error");
         hideDropQuantityPrompt();
         return;
    }

    console.log(`Confirmado: Soltar ${quantityToDrop} de ${currentDropItemId} desde índice ${currentDropInventoryIndex}`);

    // Preparar item a spawnear
    const itemInstanceToSpawn = { ...itemOriginal };
    itemInstanceToSpawn.count = quantityToDrop; // Cantidad a soltar

    // Calcular posición (sin cambios)
    const dropOffset = 1.2; const playerForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerModel.quaternion);
    const dropPositionBase = playerState.position.clone().addScaledVector(playerForward, dropOffset);
    const terrainY = ChunkManager.getTerrainHeightAt(dropPositionBase.x, dropPositionBase.z);
    const dropPositionY = Math.max(terrainY + 0.15, WATER_LEVEL + 0.1);
    const dropPosition = new THREE.Vector3(dropPositionBase.x, dropPositionY, dropPositionBase.z);

    // Spawnear
    const spawnInitiated = spawnItem(itemInstanceToSpawn, dropPosition);

    if (spawnInitiated) {
        // Actualizar inventario DESPUÉS de spawn exitoso
        itemOriginal.count -= quantityToDrop;
        let itemRemoved = false;
        if (itemOriginal.count <= 0) {
            inventory.items.splice(currentDropInventoryIndex, 1);
            itemRemoved = true;
        }

        // Importante: Deseleccionar SOLO si el item fue completamente eliminado
        // O si la selección se vuelve inválida (aunque splice debería manejar índices)
        if (itemRemoved) {
             deselectInventoryItem();
        } else {
             updateActionButtons(); // Actualizar botones si el item sigue seleccionado pero cambió cantidad
        }


        AudioManager.playSound('drop_item', 0.5);
        logMessage(`Has soltado ${quantityToDrop} ${itemDef.name}.`, 'system');
        updateInventoryUI();
        hideDropQuantityPrompt(); // Cerrar panel al éxito
    } else {
        logMessage("No se pudo soltar el objeto (fallo al spawnear).", "error");
        AudioManager.playSound('ui_error', 0.4);
        hideDropQuantityPrompt(); // Cerrar panel incluso si falla el spawn
    }
}


// --- Asegúrate que `updateDropPanelQuantity` también use la variable `maxBtn` correcta ---
/**
 * Actualiza el input de cantidad en el panel de soltar y los botones.
 * (v2 - Usa maxBtn correcto)
 * @param {number} change - Cambio a aplicar (+1, -1, 0 para validar, Infinity para MAX/Todo).
 */
function updateDropPanelQuantity(change) {
    const inputEl = domCache['drop-quantity-input'];
    const decreaseBtn = domCache['drop-decrease-btn'];
    const increaseBtn = domCache['drop-increase-btn'];
    const maxBtn = domCache['drop-quantity-max']; // <-- USA EL ID CORRECTO DEL BOTÓN MAX
    const confirmBtn = domCache['drop-confirm-specific-btn'];

    if (!(inputEl instanceof HTMLInputElement) || !(decreaseBtn instanceof HTMLButtonElement) || !(increaseBtn instanceof HTMLButtonElement) || !(maxBtn instanceof HTMLButtonElement) || !(confirmBtn instanceof HTMLButtonElement)) {
        console.error("updateDropPanelQuantity: Faltan elementos UI del panel.");
        return;
    }

    let currentValue = parseInt(inputEl.value, 10);
    if (isNaN(currentValue)) currentValue = 1;

    let newValue;
    if (change === Infinity) { // Botón MAX/Todo
        newValue = currentDropMaxQuantity;
    } else {
        newValue = currentValue + change;
    }

    newValue = Math.max(1, Math.min(currentDropMaxQuantity, newValue)); // Validar límites

    inputEl.value = newValue.toString();

    // Habilitar/deshabilitar botones +/-/MAX
    decreaseBtn.disabled = newValue <= 1;
    increaseBtn.disabled = newValue >= currentDropMaxQuantity;
    maxBtn.disabled = newValue >= currentDropMaxQuantity; // <-- Ahora usa la variable correcta

    // Habilitar/deshabilitar botón Confirmar
    confirmBtn.disabled = newValue <= 0 || newValue > currentDropMaxQuantity;
}


/**
 * Lógica para soltar una cantidad específica de items.
 * Llamada por los botones del panel de soltar.
 * (v3 - NO cierra el panel al éxito)
 * @param {number} quantityToDrop - La cantidad exacta a soltar.
 * @param {number} inventoryIndex - El índice del item en el inventario.
 */
function confirmDropSpecificQuantity(quantityToDrop, inventoryIndex) {
    console.log(`[confirmDrop v3] Intentando soltar ${quantityToDrop} del índice ${inventoryIndex}`);

    // --- 1. Validaciones Robustas ---
    if (inventoryIndex === null || inventoryIndex < 0 || inventoryIndex >= inventory.items.length) {
        console.error("[confirmDrop v3] Índice de inventario inválido:", inventoryIndex);
        logMessage("Error interno al soltar.", "error");
        closeDropItemPanel(); // Cerrar si el índice es inválido
        return;
    }
    // ... (resto de validaciones: item existe, def existe, quest item, cantidad > 0) ...
    const itemOriginal = inventory.items[inventoryIndex];
    if (!itemOriginal || !itemOriginal.id) { /*...*/ closeDropItemPanel(); return; }
    const itemDef = itemDefinitions[itemOriginal.id];
    if (!itemDef) { /*...*/ closeDropItemPanel(); return; }
    if (itemDef.questItem) { /*...*/ return; } // No cerrar si es quest item
    quantityToDrop = Math.min(quantityToDrop, itemOriginal.count || 1);
    if (isNaN(quantityToDrop) || quantityToDrop <= 0) { /*...*/ return; } // No cerrar si cantidad inválida

    console.log(`[confirmDrop v3] Validado: Soltar ${quantityToDrop} de ${itemDef.name}`);

    // --- 2. Preparar Item para Spawn ---
    const itemInstanceToSpawn = { ...itemOriginal };
    itemInstanceToSpawn.count = quantityToDrop;

    // --- 3. Calcular Posición de Drop ---
    // ... (código para calcular dropPosition) ...
    const dropOffset = 1.2;
    const playerForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerModel.quaternion);
    const dropPositionBase = playerState.position.clone().addScaledVector(playerForward, dropOffset);
    const terrainY = ChunkManager.getTerrainHeightAt(dropPositionBase.x, dropPositionBase.z);
    const dropPositionY = Math.max(terrainY + 0.15, WATER_LEVEL + 0.1);
    const dropPosition = new THREE.Vector3(dropPositionBase.x, dropPositionY, dropPositionBase.z);


    // --- 4. Intentar Spawnear el Item ---
    const spawnInitiated = spawnItem(itemInstanceToSpawn, dropPosition);

    // --- 5. Procesar Resultado del Spawn ---
    if (spawnInitiated) {
        console.log("[confirmDrop v3] spawnItem iniciado con éxito.");
        // *** Actualizar Inventario SOLO SI el spawn se inició ***
        // ... (lógica para actualizar inventario, itemOriginal.count--, splice si es necesario) ...
         const currentSelectedItemIndex = inventory.selectedItemIndex;
         let itemRemoved = false;
         const itemInInventory = inventory.items[inventoryIndex];
         if (itemInInventory && itemInInventory.id === itemOriginal.id) {
             itemInInventory.count -= quantityToDrop;
             if (itemInInventory.count <= 0) {
                 inventory.items.splice(inventoryIndex, 1);
                 itemRemoved = true;
             }
         } else { console.error("Error crítico al actualizar inventario post-drop."); /* Podrías revertir oro si fuera compra */ }

        // --- Actualizar Selección y UI ---
        // ... (lógica para deseleccionar si era el item, ajustar índice si se eliminó uno anterior) ...
          if (inventoryIndex === currentSelectedItemIndex) {
              inventory.selectedItemIndex = null;
          } else if (itemRemoved && currentSelectedItemIndex !== null && inventoryIndex < currentSelectedItemIndex) {
              inventory.selectedItemIndex--;
          }

        updateActionButtons(); // Actualizar botones generales
        updateInventoryUI();   // Actualizar inventario visual

        // --- Feedback y *** NO CERRAR PANEL *** ---
        AudioManager.playSound('drop_item', 0.5);
        logMessage(`Has soltado ${quantityToDrop} ${itemDef.name}.`, 'system');
        // --- LÍNEA ELIMINADA ---
        // hideDropQuantityPrompt(); // ¡¡NO LLAMAR A ESTO AQUÍ!!
        // -------------------------
        // Después de soltar con éxito, ACTUALIZAR EL PANEL ACTUAL para reflejar la nueva cantidad máxima
        currentDropMaxQuantity = itemInInventory?.count || 0; // Actualizar max global
        if (currentDropMaxQuantity > 0) {
             const maxTextEl = domCache['drop-max-text'];
             const allCountSpan = domCache['drop-all-count'];
             if(maxTextEl) maxTextEl.textContent = `(Max: ${currentDropMaxQuantity})`;
             if(allCountSpan) allCountSpan.textContent = currentDropMaxQuantity.toString();
             const inputEl = domCache['drop-quantity-input']; // Actualizar max del input y validar valor actual
             if(inputEl instanceof HTMLInputElement) {
                  inputEl.max = currentDropMaxQuantity.toString();
                  if(parseInt(inputEl.value, 10) > currentDropMaxQuantity) {
                      inputEl.value = currentDropMaxQuantity.toString();
                  }
             }
             updateDropPanelQuantity(0); // Revalidar botones +/-/Confirmar/Todo
        } else {
             // Si la cantidad llegó a 0, ahora sí cerramos el panel
             console.log("[confirmDrop v3] Item stack agotado. Cerrando panel.");
             closeDropItemPanel();
        }


    } else {
        // Si spawnItem falló
        console.error("[confirmDrop v3] spawnItem devolvió false.");
        logMessage("No se pudo soltar el objeto (fallo al spawnear).", "error");
        AudioManager.playSound('ui_error', 0.4);
        closeDropItemPanel(); // <<-- Cerrar el panel si falla el spawn
    }
}

    function handleEscapeKey() {
        if (gameState.isTargetingSpell) { exitSpellTargetingMode(); return; }
        if (gameState.isAimingWithBow) { cancelAiming(); return; }
        if (gameState.isLargeMapOpen) { closeLargeMap(); return; }
        if (gameState.isOptionsMenuOpen) { closeOptionsMenu(); return; }
        if (gameState.isCharacterSheetOpen) { toggleCharacterSheet(); return; }
        if (gameState.isShopOpen) { closeShop(); return; }
        if (gameState.isEquipmentModalOpen) { closeEquipmentModal(); return; }
        if (gameState.isCraftingModalOpen) { closeCraftingModal(); return; }
        if (gameState.isQuestsModalOpen) { closeQuestsModal(); return; }
        if (gameState.isSkillsModalOpen) { closeSkillsModal(); return; }
        // Si ninguna UI principal está abierta, pausar/reanudar
        if (gameState.isPlaying) {
            if (gameState.isPaused) resumeGame(); else pauseGame();
        }
    }

function finalizeInitialization() {
    const loadingScreen = domCache["loading-screen"];
    const startScreen = domCache["start-screen"];

    if (loadingScreen instanceof HTMLElement) loadingScreen.style.display = "none";

    try {
        // Inicializar PREVIEW solo si no se inicializó ya
        if(!previewRenderer) {
            initPreviewRenderer();
        } else {
             // Asegurar que el renderer esté en el DOM si ya existe
             const previewContainer = domCache['char-preview-model'];
             if(previewContainer instanceof HTMLElement && !previewContainer.contains(previewRenderer.domElement)) {
                 previewContainer.appendChild(previewRenderer.domElement);
                 // Reiniciar bucle de animación si se detuvo
                 if(previewAnimationLoopId === null) animatePreview();
             }
        }
    } catch (previewInitError) {
        console.error("Error fatal inicializando el preview del personaje:", previewInitError);
        const previewContainer = domCache['char-preview-model'];
        if (previewContainer instanceof HTMLElement) previewContainer.innerHTML = "<p style='color:red;'>Error Preview</p>";
    }

    if (startScreen instanceof HTMLElement) {
        startScreen.style.display = "flex";
        const continueButton = domCache["continue-button"];
        if(continueButton instanceof HTMLElement) {
             const hasSave = !!localStorage.getItem('eldravar_save');
             continueButton.disabled = !hasSave;
             continueButton.classList.toggle('disabled', !hasSave);
        }
    }

    gameState.isLoading = false;
    console.log("Inicialización de Eldravar completada. Menú principal mostrado.");
    logMessage(`Bienvenido a Eldravar v${VERSION}.`, 'system');
}

function applyLightingIntensityFactor() {
    if (!scene) return;
    let lightsAdjusted = 0;
    scene.traverse(obj => {
        if (obj.isLight && obj.userData?.baseIntensity !== undefined) {
            const baseIntensity = obj.userData.baseIntensity;
            obj.intensity = baseIntensity * lightingIntensityFactor;
            lightsAdjusted++;
        }
    });
}

    // --- Funciones de Flujo de Juego ---
function showCharacterCreation() {
    const startScreen = domCache["start-screen"];
    const characterCreation = domCache["character-creation"];
    const previewContainer = domCache['char-preview-model'];

    if (startScreen instanceof HTMLElement) startScreen.style.display = "none";
    if (characterCreation instanceof HTMLElement) characterCreation.style.display = "flex";

    // --- Resetear selecciones iniciales y estado ---
    playerState.race = 'human'; // O el default que prefieras
    playerState.gender = 'male'; // O el default que prefieras
    playerState.class = 'warrior'; // O el default que prefieras
    // Actualiza la UI para reflejar estos defaults (botones/radios)
    document.querySelector('.race-option[data-race="human"]')?.classList.add('selected');
    document.querySelector('#gender-male')?.setAttribute('checked', 'checked');
    document.querySelector('.class-option[data-class="warrior"]')?.classList.add('selected');
    updateCharacterCreationAttributes(); // Calcula atributos iniciales

    // --- Llamar a actualizar preview DESPUÉS de mostrar pantalla y si el preview está listo ---
    if (previewScene && previewRenderer && previewCamera) { // Importante: Comprueba si está inicializado
         console.log("showCharacterCreation: Llamando a updateCharacterPreviewModel para el modelo inicial.");
         updateCharacterPreviewModel(); // Carga el modelo inicial (Humano Masculino)
    } else {
        console.error("showCharacterCreation: El entorno de preview no está listo. No se puede mostrar modelo inicial.");
        if(previewContainer) previewContainer.innerHTML = "<p style='color:orange;'>Preview no disponible.</p>";
    }


    AudioManager.playSound('ui_open', 0.4);
}
    function selectClass(element, isInitialization = false) {
        if (!(element instanceof HTMLElement)) return;
        domCache.classOptions?.forEach(option => {
            if (option instanceof HTMLElement) option.classList.remove("selected");
        });
        element.classList.add("selected");
        const selectedClass = element.dataset.class || 'warrior';

        // Aplicar atributos base de la clase SOLO durante la creación inicial
        if (isInitialization) {
            playerState.class = selectedClass;
            switch (selectedClass) {
                case 'warrior': playerState.attributes = { strength: 12, dexterity: 10, intelligence: 8, constitution: 12 }; break;
                case 'mage': playerState.attributes = { strength: 8, dexterity: 9, intelligence: 14, constitution: 10 }; break;
                case 'paladin': playerState.attributes = { strength: 11, dexterity: 9, intelligence: 10, constitution: 11 }; break;
                case 'hunter': playerState.attributes = { strength: 10, dexterity: 13, intelligence: 8, constitution: 10 }; break;
                case 'assassin': playerState.attributes = { strength: 9, dexterity: 14, intelligence: 8, constitution: 10 }; break;
                case 'worker': playerState.attributes = { strength: 10, dexterity: 11, intelligence: 9, constitution: 11 }; break; // Más balanceado
                default: playerState.attributes = { strength: 10, dexterity: 10, intelligence: 10, constitution: 10 };
            }
        }
        if (!isInitialization) AudioManager.playSound('ui_confirm', 0.3);
    }

    function createCharacter() {
        const nameInput = domCache["character-name"];
        let charName = "Héroe";
        if (nameInput instanceof HTMLInputElement && nameInput.value.trim()) {
            charName = nameInput.value.trim().substring(0, 16); // Limitar longitud
        }
        const selectedClassOption = document.querySelector('.class-option.selected');
        const charClass = selectedClassOption?.dataset.class || 'warrior';

        playerState.name = charName;
        playerState.class = charClass;
        setupInitialPlayerState(); // Configura todo basado en la clase y resetea

 const characterCreation = domCache["character-creation"];
    if (characterCreation instanceof HTMLElement) characterCreation.style.display = "none";

    // *** Iniciar el juego (que llamará a setupSceneContent -> createPlayer) ***
    startGame();
}

async function startGame() {
    console.log("--- Iniciando startGame (v3 - Async Load Handling) ---");
    const functionName = "startGame"; // Para logs

    // --- 1. Ocultar Menús Anteriores ---
    const startScreen = domCache["start-screen"];
    const characterCreation = domCache["character-creation"];
    if (startScreen instanceof HTMLElement) startScreen.style.display = "none";
    if (characterCreation instanceof HTMLElement) characterCreation.style.display = "none";

    // --- 2. Mostrar Pantalla de Carga Temporal ---
    showLoadingScreen(); // Muestra pantalla con título, barra, texto
    updateLoadingProgress(5, "Preparando tu aventura..."); // Mensaje inicial

    try {
        // --- 3. Configurar el Contenido 3D Principal ---
        //    Esto incluye llamar a createPlayer() de forma ASÍNCRONA.
        //    `setupSceneContent` debe ser async o devolver una promesa si contiene `await createPlayer()`.
        updateLoadingProgress(10, "Forjando el mundo...");
        await setupSceneContent(); // Espera a que se complete la carga del jugador y NPCs iniciales
        console.log(`[${functionName}] setupSceneContent completado.`);
        updateLoadingProgress(75, "Posicionando al héroe...");

        // --- 4. Validar y Posicionar Modelo del Jugador (POST-CARGA) ---
        if (!playerModel) {
            // Esto NO debería pasar si setupSceneContent esperó correctamente a createPlayer
            console.error(`[${functionName}] ¡ERROR CRÍTICO! playerModel no fue creado por setupSceneContent.`);
            throw new Error("Fallo al crear el objeto del jugador.");
        }

        // Ajustar posición Y inicial basada en terreno cargado
        const groundY = ChunkManager.getTerrainHeightAt(playerState.position.x, playerState.position.z);
        if (isNaN(groundY)) {
            console.warn(`[${functionName}] No se pudo obtener altura del terreno en la posición inicial (${playerState.position.x.toFixed(1)}, ${playerState.position.z.toFixed(1)}). Usando Y actual.`);
            // No modificar Y si la altura es inválida
        } else {
            playerState.position.y = groundY + PLAYER_HALF_HEIGHT;
        }
        playerModel.position.copy(playerState.position); // Sincronizar modelo 3D
        playerModel.rotation.y = playerState.rotationY;
        playerState.onGround = true; // Asumir que empieza en el suelo
        console.log(`[${functionName}] Posición inicial del jugador ajustada a Y=${playerState.position.y.toFixed(2)}`);

        // --- 5. Configurar Cámara Inicial ---
        if (orbitControls && camera) {
            orbitControls.target.copy(playerState.position).add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.9, 0));
            const initialOffset = cameraOffset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), playerState.rotationY);
            camera.position.copy(playerState.position).add(initialOffset);
            camera.lookAt(orbitControls.target);
            orbitControls.update(); // Aplicar cambios iniciales
            console.log(`[${functionName}] Cámara posicionada.`);
        } else {
            console.warn(`[${functionName}] OrbitControls o Cámara no disponibles para configuración inicial.`);
        }

        // --- 6. Actualizar TODA la UI con el estado final ---
        updateLoadingProgress(90, "Pulido final...");
        updatePlayerUI();
        updateInventoryUI();
        updateEquipmentUI();
        updateQuestLog();
        updateSpellsUI();
        updateSkillsUI();
        updateCraftingUI();
        updateMinimap(); // Primera llamada para dibujar
        updateActionSlotsUI();
        updateQuestTrackerUI();
        updateTargetUI(); // Limpiar target inicial
        updateNPCMarkers(); // Actualizar '!' en NPCs
        console.log(`[${functionName}] Interfaces de usuario actualizadas.`);

        // --- 7. Preparar Estado Final del Juego ---
        gameState.isPlaying = true;
        gameState.isPaused = false;
        gameState.isGameOver = false;
        gameState.isGhost = false; // Asegurarse de que no empiece como fantasma
        gameState.lastSaveTime = gameState.gameTime; // O 0 si es partida nueva
        closeOtherModals(); // Asegurar que no queden modales abiertos
        updateLoadingProgress(100, "¡Aventura lista!");

        // --- 8. Ocultar Carga, Mostrar UI del Juego e Iniciar Bucle Principal ---
        // Usar un pequeño timeout para permitir que el navegador renderice el 100%
        // antes de cambiar pantallas e iniciar el bucle.
        setTimeout(() => {
            hideLoadingScreen(); // Oculta la pantalla de carga
            showGameUI();      // Muestra la sidebar y el contenedor UI principal

            startGameLoop();   // Inicia el bucle de requestAnimationFrame

            logMessage(`Bienvenido a Eldravar v${VERSION}, ${playerState.name}. Tu aventura comienza...`, "system");
            showNotification("¡Bienvenido a Eldravar!", "info");
            AudioManager.updateMusic(); // Iniciar música de fondo
            console.log(`[${functionName}] Juego iniciado y bucle corriendo.`);

        }, 250); // Delay de 250ms (ajustable)

    } catch (error) {
        // --- Manejo de Errores Críticos durante el Inicio ---
        console.error(`[${functionName}] Error crítico durante el inicio de la aventura:`, error);
        hideLoadingScreen(); // Ocultar carga aunque falle
        // Volver al menú principal como fallback
        finalizeInitialization(); // Asegúrate que esta función muestre el menú principal
        logMessage("Error crítico al iniciar la aventura. Volviendo al menú.", "error");
        showNotification("Error al Iniciar Aventura", "error", 5000);
        // Detener música si se inició
        AudioManager.stopMusic();
    }
}
    function startGameLoop() {
        if (gameLoopId !== null) cancelAnimationFrame(gameLoopId);
        clock.start(); // Reiniciar reloj delta
        function gameLoop() {
            // Verificar si aún debemos correr
            if (!gameState.isPlaying || gameState.isLoading) {
                 stopGameLoop(); // Detener si el estado cambió
                 return;
            }
            gameLoopId = requestAnimationFrame(gameLoop);

            // Procesar juego solo si no está pausado
            if (!gameState.isPaused) {
                const deltaTime = Math.min(clock.getDelta(), 0.1); // Obtener delta y limitar
                updateGame(deltaTime);
            }
             // Renderizar siempre (incluso pausado para ver menú/cambios UI)
            try {
                 render();
            } catch (e) {
                 console.error("Error fatal en render loop:", e);
                 stopGameLoop(); // Detener en caso de error grave de renderizado
                 logMessage("Error gráfico crítico. El juego se ha detenido.", "error");
            }
        }
        gameLoopId = requestAnimationFrame(gameLoop);
        console.log("Bucle de juego iniciado.");
    }

    function stopGameLoop() {
        if (gameLoopId !== null) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
            console.log("Bucle de juego detenido.");
        }
    }
    
     //=====================================================================
    // FUNCIÓN: createAOE (COMPLETA)
    //=====================================================================
    /**
     * Crea un efecto de Área de Efecto (AoE) en una posición dada.
     * @param {THREE.Object3D} caster - Quien lanza el AoE.
     * @param {THREE.Vector3} targetPos - La posición central del AoE.
     * @param {string} type - El ID del hechizo AoE (ej: 'poison_cloud', 'fire_storm').
     * @param {boolean} [instantDamage=false] - Si true, aplica el daño una vez al crear el AoE.
     */
    function createAOE(caster, targetPos, type, instantDamage = false) {
         const spellDef = spellDefinitions[type]; if (!spellDef) return;
         console.log(`Creando AoE: ${type} en ${targetPos.x.toFixed(1)},${targetPos.z.toFixed(1)}`);

         const radius = spellDef.radius || 3;
         const duration = spellDef.duration || 5; // segundos
         const tickTime = spellDef.tickTime || 1.0; // segundos
         const damagePerTick = spellDef.damagePerTick || { amount: 0, type: spellDef.element || 'magic' };
         const instantDamageData = {amount: Math.floor(Math.random()*(spellDef.damageMax-spellDef.damageMin+1))+spellDef.damageMin, type: spellDef.element || 'magic'};
         const effectToApply = spellDef.statusEffect;

         // Crear visual del AoE (Círculo en el suelo)
         const aoeGeometry = new THREE.CircleGeometry(radius, 32); // Más segmentos para círculo suave
         const aoeMaterial = new THREE.MeshStandardMaterial({
             color: spellDef.element === 'poison' ? 0x339933 : (spellDef.element === 'fire' ? 0xff8800 : (spellDef.element === 'shadow' ? 0x581845 : 0xaaaaaa)),
             transparent: true, opacity: 0.45, // Ligeramente más opaco
             side: THREE.DoubleSide,
             depthWrite: false // Evitar problemas de Z-fighting con el suelo
         });
         const aoeMesh = new THREE.Mesh(aoeGeometry, aoeMaterial);
         aoeMesh.position.copy(targetPos);
         // Asegurar que esté plano sobre el terreno
         aoeMesh.position.y = ChunkManager.getTerrainHeightAt(targetPos.x, targetPos.z) + 0.05; // Muy pegado al suelo
         aoeMesh.rotation.x = -Math.PI / 2;
         scene.add(aoeMesh);

         const startTime = Date.now();

         const aoeData = {
              type: 'aoe', spellType: type, caster: caster,
              position: targetPos.clone(), radiusSq: radius * radius,
              endTime: startTime + duration * 1000,
              duration: duration * 1000, // Guardar duración total en ms
              startTime: startTime,        // Guardar tiempo de inicio
              tickTime: tickTime * 1000,
              damagePerTick: damagePerTick,
              effectToApply: effectToApply,
              mesh: aoeMesh,
              lastTickTime: startTime, // Iniciar tick inmediatamente
              instantDamage: instantDamage ? instantDamageData : null // Guardar daño instantáneo si aplica
         };
         world.activeAOEs.push(aoeData); // Añadir a lista de AoEs activos

         // Aplicar daño instantáneo si corresponde
         if (aoeData.instantDamage && aoeData.instantDamage.amount > 0) {
              console.log(`Applying instant AoE damage: ${aoeData.instantDamage.amount}`);
              const targets = (aoe.caster === playerModel) ? world.enemies : [playerModel]; // Simplificado
              targets.forEach(target => {
                   if (target?.userData && !target.userData.isDead && target.position.distanceToSquared(aoe.position) < aoe.radiusSq) {
                        applyDamage(target, aoeData.instantDamage.amount, aoeData.instantDamage.type, false); // Crítico en AoE? Opcional
                   }
              });
         }

         // Efecto visual inicial
         createImpactEffect(targetPos, spellDef.particleColor || aoeMaterial.color.getHex());
         // Sonido inicial del AoE?
         // AudioManager.playSound(`aoe_${spellDef.element}_start`);
    }

    /**
     * Actualiza los AoE activos, aplicando daño/efectos por tick y eliminándolos.
     * (v2 - Corregido tick y añadido efecto visual fade out)
     * @param {number} deltaTime
     */
    function updateAOEs(deltaTime) {
         const now = Date.now();
         for (let i = world.activeAOEs.length - 1; i >= 0; i--) {
              const aoe = world.activeAOEs[i];
              if (!aoe || !aoe.mesh) { // Check si el AoE o su malla son inválidos
                  world.activeAOEs.splice(i, 1); continue;
              }

              const timeElapsed = now - aoe.startTime;
              const remainingTime = aoe.endTime - now;

              // Eliminar si terminó duración
              if (remainingTime <= 0) {
                  if (aoe.mesh.parent) scene.remove(aoe.mesh);
                  // Limpiar geometría/material de la malla AoE
                  if(aoe.mesh.geometry) aoe.mesh.geometry.dispose();
                  if(aoe.mesh.material instanceof THREE.Material) aoe.mesh.material.dispose();
                  world.activeAOEs.splice(i, 1);
                  continue;
              }

              // Procesar Tick de Daño/Efecto (si no es daño instantáneo)
              if (aoe.tickTime > 0 && !aoe.instantDamage && now - aoe.lastTickTime >= aoe.tickTime) {
                   aoe.lastTickTime = now;
                   // Determinar objetivos (Jugador vs Enemigos basado en caster)
                   const potentialTargets = (aoe.caster === playerModel)
                        ? world.enemies.filter(e => e?.userData && !e.userData.isDead && e.visible) // Enemigos vivos
                        : (!gameState.isGhost && playerModel ? [playerModel] : []); // Solo jugador si no es fantasma

                   potentialTargets.forEach(target => {
                        if (target?.position && target.position.distanceToSquared(aoe.position) < aoe.radiusSq) {
                             // Aplicar daño del tick
                             if (aoe.damagePerTick?.amount > 0) {
                                  applyDamage(target, aoe.damagePerTick.amount, aoe.damagePerTick.type || 'magic', false);
                             }
                             // Aplicar efecto de estado (si lo hay)
                             if (aoe.effectToApply) {
                                  const effectDef = window[`${aoe.effectToApply.toUpperCase()}_EFFECT_DATA`];
                                  if (effectDef) {
                                      // Aplicar con duración corta (ej: duración del tick + pequeño margen)
                                      addStatusEffectToTarget(target.userData || playerState, { ...effectDef, duration: (aoe.tickTime / 1000) + 0.5 });
                                  }
                             }
                        }
                   });
              }

               // Animar opacidad/escala del AoE visual para fade out
               if (aoe.mesh.material instanceof THREE.Material) {
                    const lifeRatio = Math.max(0, remainingTime / aoe.duration); // Ratio 1 a 0
                    aoe.mesh.material.opacity = 0.1 + 0.35 * lifeRatio * lifeRatio; // Fade out cuadrático
                    // Opcional: encoger el radio visualmente
                    // aoe.mesh.scale.setScalar(lifeRatio);
               }
         }
     }

/**
 * Bucle principal de actualización del juego. Llamado por requestAnimationFrame.
 * Orquesta todas las actualizaciones lógicas y visuales del juego.
 * (v9 - Lógica Fantasma Integrada y Carga de Chunks Corregida)
 * @param {number} deltaTime - Tiempo transcurrido desde el último frame en segundos.
 */
function updateGame(deltaTime) {
    // --- 0. Inicio del Frame y Validación Global ---
    // Si isLoading es true, el juego aún no ha comenzado realmente, no hacer nada.
    // Si !isPlaying, el juego se ha detenido (ej. vuelto al menú), no hacer nada.
    if (gameState.isLoading || !gameState.isPlaying) {
        return;
    }

    frameCount++; // Contador de frames global
    gameState.gameTime += deltaTime; // Actualizar tiempo total de juego

    // --- 1. Actualizaciones Visuales Persistentes (Siempre, incluso Pausado) ---
    //    (Para mantener la atmósfera visual o efectos continuos)
    updateTimeOfDay(deltaTime); // Actualiza posición sol/luna, intensidad luces, color niebla/fondo
    updateWeather(deltaTime);   // Actualiza tipo/intensidad clima, efectos globales de niebla/lluvia/nieve
    updateParticles(deltaTime); // Actualiza posición/vida de partículas 2D (texto flotante, clima)

    // --- 2. Actualización del Chunk Manager (SIEMPRE si se está jugando, independientemente de Pausa o Fantasma) ---
    //    Utiliza la posición ACTUAL del jugador (sea normal o fantasma)
    //    para decidir qué chunks cargar/descargar.
    if (playerState?.position) { // Asegurar que la posición exista
        ChunkManager.update(playerState.position);
    } else {
        if (!updateGame.warnedPlayerPosMissing) { // Advertir solo una vez
            console.warn("updateGame: playerState.position no definido, ChunkManager no se puede actualizar.");
            updateGame.warnedPlayerPosMissing = true;
        }
    }
    updateGame.warnedPlayerPosMissing = !!playerState?.position; // Resetear advertencia si la posición existe


    // --- 3. Lógica Principal del Juego (Solo si NO está pausado) ---
    if (!gameState.isPaused) {

        // --- 3.a Lógica del Estado Normal (No Fantasma) ---
        if (!gameState.isGhost) {
            // Verificar si el jugador murió en este frame
            if (playerState?.stats?.health <= 0 && !gameState.isGameOver) {
                playerDeath(); // Inicia el proceso de muerte (pone isGhost=true)
                // NO continuar con el resto de la lógica normal en este frame
                // El próximo frame entrará en la lógica fantasma
            } else if (!gameState.isGameOver) { // Solo si no está muerto
                // --- Actualizaciones de Entidades y Mundo (Normal) ---

                // - Jugador:
                updatePlayer(deltaTime); // Movimiento, Regeneración, Estado Bloqueo/Parry/Esquiva, Sonidos pasos

                // - Enemigos (IA con Throttling):
                if (frameCount % AI_UPDATE_THROTTLE === 0) {
                    updateEnemies(deltaTime * AI_UPDATE_THROTTLE); // Pasar deltaTime acumulado
                }

                // - Proyectiles:
                updateProjectiles(deltaTime);

                // - Efectos de Estado (Jugador):
                updateStatusEffects(deltaTime);

                // - Enfriamientos Hechizos:
                updateSpellCooldowns(deltaTime);

                // - Animación Items en Suelo:
                updateWorldItemsAnimation(deltaTime);

                // - Comprobación de Interacciones Cercanas:
                checkInteractions(); // Actualiza gameState.targetEntity

                // - Marcadores de Misión en NPCs (Throttled):
                if (frameCount % 20 === 0) {
                    updateNPCMarkers();
                }

                // - Áreas de Efecto (AoE):
                updateAOEs(deltaTime);

                // - Despawn Items en Suelo (Throttled):
                 if (frameCount % 15 === 0) { // Igual que UI para agrupar
                     updateWorldItemDespawn();
                 }
            }
        }
        // --- 3.b Lógica del Estado Fantasma ---
        else { // gameState.isGhost es true
            // - Movimiento Etéreo Fantasma:
            updatePlayerMovement(deltaTime, 1.2); // Movimiento base, +20% velocidad

            // - Física Simplificada Fantasma (Mantenerse sobre terreno):
            const terrainHeight = getGroundHeightAt(playerState.position.x, playerState.position.z);
            const ghostFloatHeight = 0.4; // Altura sobre el suelo
            playerState.position.y = Math.max(terrainHeight + ghostFloatHeight, playerState.position.y + playerState.velocity.y * deltaTime); // Aplicar mínima vel vertical y asegurar altura
            playerState.velocity.y *= 0.85; // Amortiguar velocidad vertical
            playerState.onGround = (playerState.position.y <= terrainHeight + ghostFloatHeight + 0.1);

            // Sincronizar modelo fantasma
            if (playerModel) {
                playerModel.position.copy(playerState.position);
                playerModel.rotation.y = playerState.rotationY;
            }

            // - Comprobar Interacción Fantasma (con Sacerdotes):
            checkGhostInteractions(); // Busca sacerdotes y actualiza targetEntity
        }

        // --- 3.c Actualizaciones UI Principales (Throttled, pero ocurren sin importar fantasma) ---
        if (frameCount % 15 === 0) { // ~4 FPS para UI
            updateMinimap();             // Minimapa sidebar (o móvil si aplica)
            updatePlayerUI();            // Barras jugador, nombre, oro, XP, efectos
            updateActionSlotsUI();       // Hotbar
            updateQuestTrackerUI();      // Tracker misión activa
            updateTargetUI();            // Info del objetivo (sea enemigo, NPC, o sacerdote como fantasma)
        }
        // Actualizar barra superior móvil con más frecuencia si es visible
        if (domCache['mobile-ui-container']?.style.display !== 'none' && frameCount % 5 === 0) {
            updateMobileTopBar();
        }

    } // --- Fin del Bloque if (!gameState.isPaused) ---

    // --- 4. Actualizaciones Visuales Finales (SIEMPRE, incluso pausado) ---

    // - Actualizar Posición Cámara: Siempre sigue al jugador (normal o fantasma)
    updateCameraPosition(deltaTime);

    // - Actualizar Animation Mixers: Pasar 0 si está pausado
    const dtMixer = gameState.isPaused ? 0 : deltaTime;
    if (playerState.mixer) {
        try { playerState.mixer.update(dtMixer); }
        catch(e) { console.error("Error actualizando player mixer:", e); playerState.mixer = null; } // Evitar crasheos
    }
    // Actualizar mixers de enemigos/NPCs (estos ya no deberían estar en un array global, sino en world.enemies/npcs)
    world.enemies.forEach(enemy => { if(enemy?.userData?.mixer) try{ enemy.userData.mixer.update(dtMixer); } catch(e){ console.error(`Error mixer enemigo ${enemy.userData?.name}:`, e); enemy.userData.mixer = null; } });
    world.npcs.forEach(npc => { if(npc?.userData?.mixer) try{ npc.userData.mixer.update(dtMixer); } catch(e){ console.error(`Error mixer NPC ${npc.userData?.name}:`, e); npc.userData.mixer = null; } });
    // Limpiar animationMixers si aún se usa (mejor eliminarlo)
    if (Array.isArray(window.animationMixers)) window.animationMixers = [];


    // - Actualizar OrbitControls (Para Damping): SIEMPRE al final
    if (orbitControls?.enableDamping) {
        try { orbitControls.update(); } catch(e) { console.error("Error en orbitControls.update():", e); }
    }

    // --- 5. Acciones Periódicas (Solo si JUEGA y NO PAUSADO) ---
    if (gameState.isPlaying && !gameState.isPaused) {
        // - Guardado Automático:
        if (gameState.gameTime - gameState.lastSaveTime > SAVE_INTERVAL) {
            saveGame(); // saveGame ya comprueba si es fantasma
        }

        // - Actualizar Música (Throttled):
        if (frameCount % 60 === 0) { // Comprobar cambio de música cada segundo aprox.
            AudioManager.updateMusic();
        }
    }

} // --- Fin updateGame (v9) ---
// Inicializar flags de advertencia para la función
updateGame.warnedPlayerPosMissing = false;


function updateTimeOfDay(deltaTime) {
        gameState.timeOfDay += deltaTime / (DAY_NIGHT_DURATION_MS / 1000);
        if (gameState.timeOfDay >= 1) gameState.timeOfDay -= 1;
        const sunAngle = (gameState.timeOfDay - 0.25) * Math.PI * 2;
        const sunHeight = Math.sin(sunAngle);
        const moonAngle = sunAngle + Math.PI;
        const moonHeight = Math.sin(moonAngle);

        // Update light positions and intensities
        scene.traverse((object) => {
            if (!(object instanceof THREE.Light)) return;
            const type = object.userData.type;
            if (type === 'sun') {
                object.position.y = Math.max(0, sunHeight) * 120;
                object.position.x = Math.cos(sunAngle) * 100;
                object.position.z = Math.sin(sunAngle + Math.PI / 4) * 80;
                object.target.position.set(0,0,0);
                object.intensity = Math.max(0, sunHeight) * 1.0; // Adjusted intensity
                object.castShadow = object.intensity > 0.05;
            } else if (type === 'moon') {
                object.position.y = Math.max(0, moonHeight) * 100;
                object.position.x = Math.cos(moonAngle) * 100;
                object.position.z = Math.sin(moonAngle + Math.PI / 4) * 60;
                object.target.position.set(0,0,0);
                object.intensity = Math.max(0, moonHeight) * 0.20; // Adjusted intensity
            } else if (type === 'ambient') {
                const dayAmbient = 0.40; const nightAmbient = 0.15;
                object.intensity = nightAmbient + Math.max(0, sunHeight) * (dayAmbient - nightAmbient);
            } else if (type === 'player_light' && playerLight) {
                 // Turn on player light only when it's dark enough
                 playerLight.intensity = sunHeight < -0.15 ? 1.0 : 0;
            }
        });

        // Update background and fog color based on sun height (lerp)
        const nightColor = new THREE.Color(0x050810);
        const dayColor = new THREE.Color(0x10151b);
        const lerpFactor = (Math.max(0, sunHeight) + 1) / 2; // Factor from 0.5 (night) to 1.0 (day peak)

        let currentBgColor = dayColor.clone(); // Start with day color
        currentBgColor.lerp(nightColor, 1 - lerpFactor); // Lerp towards night color
        scene.background = currentBgColor;

        // Update fog only if weather is not controlling it
        if (scene.fog instanceof THREE.Fog && gameState.weather === 'clear') {
             scene.fog.color.copy(currentBgColor);
             const fogDensityFactor = 1.0 - Math.abs(Math.sin(sunAngle + Math.PI/2)) * 0.5;
             scene.fog.near = 80 * fogDensityFactor;
             scene.fog.far = 280 * fogDensityFactor;
        }
    }

    function updateWeather(deltaTime) {
         if (!gameState.isLoading && gameState.gameTime - gameState.lastWeatherChange > gameState.weatherDuration) {
            const weatherTypes = ['clear', 'rain', 'snow']; // Add 'fog', 'storm'?
            const weights = [0.6, 0.3, 0.1]; // Probabilities
            let newWeather = 'clear'; const rand = Math.random(); let cumulativeWeight = 0;
            for (let i = 0; i < weatherTypes.length; i++) { cumulativeWeight += weights[i]; if (rand <= cumulativeWeight) { newWeather = weatherTypes[i]; break; } }
            // Prevent immediately repeating the same non-clear weather
            if (newWeather !== 'clear' && newWeather === gameState.weather) newWeather = 'clear';

            const intensity = 0.3 + Math.random() * 0.7; // Random intensity
            world.weatherSystem.setWeather(newWeather, intensity);
            gameState.lastWeatherChange = gameState.gameTime;
            gameState.weatherDuration = WEATHER_DURATION_MIN + Math.random() * (WEATHER_DURATION_MAX - WEATHER_DURATION_MIN);
            if (newWeather !== 'clear') {
                 const weatherNames = { rain: 'lluvia', snow: 'nieve' };
                 logMessage(`El clima ha cambiado. Comienza a caer ${weatherNames[newWeather]}.`, 'system');
                 // TODO: Apply gameplay effects (reduced visibility handled in setWeather, add others)
                 // if (newWeather === 'snow') playerState.stats.moveSpeedMultiplier *= 0.9; // Example slowdown
            } else if (gameState.weather !== 'clear') {
                 logMessage('El clima ha mejorado. El cielo se despeja.', 'system');
                 // TODO: Remove gameplay effects
                 // playerState.stats.moveSpeedMultiplier = 1.0; // Restore speed
                 // updatePlayerStats(); // Recalculate if multipliers changed
            }
        }
        // Update particle positions if weather is active
         if(world.weatherSystem.active) {
             world.weatherSystem.update(deltaTime);
         }
    }

    function updatePlayer(deltaTime) {
        if (!playerModel || !playerState.position) return;
        if (gameState.isGhost) return; // Handled in ghost loop
        if (playerState.stats.health <= 0) { playerDeath(); return; }

        updatePlayerMovement(deltaTime);
        handleBlocking(deltaTime); // Process blocking and parry window logic
        // playPlayerAnimation(determinePlayerAnimationState()); // Update animation based on state
        updatePlayerRegeneration(deltaTime);

        // Sync 3D model
        playerModel.position.copy(playerState.position);
        playerModel.rotation.y = playerState.rotationY;
        if (playerCollider instanceof THREE.Box3) { playerCollider.setFromCenterAndSize(playerState.position, new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2)); }
        if (playerLight && playerLight.intensity > 0) { playerLight.position.copy(playerState.position).add(new THREE.Vector3(0, 1.2, 0)); }

        AudioManager.playFootstep(); // Play sounds based on movement

        // Handle interaction check result (actual interaction happens on key press/click)
        // checkInteractions() is called in updateGame loop to update targetEntity

        // Consume interact flag if used (e.g., by checkInteractions finding something)
         if (controls.interact && gameState.targetEntity?.userData.interactable) {
             if (gameState.targetEntity.position.distanceToSquared(playerState.position) < INTERACT_DISTANCE_SQ * 1.1) {
                 if (typeof gameState.targetEntity.userData.interact === 'function') {
                     gameState.targetEntity.userData.interact(); // Call interact function
                     controls.interact = false; // Consume interact press after successful call
                 }
             } else {
                  // Optionally log "too far" if interact is pressed but out of range
             }
         }
    }

    function handleBlocking(deltaTime) {
        const wasBlocking = playerState.isBlocking;
        const tryingToBlock = controls.block && !playerState.isChargingAttack && !playerState.isAttacking && !playerState.isDodging;

        if (tryingToBlock && !wasBlocking && playerState.stats.stamina > 0) {
            playerState.isBlocking = true;
            playerState.blockStartTime = Date.now();
            playerState.isParrying = true;
            console.log("Block Started. Parry Active.");
        } else if (!tryingToBlock && wasBlocking) {
            playerState.isBlocking = false;
            playerState.isParrying = false;
             console.log("Block Ended.");
        }

        if (playerState.isBlocking) {
            if (playerState.isParrying && Date.now() - playerState.blockStartTime > PARRY_WINDOW) {
                playerState.isParrying = false;
                 console.log("Parry Window Closed.");
            }
            playerState.stats.stamina -= BLOCK_STAMINA_COST_PER_SEC * deltaTime;
            if (playerState.stats.stamina <= 0) {
                playerState.stats.stamina = 0; playerState.isBlocking = false; playerState.isParrying = false;
                controls.block = false; logMessage("Sin resistencia para bloquear.", "warning"); AudioManager.playSound('ui_error', 0.4);
                 console.log("Block Ended (Out of Stamina).");
            }
        }
    }

    /**
     * Actualiza la posición y velocidad del jugador basándose en los inputs y el estado actual.
     * Maneja movimiento normal, sprint, salto, gravedad, colisiones simples y movimiento fantasma.
     * (v6 - Lógica Fantasma integrada, Colisión Simplificada)
     * @param {number} deltaTime - Tiempo transcurrido desde el último frame.
     * @param {number} [speedMultiplier=1.0] - Multiplicador opcional de velocidad (usado para fantasma/efectos).
     */
    function updatePlayerMovement(deltaTime, speedMultiplier = 1.0) {
        // --- Validaciones ---
        if (!playerModel || !playerState || !playerState.position || !playerState.velocity || !playerState.stats || !camera) {
             console.warn("updatePlayerMovement: Faltan datos esenciales.");
             return;
        }
        // Si está en modo normal y pausado, o esquivando, no procesar movimiento normal
        if (!gameState.isGhost && (gameState.isPaused || !gameState.isPlaying || playerState.isDodging)) {
            if (!playerState.isDodging) { // Detener movimiento horizontal si no esquiva
                 playerState.isMoving = false;
                 playerState.velocity.x = 0;
                 playerState.velocity.z = 0;
            }
            // Aplicar gravedad si está en el aire (incluso pausado?) - Quizás no deseado si está pausado
            if (!playerState.onGround && !playerState.isDodging) {
                 playerState.velocity.y += GRAVITY * deltaTime;
                 playerState.position.y += playerState.velocity.y * deltaTime; // Aplicar caída simple
                 // Comprobar colisión con suelo si está pausado y cae
                 const terrainHeight = ChunkManager.getTerrainHeightAt(playerState.position.x, playerState.position.z);
                 if (playerState.position.y - PLAYER_HALF_HEIGHT < terrainHeight) {
                      playerState.position.y = terrainHeight + PLAYER_HALF_HEIGHT;
                      playerState.velocity.y = 0;
                 }
            }
            return; // Salir si no debe procesar movimiento normal/fantasma
        }

        // --- Lógica de Movimiento (Normal y Fantasma) ---
        let moveDirection = new THREE.Vector3(0, 0, 0);
        let inputMagnitude = 0;
        let isInputActive = false;
        let targetRotationY = playerState.rotationY;
        let keyboardRotate = 0;

        // Determinar Input (Joystick o Teclado)
        if (joystickActive && joystickMagnitude > 0.1) {
            // Joystick (Código sin cambios)
            isInputActive = true; inputMagnitude = joystickMagnitude;
            const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection);
            const forward = new THREE.Vector3(cameraDirection.x, 0, cameraDirection.z).normalize();
            const right = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forward).normalize();
            moveDirection.addScaledVector(forward, joystickVector.y).addScaledVector(right, -joystickVector.x);
            if (moveDirection.lengthSq() > 0.001) { moveDirection.normalize(); targetRotationY = normalizeAngle(Math.atan2(moveDirection.x, moveDirection.z) + Math.PI); }
            else { inputMagnitude = 0; }
        } else {
            // Teclado (Procesa flags de controls)
            let keyboardMoveZ = (controls.moveForward ? 1 : 0) + (controls.moveBackward ? -1 : 0);
            keyboardRotate = (controls.turnLeft ? 1 : 0) + (controls.turnRight ? -1 : 0);

            if (keyboardRotate !== 0) {
                // Rotar jugador (funciona igual para fantasma y normal)
                targetRotationY = normalizeAngle(playerState.rotationY + keyboardRotate * ROTATION_SPEED * deltaTime);
                isInputActive = true;
            }
            if (keyboardMoveZ !== 0) {
                // Mover jugador (funciona igual para fantasma y normal)
                isInputActive = true;
                inputMagnitude = 1.0;
                const playerForward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), playerState.rotationY);
                moveDirection.copy(playerForward).multiplyScalar(keyboardMoveZ);
            }
        }
        // Actualizar estado 'isMoving'
        playerState.isMoving = (inputMagnitude > 0.01);

        // Rotar Modelo del Jugador (Lerp suave)
        if (Math.abs(normalizeAngle(targetRotationY - playerState.rotationY)) > 0.001) {
             const turnLerpFactor = Math.min(1.0, (joystickActive ? 9.0 : 15.0) * deltaTime);
             playerState.rotationY = lerpAngle(playerState.rotationY, targetRotationY, turnLerpFactor);
        }

        // --- Calcular Velocidad Horizontal ---
        let currentSpeed = (playerState.stats.moveSpeed || MOVE_SPEED_BASE) * inputMagnitude * speedMultiplier; // Aplicar multiplicador (para fantasma)
        let wantsToSprint = controls.sprint || (joystickActive && mobileSprintToggleActive && inputMagnitude > 0.1);
        let canSprint = false;

        // Lógica de Sprint (Solo si NO es fantasma)
        if (!gameState.isGhost) {
             canSprint = playerState.isMoving && wantsToSprint && playerState.stats.stamina > 0 && !playerState.isBlocking && !playerState.isDodging;
             playerState.isSprinting = canSprint;
             if (playerState.isSprinting) {
                 currentSpeed = (playerState.stats.moveSpeed || MOVE_SPEED_BASE) * SPRINT_MULTIPLIER * speedMultiplier; // Sprint + multiplicador general
                 playerState.stats.stamina -= SPRINT_STAMINA_COST_PER_SEC * deltaTime;
                 if (playerState.stats.stamina <= 0) {
                      playerState.stats.stamina = 0; playerState.isSprinting = false;
                      if(joystickActive) { mobileSprintToggleActive = false; domCache['mobile-sprint-toggle-btn']?.classList.remove('sprint-active'); }
                      logMessage("Correr desactivado por falta de resistencia.", "warning");
                 }
             }
             // Reducir velocidad si bloquea (solo si no es fantasma)
             if (playerState.isBlocking) currentSpeed *= 0.5;
        } else {
             // Sprint fantasma (si se permite en handleKeyDown)
             playerState.isSprinting = playerState.isMoving && wantsToSprint;
             if (playerState.isSprinting) {
                  currentSpeed = (playerState.stats.moveSpeed || MOVE_SPEED_BASE) * SPRINT_MULTIPLIER * speedMultiplier * 1.2; // Sprint fantasma más rápido?
             }
        }

        // Aplicar efectos de clima (ralentización) - Incluso a fantasmas? Opcional.
        // if (gameState.weather === 'snow') currentSpeed *= (1.0 - gameState.weatherIntensity * 0.3);

        // Establecer Velocidad Horizontal (XZ)
        playerState.velocity.x = moveDirection.x * currentSpeed;
        playerState.velocity.z = moveDirection.z * currentSpeed;

      // --- Lógica Vertical (Salto, Gravedad) ---
        if (!gameState.isGhost) {
            // Gravedad
            if (!playerState.onGround) { playerState.velocity.y += GRAVITY * deltaTime; }
            // Salto
            const canJump = controls.jump && playerState.onGround && !playerState.isJumping && playerState.stats.stamina >= JUMP_STAMINA_COST && !playerState.isBlocking && !playerState.isDodging;
            if (canJump) { playerState.velocity.y = JUMP_VELOCITY; playerState.onGround = false; playerState.isJumping = true; playerState.stats.stamina -= JUMP_STAMINA_COST; AudioManager.playSound('jump', 0.5); controls.jump = false; if (playerState.isChargingAttack) { playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0; controls.isAttackKeyDown = false; logMessage("Carga cancelada por salto.", "info");} }
            if (playerState.isJumping && playerState.velocity.y <= 0) { playerState.isJumping = false; }
            // Esquivar (ya manejado arriba)
        } else { // Lógica vertical fantasma
             playerState.velocity.y *= 0.90; playerState.velocity.y += GRAVITY * deltaTime * 0.3;
        }

        // --- Aplicar Movimiento y Colisiones ---
        const deltaPosition = playerState.velocity.clone().multiplyScalar(deltaTime);
        const potentialPosition = playerState.position.clone().add(deltaPosition);

        // <<< MODIFICADO: Colisión con Suelo (Usa nueva función) >>>
        const groundHeight = getGroundHeightAt(potentialPosition.x, potentialPosition.z);
        const feetOffset = gameState.isGhost ? -0.3 : PLAYER_HALF_HEIGHT; // Fantasma flota
        const potentialFeetY = potentialPosition.y - PLAYER_HALF_HEIGHT; // Dónde estarían los pies
        let correctedY = potentialPosition.y;
        let landed = false;

        if (!gameState.isGhost && potentialFeetY < groundHeight) {
            correctedY = groundHeight + PLAYER_HALF_HEIGHT;
            if (playerState.velocity.y < -1.0 && !playerState.onGround) landed = true;
            playerState.velocity.y = 0; playerState.onGround = true;
        } else if (gameState.isGhost) {
            correctedY = Math.max(groundHeight + 0.3, potentialPosition.y); playerState.onGround = false;
        } else { playerState.onGround = false; }
        potentialPosition.y = correctedY;

        // <<< MODIFICADO: Colisión Estática (Mundo y Dungeon) >>>
        if (!gameState.isGhost && playerCollider) { // Fantasma ignora colisión estática
            const playerPotentialBox = playerCollider.clone().translate(deltaPosition); // Mover collider lógico
            let collisionCandidates = [];

            if (gameState.currentLocation === 'world') {
                // En el mundo, buscar en chunks activos como antes
                 const playerChunkX = ChunkManager.playerChunkCoords.x; const playerChunkZ = ChunkManager.playerChunkCoords.z; const checkDist = 1;
                 for (let dx = -checkDist; dx <= checkDist; dx++) { for (let dz = -checkDist; dz <= checkDist; dz++) { const chunk = ChunkManager.activeChunks.get(`${playerChunkX + dx}_${playerChunkZ + dz}`); if (chunk?.objects) { collisionCandidates.push(...chunk.objects.filter(o => o && o !== playerModel && o.visible && o.userData?.boundingBox && o.userData.type !== 'terrain_chunk' && o.userData.type !== 'water')); } } }
            } else {
                // En dungeon, buscar objetos en world.objects marcados con el dungeonId actual
                 collisionCandidates = world.objects.filter(obj =>
                     obj && obj !== playerModel && obj.visible && obj.userData?.boundingBox &&
                     obj.userData.dungeonId === gameState.currentLocation &&
                     (obj.userData.type === 'dungeon_structure' || obj.userData.type === 'dungeon_walls' || obj.userData.type === 'chest' /* añadir otros tipos colisionables */)
                 );
            }

            // Resolver Colisión
            for (const staticObj of collisionCandidates) {
                 if (staticObj.userData.boundingBox instanceof THREE.Box3 && playerPotentialBox.intersectsBox(staticObj.userData.boundingBox)) {
                     // Colisión detectada, resolver por eje
                     const testBoxX = playerCollider.clone().translate(new THREE.Vector3(deltaPosition.x, 0, 0));
                     if (testBoxX.intersectsBox(staticObj.userData.boundingBox)) {
                          potentialPosition.x = playerState.position.x; playerState.velocity.x = 0;
                     }
                     const testBoxZ = playerCollider.clone().translate(new THREE.Vector3(0, 0, deltaPosition.z));
                      if (testBoxZ.intersectsBox(staticObj.userData.boundingBox)) {
                          potentialPosition.z = playerState.position.z; playerState.velocity.z = 0;
                     }
                     if (potentialPosition.x === playerState.position.x || potentialPosition.z === playerState.position.z) break; // Salir si ya se resolvió
                 }
            }
        }

        // --- Aplicar Posición Final y Limitar a Bordes ---
        playerState.position.copy(potentialPosition);
        if (gameState.currentLocation === 'world') { // Limitar solo en overworld
            const bounds = world.worldBounds;
            playerState.position.x = Math.max(bounds.minX + PLAYER_RADIUS, Math.min(bounds.maxX - PLAYER_RADIUS, playerState.position.x));
            playerState.position.z = Math.max(bounds.minZ + PLAYER_RADIUS, Math.min(bounds.maxZ - PLAYER_RADIUS, playerState.position.z));
        } else { // Dentro del dungeon, usar límites del layout si existen
             const layout = dungeonDefinitions[gameState.currentLocation]?.layout;
             if (layout?.type === 'box' && layout.size) {
                 const [width, , depth] = layout.size;
                 const halfW = width / 2 - PLAYER_RADIUS; const halfD = depth / 2 - PLAYER_RADIUS;
                 playerState.position.x = Math.max(-halfW, Math.min(halfW, playerState.position.x));
                 playerState.position.z = Math.max(-halfD, Math.min(halfD, playerState.position.z));
             }
        }

        // Sonido de aterrizaje
        if (landed && !gameState.isGhost) AudioManager.playSound('land', 0.4 + Math.abs(playerState.velocity.y) * 0.02);
    }
    function normalizeAngle(angle) { while (angle <= -Math.PI) angle += Math.PI * 2; while (angle > Math.PI) angle -= Math.PI * 2; return angle; }
    function lerpAngle(startAngle, endAngle, t) { const delta = normalizeAngle(endAngle - startAngle); return normalizeAngle(startAngle + delta * t); }
    function smoothLerpAngle(startAngle, endAngle, t) { const delta = normalizeAngle(endAngle - startAngle); const smoothT = t * t * (3 - 2 * t); return normalizeAngle(startAngle + delta * smoothT); }

    function playPlayerAnimation(animationName, crossfadeDuration = 0.25, loop = true, timeScale = 1.0) {
        if (!playerState.mixer || !playerState.animations) return;
        const nameLower = animationName.toLowerCase();
        // Fallback logic: try variations if exact name not found
        const clip = playerState.animations[nameLower]
                  || playerState.animations[nameLower.replace('_', '')] // Try removing underscore
                  || playerState.animations[nameLower + '_base'] // Try adding _base
                  || playerState.animations['idle'] // Ultimate fallback to idle
                  || Object.values(playerState.animations)[0]; // Last resort: first animation

        if (!clip) { console.warn(`Animación jugador no encontrada ni fallback: ${animationName}`); return; }

        const mixer = playerState.mixer; let currentAction = playerState.currentAction || null;
        const targetAction = mixer.clipAction(clip);

        if (currentAction === targetAction && targetAction.loop === THREE.LoopRepeat && targetAction.isRunning()) {
             if(targetAction.timeScale !== timeScale) targetAction.setEffectiveTimeScale(timeScale);
             return; // Already playing the correct looping animation
        }

        targetAction.reset(); targetAction.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, loop ? Infinity : 1);
        targetAction.clampWhenFinished = !loop; targetAction.setEffectiveTimeScale(timeScale); targetAction.weight = 1;

        if (currentAction && currentAction.isRunning()) { currentAction.crossFadeTo(targetAction, crossfadeDuration, true); }
        targetAction.play();
        playerState.currentAction = targetAction; // Store current action
    }


function updateCameraPosition(deltaTime) {
        // --- 1. Validaciones Esenciales ---
        if (!camera || !orbitControls || !playerModel || !playerState || !playerState.position) {
            return;
        }

        // --- 2. Actualizar el Objetivo (Target) de OrbitControls ---
        const targetLookAtPosition = playerState.position.clone().add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.9, 0));
        const lerpFactorTarget = 10 * deltaTime; // Velocidad de seguimiento del objetivo
        orbitControls.target.lerp(targetLookAtPosition, lerpFactorTarget);

        // --- 3. Determinar si el Modo "Follow Cam" debe activarse ---
        const isMovingWithKeyboard = !joystickActive && playerState.isMoving;
        const isRotatingWithKeyboard = !joystickActive && (controls.turnLeft || controls.turnRight);
        const followCamActive = joystickActive || isMovingWithKeyboard || isRotatingWithKeyboard;

        // --- 4. Lógica de Posicionamiento de la Cámara ---
        if (followCamActive) {
            // === MODO FOLLOW CAM ACTIVO ===
            // a. Calcular Posición DESEADA
            const desiredOffset = cameraOffset.clone();
            desiredOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerState.rotationY);
            const desiredCameraPosition = playerState.position.clone().add(desiredOffset);

            // b. Comprobar Colisiones (Raycast)
            const rayOrigin = playerState.position.clone().add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.8, 0));
            const rayDirection = new THREE.Vector3().subVectors(desiredCameraPosition, rayOrigin).normalize();
            const maxDistance = cameraOffset.length();
            // Reutilizar raycaster global o crear uno específico si hay concurrencia
             if (!window.collisionRaycasterCam) window.collisionRaycasterCam = new THREE.Raycaster();
             window.collisionRaycasterCam.set(rayOrigin, rayDirection);
             window.collisionRaycasterCam.near = 0.2;
             window.collisionRaycasterCam.far = maxDistance;

             // Obtener chunks activos y sus objetos para colisión
             const collisionCandidates = [ChunkManager.activeChunks.get(`${ChunkManager.playerChunkCoords.x}_${ChunkManager.playerChunkCoords.z}`)?.terrainMesh];
             for(let dx = -1; dx <= 1; dx++) {
                 for(let dz = -1; dz <= 1; dz++) {
                      const chunk = ChunkManager.activeChunks.get(`${ChunkManager.playerChunkCoords.x+dx}_${ChunkManager.playerChunkCoords.z+dz}`);
                      if (chunk?.terrainMesh && chunk.terrainMesh !== collisionCandidates[0]) collisionCandidates.push(chunk.terrainMesh);
                      if (chunk?.objects) collisionCandidates.push(...chunk.objects.filter(o => o?.userData?.boundingBox));
                 }
             }
             const validCandidates = collisionCandidates.filter(o => o != null && o !== playerModel); // Excluir nulos y al jugador

             let finalTargetCameraPosition = desiredCameraPosition; // Posición por defecto

            try { // Envolver intersección en try-catch
                const intersects = window.collisionRaycasterCam.intersectObjects(validCandidates, true);
                if (intersects.length > 0) {
                    const firstValidIntersect = intersects.find(intersect => intersect.object !== playerModel && !intersect.object.userData?.isTrigger); // Ignorar triggers
                    if (firstValidIntersect) {
                        const distanceToCollision = firstValidIntersect.distance;
                        const minimumAllowedDistance = 1.8; const collisionMargin = 0.7;
                        const adjustedDistance = Math.max(minimumAllowedDistance, distanceToCollision - collisionMargin);
                        finalTargetCameraPosition = rayOrigin.clone().addScaledVector(rayDirection, adjustedDistance);
                        // Ajustar Y para evitar que atraviese el suelo
                        const camTerrainHeight = ChunkManager.getTerrainHeightAt(finalTargetCameraPosition.x, finalTargetCameraPosition.z);
                        finalTargetCameraPosition.y = Math.max(finalTargetCameraPosition.y, camTerrainHeight + 0.9);
                    }
                }
            } catch(e) { console.error("Error en raycaster de cámara:", e); }


            // c. Suavizar (Lerp) la posición ACTUAL hacia la FINAL
            const lerpFactorPosition = 12 * deltaTime;
            camera.position.lerp(finalTargetCameraPosition, lerpFactorPosition);

        }
        // else: MODO FOLLOW CAM INACTIVO - OrbitControls maneja la cámara

        // --- 5. Actualizar OrbitControls ---
        if (orbitControls.enableDamping || followCamActive) {
            orbitControls.update(); // No pasar deltaTime si no se quiere damping dependiente de framerate
        }
    }

    function updatePlayerRegeneration(deltaTime) {
        if (gameState.isGhost) return;
        // Solo regenerar si no está muerto
        if (playerState.stats.health > 0) {
            playerState.stats.health = Math.min(playerState.stats.maxHealth, playerState.stats.health + playerState.stats.hpRegen * deltaTime);
        }
        playerState.stats.mana = Math.min(playerState.stats.maxMana, playerState.stats.mana + playerState.stats.mpRegen * deltaTime);
        // Regeneración de estamina mejorada
        let staminaRegenMultiplier = 1.0;
        if (!playerState.isSprinting && !playerState.isBlocking && !playerState.isAttacking && !playerState.isChargingAttack && !playerState.isDodging) {
            staminaRegenMultiplier = 2.5; // Regeneración más rápida si está completamente inactivo
        } else if (!playerState.isSprinting && !playerState.isBlocking) {
            staminaRegenMultiplier = 1.5; // Regeneración normal si solo ataca/carga
        }
        playerState.stats.stamina = Math.min(playerState.stats.maxStamina, playerState.stats.stamina + playerState.stats.spRegen * staminaRegenMultiplier * deltaTime);

        // Actualizar UI (menos frecuente, manejado en updateGame)
    }

    /**
     * Ejecuta un ataque cuerpo a cuerpo (o sin arma).
     * Maneja ataques rápidos y cargados, calcula daño, verifica impacto (RANGO HORIZONTAL y ÁNGULO FRONTAL),
     * aplica daño/efectos y actualiza estados/UI.
     * (v9 - Rango Horizontal, Ángulo Frontal, Origen Ajustado)
     * @param {number} [chargeDuration=0] - Duración (ms) que se mantuvo presionado el botón de ataque.
     */
    function executeMeleeAttack(chargeDuration = 0) {
        // 1. --- Validaciones Previas ---
        if (gameState.isGhost || playerState.isBlocking || playerState.isAimingWithBow || playerState.isAttacking || playerState.isDodging) {
            if (playerState.isChargingAttack) { playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0; controls.isAttackKeyDown = false; } return;
        }
        const now = Date.now(); const timeSinceLastAttack = now - playerState.lastAttackTime; const effectiveCooldown = ATTACK_COOLDOWN;
        if (timeSinceLastAttack < effectiveCooldown) { if (playerState.isChargingAttack) { playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0; controls.isAttackKeyDown = false; } return; }

        // 2. --- Determinar Carga y Coste de Resistencia ---
        const chargeThreshold = 200; const isCharged = chargeDuration >= chargeThreshold; const staminaCost = isCharged ? CHARGED_ATTACK_STAMINA_COST : ATTACK_STAMINA_COST;
        if (playerState.stats.stamina < staminaCost) { logMessage(`Sin resistencia para ${isCharged ? 'ataque cargado' : 'atacar'}.`, "warning"); AudioManager.playSound('ui_error', 0.4); if (playerState.isChargingAttack) { playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0; controls.isAttackKeyDown = false; } return; }
        playerState.stats.stamina -= staminaCost;

        try {
            // 3. --- Iniciar Secuencia de Ataque ---
            playerState.lastAttackTime = now; playerState.isAttacking = true;
            const attackSound = isCharged ? 'swing_heavy' : 'swing'; AudioManager.playSound(attackSound, isCharged ? 0.7 : 0.55);
            // playPlayerAnimation(isCharged ? 'attack_heavy' : 'attack_light', 0.05, false);

            // 4. --- Determinar Propiedades del Ataque (Daño, Tipo, Rango Base, Crit) ---
            let dmgMin, dmgMax, baseAttackRange, attackType, baseCritChance;
            const weapon = playerState.equipment.weapon; const weaponId = weapon ? weapon.id : 'unarmed'; const weaponDef = itemDefinitions[weaponId];
            if (!weaponDef) { dmgMin = 1 + (playerState.stats.physDmgMin || 1); dmgMax = 2 + (playerState.stats.physDmgMax || 1); attackType = 'physical'; baseAttackRange = ATTACK_DISTANCE * 0.8; baseCritChance = playerState.stats.critChance || 5; const unarmedSkillLevel = playerState.skills?.unarmed_combat?.level || 0; dmgMin += unarmedSkillLevel * 0.12; dmgMax += unarmedSkillLevel * 0.12; baseCritChance += unarmedSkillLevel * 0.06; logMessage("Error: Usando ataque sin arma.", "warning"); }
            else { if (weaponDef.stats?.magicDmgMin || weaponDef.stats?.magicDmgMax) { dmgMin = (playerState.stats.magicDmgMin || 0) + (weaponDef.stats?.magicDmgMin || 0); dmgMax = (playerState.stats.magicDmgMax || 0) + (weaponDef.stats?.magicDmgMax || 0); attackType = 'magic'; baseAttackRange = ATTACK_DISTANCE * 1.1; baseCritChance = (playerState.stats.critChance || 5) + (weaponDef.stats?.critChance || 0); } else { dmgMin = (weaponId === 'unarmed' ? 1 : (playerState.stats.physDmgMin || 1)) + (weaponDef.stats?.physDmgMin || 0); dmgMax = (weaponId === 'unarmed' ? 2 : (playerState.stats.physDmgMax || 1)) + (weaponDef.stats?.physDmgMax || 0); attackType = 'physical'; baseAttackRange = ATTACK_DISTANCE; baseCritChance = (playerState.stats.critChance || 5) + (weaponDef.stats?.critChance || 0); const combatSkillId = weaponId === 'unarmed' ? 'unarmed_combat' : 'weapon_combat'; const combatSkillLevel = playerState.skills[combatSkillId]?.level || 0; dmgMin += combatSkillLevel * 0.12; dmgMax += combatSkillLevel * 0.12; baseCritChance += combatSkillLevel * 0.06; } }
            dmgMin = Math.max(1, Math.floor(dmgMin)); dmgMax = Math.max(dmgMin, Math.floor(dmgMax));

            // --- 5. Aplicar Modificadores por Carga ---
            let damageMultiplier = 1.0; let knockbackMultiplier = 1.0; let finalCritChance = baseCritChance;
            let finalAttackRange = baseAttackRange; // <<< MODIFICADO: Empezar con rango base
            if (isCharged) {
                const chargeProgress = Math.min(1.0, chargeDuration / CHARGE_ATTACK_MAX_TIME);
                damageMultiplier = 1.0 + (CHARGE_ATTACK_DAMAGE_MULTIPLIER - 1.0) * chargeProgress;
                knockbackMultiplier = 1.0 + 1.2 * chargeProgress;
                finalAttackRange *= (1.0 + 0.35 * chargeProgress); // <<< MODIFICADO: Aumentar rango SOLO si es cargado
            }
            dmgMin = Math.floor(dmgMin * damageMultiplier); dmgMax = Math.floor(dmgMax * damageMultiplier);
            dmgMin = Math.max(1, dmgMin); dmgMax = Math.max(dmgMin, dmgMax);

            // --- 6. Origen y Dirección ---
            const playerForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerModel.quaternion).normalize();
            // <<< MODIFICADO: Origen ligeramente adelantado para mejor golpe cercano >>>
            const attackOrigin = playerState.position.clone().add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.9, 0)).addScaledVector(playerForward, 0.15);

            // --- 7. Buscar y Procesar Objetivo ---
            let hitTarget = false;
            const attackRangeSq = finalAttackRange * finalAttackRange; // <<< MODIFICADO: Usar rango final (puede ser mayor si es cargado)
            // <<< NUEVO: Calcular Coseno del Ángulo Máximo para el cono frontal >>>
            const maxAttackAngleCos = Math.cos(ATTACK_CONE_ANGLE / 2); // Coseno del semi-ángulo

            const enemiesToCheck = [...world.enemies];
            console.log(`--- ATTACK: RangeSq=${attackRangeSq.toFixed(1)}, AngleCosLimit=${maxAttackAngleCos.toFixed(2)} ---`);

            for (const enemy of enemiesToCheck) {
                if (!enemy?.userData || enemy.userData.isDead || !enemy.visible || !enemy.position) continue;

                const enemyPos = enemy.position.clone();

                // <<< MODIFICADO: Chequeo de RANGO HORIZONTAL (ignora Y) >>>
                const dx = enemyPos.x - attackOrigin.x;
                const dz = enemyPos.z - attackOrigin.z;
                const distSqXZ = dx * dx + dz * dz;

                if (distSqXZ < attackRangeSq) { // Si está dentro del RANGO HORIZONTAL...
                    // <<< NUEVO: Chequeo de ÁNGULO FRONTAL >>>
                    const directionToEnemy = new THREE.Vector3(dx, 0, dz).normalize(); // Vector horizontal al enemigo
                    const dotProduct = playerForward.dot(directionToEnemy); // Producto punto con la dirección del jugador

                    if (dotProduct > maxAttackAngleCos) { // Si está dentro del CONO FRONTAL...
                        console.log(`   -> HIT Candidate: ${enemy.userData.name} (DistXZ OK, Angle OK: dot=${dotProduct.toFixed(2)})`);
                        hitTarget = true;

                        // Calcular Hit Chance (sin cambios)
                        const hitChanceRoll = Math.random() * 100;
                        const combatSkillIdHit = weaponId === 'unarmed' ? 'unarmed_combat' : 'weapon_combat'; const combatSkillLevelHit = playerState.skills[combatSkillIdHit]?.level || 0; const playerHitChance = playerState.stats.hitChance + combatSkillLevelHit * 0.18;

                        if (hitChanceRoll > playerHitChance) {
                            console.log(`      MISS! (Roll ${hitChanceRoll.toFixed(1)} vs Chance ${playerHitChance.toFixed(1)})`);
                            showFloatingText("miss-text", "Fallo", enemyPos.clone().add(new THREE.Vector3(0, enemy.userData.heightOffset || 1.5, 0)));
                        } else {
                            console.log(`      HIT!`);
                            const isCritical = Math.random() * 100 < finalCritChance;
                            let damage = Math.max(1, Math.floor(Math.random() * (dmgMax - dmgMin + 1) + dmgMin));
                            if (isCritical) damage = Math.floor(damage * 1.6);

                            // Lógica Stab/Bleed (sin cambios)
                            let applyBleed = false; if (weaponDef?.isDagger) { /*...*/ }

                            // Aplicar Daño (sin cambios, applyDamage maneja defensas/resists)
                            console.log(`         Applying ${damage} ${attackType} damage (Crit: ${isCritical})`);
                            applyDamage(enemy, damage, attackType, isCritical);
                            if (applyBleed) { /* addStatusEffect... */ }

                            // Aplicar Knockback (sin cambios)
                            if (enemy.userData && !enemy.userData.isDead) { const kbDir = new THREE.Vector3().subVectors(enemyPos, attackOrigin).normalize(); kbDir.y = 0.35; applyKnockback(enemy, kbDir.normalize(), (isCritical ? 2.2 : 1.4) * knockbackMultiplier); }
                        }
                        break; // Detener al primer enemigo golpeado válido
                    } else {
                         // console.log(`   -> Target ${enemy.userData.name} in range BUT outside angle (dot=${dotProduct.toFixed(2)})`); // DEBUG
                    }
                } // Fin chequeo RANGO
            } // Fin FOR enemigos

            if (!hitTarget) console.log("   Attack finished: No target hit in range/angle.");

        } catch (attackError) {
            console.error("Error durante executeMeleeAttack:", attackError); logMessage("Error al atacar.", "error");
        } finally {
            // --- Resetear Estado de Ataque (sin cambios) ---
            const animationDuration = isCharged ? effectiveCooldown * 0.75 : effectiveCooldown * 0.65;
            setTimeout(() => { if (playerState.isAttacking) playerState.isAttacking = false; }, animationDuration);
            if (playerState.isChargingAttack) { playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0; controls.isAttackKeyDown = false; }
            updatePlayerUI(); updateActionButtons();
        }
    } // Fin executeMeleeAttack (v9)
        /**
     * Itera sobre todos los enemigos activos y llama a updateSingleEnemy para cada uno.
     * Incluye throttling para optimizar la actualización de la IA.
     * @param {number} deltaTime - Tiempo acumulado desde la última actualización de IA (considerando el throttle).
     */
    function updateEnemies(deltaTime) {
        // Iterar sobre una copia del array si `updateSingleEnemy` puede modificar `world.enemies` (ej: al morir y respawnear inmediatamente)
        // const enemiesToUpdate = [...world.enemies];
        // Por ahora, iteramos directamente, asumiendo que las modificaciones no causan problemas graves de índice aquí.
        world.enemies.forEach(enemy => {
            // --- Validaciones Básicas ---
            if (!enemy || !enemy.userData || enemy.userData.type !== 'enemy') {
                // Podrías añadir lógica para limpiar entradas inválidas del array aquí si es necesario
                // console.warn("Entrada inválida encontrada en world.enemies");
                return;
            }

            // No actualizar enemigos muertos o que se están procesando para morir
            if (enemy.userData.isDead || enemy.userData.isProcessingDeath) {
                return;
            }

            // --- Llamar a la IA Individual ---
            try {
                // Pasar el deltaTime acumulado debido al throttling
                updateSingleEnemy(enemy, deltaTime);
            }
            catch(error) {
                // Capturar errores específicos de un enemigo para que no detengan el bucle
                console.error(`Error en updateSingleEnemy (${enemy.userData.name || 'ID: '+enemy.uuid}):`, error);
                // Opcional: Poner al enemigo en estado 'idle' o desactivar su IA si falla repetidamente
                // enemy.userData.aiState = 'idle';
            }
        });
    }
    
/**
 * Entra en modo apuntar con arco.
 * (v2.3 Style)
 */
function enterAimingMode() {
    if (gameState.isAimingWithBow || gameState.isTargetingSpell || !gameState.isPlaying || gameState.isPaused || gameState.isGhost) return;
    const weapon = playerState.equipment.weapon; const weaponDef = weapon ? itemDefinitions[weapon.id] : null;
    if (!weaponDef || weaponDef.weaponType !== 'bow') { logMessage("Necesitas equipar un arco.", "warning"); controls.isAttackKeyDown = false; return; }

    gameState.isAimingWithBow = true;
    playerState.isDrawingBow = true; // Para animación
    document.body.style.cursor = 'crosshair';
    logMessage("Apuntando con arco... Clic Izq: Disparar, Clic Der/Esc: Cancelar.", "info");
    showNotification("Modo Apuntar (Arco)", "system", 2000);
    AudioManager.playSound('bow_draw', 0.4); // Sonido de tensar
    // playPlayerAnimation('bow_draw_hold', 0.1, true); // Animación
}

/**
 * Cancela el modo apuntar con arco.
 * (v2.3 Style)
 */
function cancelAiming() {
    if (!gameState.isAimingWithBow) return;
    gameState.isAimingWithBow = false;
    playerState.isDrawingBow = false;
    controls.isAttackKeyDown = false; // Asegura resetear el input Z/Mouse
    document.body.style.cursor = 'default';
    logMessage("Apuntado cancelado.", "info");
    AudioManager.playSound('ui_close', 0.3); // Sonido de cancelar
    // playPlayerAnimation('idle'); // Volver a idle
}

/**
 * Dispara una flecha hacia el objetivo enemigo especificado.
 * Consume estamina, crea el proyectil 'arrow', da feedback.
 * *** NO llama a cancelAiming internamente ***
 * (v4 - Reconfirmada para v2.3 Logic)
 * @param {THREE.Object3D} targetEnemy - El objeto 3D del enemigo objetivo.
 */
function fireArrow(targetEnemy) {
    console.log(`[fireArrow v4] Initiated for target: ${targetEnemy?.userData?.name || 'INVALID TARGET'}`);
    if (!targetEnemy?.userData || targetEnemy.userData.isDead) { console.error("fireArrow ABORTED: Objetivo inválido."); return; }
    if (gameState.isGhost || !gameState.isPlaying || gameState.isPaused) { console.warn("fireArrow ABORTED: Estado de jugador inválido."); return; }

    const staminaCost = 8;
    if (playerState.stats.stamina < staminaCost) { logMessage("Sin resistencia para disparar.", "warning"); AudioManager.playSound('ui_error', 0.4); return; }
    playerState.stats.stamina -= staminaCost;

    AudioManager.playSound('bow_shoot', 0.6);
    playerState.isFiringBow = true; setTimeout(() => { playerState.isFiringBow = false; }, 200);

    let startPos;
    try { const playerCenterPos = playerState.position; const weaponHandAnchor = playerMeshes.weaponHand; if (weaponHandAnchor?.getWorldPosition) { startPos = new THREE.Vector3(); weaponHandAnchor.getWorldPosition(startPos); const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerModel.quaternion); startPos.addScaledVector(forward, 0.4); startPos.y = Math.max(startPos.y, playerCenterPos.y + PLAYER_HALF_HEIGHT * 0.8); } else { startPos = playerCenterPos.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 1.1, 0)); } }
    catch (e) { console.error("fireArrow ABORTED: Error calculating startPos:", e); return; }

    const enemyHeightOffset = targetEnemy.userData.heightOffset ?? 0.6;
    const endPos = targetEnemy.position.clone().add(new THREE.Vector3(0, enemyHeightOffset, 0));
    if (isNaN(startPos.x) || isNaN(endPos.x)) { console.error("¡ERROR CRÍTICO fireArrow! startPos o endPos NaN."); return; }

    const direction = new THREE.Vector3().subVectors(endPos, startPos);
    if (direction.lengthSq() < 0.001) { camera.getWorldDirection(direction); } else { direction.normalize(); }

    const arrowMesh = createArrowMesh(); if (!arrowMesh) { console.error("Fallo al crear malla flecha!"); return; }
    arrowMesh.position.copy(startPos);
    try { arrowMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction); } catch (quatError) { console.error("Error setting quaternion:", quatError); return; }

    const weapon = playerState.equipment.weapon; const weaponDef = weapon ? itemDefinitions[weapon.id] : null;
    const rangeSkillLevel = playerState.skills?.ranged_weapons?.level || 0;
    let dmgMin = (playerState.stats.physDmgMin / 2) + (weaponDef?.stats?.physDmgMin || 0) + rangeSkillLevel * 0.15;
    let dmgMax = (playerState.stats.physDmgMax / 2) + (weaponDef?.stats?.physDmgMax || 0) + rangeSkillLevel * 0.15;
    dmgMin = Math.max(1, Math.floor(dmgMin)); dmgMax = Math.max(dmgMin, Math.floor(dmgMax));
    const hitChanceBonus = (weaponDef?.stats?.hitChance || 0) + rangeSkillLevel * 0.18;
    const critChanceBonus = (weaponDef?.stats?.critChance || 0);

    arrowMesh.userData = { type: 'projectile', projectileType: 'arrow', name: 'Flecha', direction: direction.clone(), speed: PROJECTILE_SPEED * 1.3, damage: { min: dmgMin, max: dmgMax, type: 'physical' }, caster: playerModel, lifetime: 4, particleColor: 0xaaaaaa, target: targetEnemy, hitChanceBonus: hitChanceBonus, critChanceBonus: critChanceBonus, isArrow: true };

    try { scene.add(arrowMesh); world.activeProjectiles.push(arrowMesh); }
    catch (addError){ console.error("Error adding arrow to scene/world:", addError); return; }

    logMessage(`Has disparado una flecha a ${targetEnemy.userData.name}.`, 'combat');
    updatePlayerUI();
    // *** NO LLAMAR A cancelAiming() AQUÍ ***
    console.log("[fireArrow] Finished successfully.");
}
    
        /**
     * Otorga experiencia al jugador y maneja la subida de nivel.
     * Actualiza la barra de XP, las estadísticas y la UI relevante.
     * @param {number} amount - La cantidad de XP a ganar. Debe ser un número positivo.
     */
    function gainExperience(amount) {
        // 1. Validación de Entrada
        if (typeof amount !== 'number' || isNaN(amount) || amount <= 0) {
            console.warn(`gainExperience: Cantidad de XP inválida recibida: ${amount}`);
            return; // No hacer nada si la cantidad es inválida
        }

        // 2. No ganar XP si ya está al nivel máximo
        if (playerState.level >= MAX_LEVEL) {
            // logMessage("Ya has alcanzado el nivel máximo.", "info"); // Opcional: Mensaje si ya es nivel máx
            return;
        }

        // 3. Añadir XP
        playerState.xp += Math.floor(amount); // Asegurar que la XP sea entera

        // 4. Log y Feedback Visual (Texto Flotante)
        // Se muestra en killEnemy, pero podrías añadirlo aquí si ganas XP de otras fuentes
        // showFloatingText('xp-text', `+${Math.floor(amount)} XP`, playerState.position.clone().add(new THREE.Vector3(0, 1.8, 0)));
        // logMessage(`Has ganado ${Math.floor(amount)} puntos de experiencia.`, 'info');

        // 5. Comprobar y Manejar Subida de Nivel
        let leveledUp = false; // Flag para saber si se subió de nivel
        while (playerState.xp >= playerState.xpToNextLevel && playerState.level < MAX_LEVEL) {
            leveledUp = true; // Marcamos que ha subido al menos un nivel

            // a. Calcular XP sobrante
            const excessXP = playerState.xp - playerState.xpToNextLevel;

            // b. Incrementar Nivel
            playerState.level++;

            // c. Calcular XP para el siguiente nivel
            playerState.xpToNextLevel = calculateXPForLevel(playerState.level + 1);

            // d. Asignar XP sobrante al nuevo nivel
            playerState.xp = excessXP;

            // e. Otorgar Puntos de Atributo y Habilidad
            playerState.attributePoints += ATTRIBUTE_POINTS_PER_LEVEL;
            playerState.skillPoints += SKILL_POINTS_PER_LEVEL; // O lógica específica de clase (ej: Trabajador)
            // if (playerState.class === 'worker') playerState.skillPoints++;

            // f. Recalcular Estadísticas Base (Pueden aumentar con el nivel si lo defines)
            // Por ahora, los stats base no aumentan directamente con nivel, sino con atributos.
            // Pero si tuvieras stats que sí escalan con nivel, se recalcularían aquí.
            updatePlayerStats(); // Recalcular por si los puntos de habilidad otorgan stats pasivos

            // g. Restaurar Salud/Maná/Estamina al subir de nivel (Común en RPGs)
            playerState.stats.health = playerState.stats.maxHealth;
            playerState.stats.mana = playerState.stats.maxMana;
            playerState.stats.stamina = playerState.stats.maxStamina;

            // h. Feedback de Subida de Nivel
            logMessage(`¡Has alcanzado el Nivel ${playerState.level}!`, 'success');
            showNotification(`¡Nivel ${playerState.level} alcanzado!`, 'success', 5000); // Notificación más larga
            if (AudioManager) AudioManager.playSound('level_up', 0.7); // Sonido de level up
            // Podría añadirse un efecto de partículas visual alrededor del jugador
            // createLevelUpEffect(playerModel.position);
        }

        // 6. Actualizar UI
        // Llama a updatePlayerUI que a su vez llama a updateStatusBar para la barra de XP
        updatePlayerUI();
        // Si subió de nivel, actualizar también la hoja de personaje si está abierta
        if (leveledUp && gameState.isCharacterSheetOpen) {
            updateCharacterSheet();
        }
        // Actualizar UI de skills si ganó puntos de habilidad y está abierta
         if(leveledUp && gameState.isSkillsModalOpen) {
              updateSkillsUI();
         }
    }
    
    
/**
 * NUEVO: Crea el modelo 3D de una flecha simple con eje, punta y plumas.
 * El modelo se orienta para que su eje Y local apunte en la dirección "adelante".
 * @returns {THREE.Group | null} Un grupo THREE.js que contiene la malla de la flecha, o null si falla.
 */
function createArrowMesh() {
    try {
        const group = new THREE.Group();
        group.name = "ArrowProjectile"; // Identificador

        // --- Dimensiones ---
        const shaftLength = 0.8;   const shaftRadius = 0.018;
        const headLength = 0.1;    const headRadius = 0.04;
        const featherLength = 0.18; const featherWidth = 0.06; const featherOffset = 0.04;

        // --- Materiales ---
        const shaftMat = new THREE.MeshStandardMaterial({ color: 0x966F33, roughness: 0.8, metalness: 0 });
        const headMat = new THREE.MeshStandardMaterial({ color: 0xadb5bd, roughness: 0.4, metalness: 0.7 });
        const featherMat = new THREE.MeshStandardMaterial({ color: 0xf0e0d0, roughness: 0.9, side: THREE.DoubleSide });

        // --- Geometrías ---
        const shaftGeom = new THREE.CylinderGeometry(shaftRadius, shaftRadius, shaftLength, 6);
        const headGeom = new THREE.ConeGeometry(headRadius, headLength, 6);
        const featherGeom = new THREE.PlaneGeometry(featherWidth, featherLength);

        // --- Crear y Posicionar Partes ---
        // Eje (Shaft) - Centrado en Y=shaftLength/2
        const shaft = new THREE.Mesh(shaftGeom, shaftMat);
        shaft.position.y = shaftLength / 2;
        shaft.castShadow = true; group.add(shaft);

        // Punta (Head) - En Y=shaftLength
        const head = new THREE.Mesh(headGeom, headMat);
        head.position.y = shaftLength;
        head.castShadow = true; group.add(head);

        // Plumas (Feathers) - Cerca de Y=0
        const numFeathers = 3;
        for (let i = 0; i < numFeathers; i++) {
            const feather = new THREE.Mesh(featherGeom, featherMat);
            const angle = (i / numFeathers) * Math.PI * 2;
            const posX = Math.cos(angle) * featherOffset; const posZ = Math.sin(angle) * featherOffset;
            feather.position.set(posX, featherLength * 0.4, posZ); // Posicionar cerca de la base
            feather.rotation.y = angle + Math.PI / 2; // Orientar hacia afuera
            feather.rotation.x = Math.PI / 12; // Ligera inclinación
            feather.castShadow = true; group.add(feather);
        }

        // El grupo completo ahora tiene la flecha apuntando hacia +Y localmente
        return group;

    } catch (e) {
        console.error("Error creando malla de flecha:", e);
        return null; // Devolver null si falla la creación
    }
    
}


function initPreviewRenderer() {
    previewModelContainer = domCache['char-preview-model']; // El div HTML
    if (!previewModelContainer) {
        console.error("Error: Div #char-preview-model no encontrado para inicializar preview.");
        return;
    }

    const width = previewModelContainer.clientWidth || 150; // Usa tamaño del div o un default
    const height = previewModelContainer.clientHeight || 200;

    previewScene = new THREE.Scene();
    previewScene.background = new THREE.Color(0x333338); // Fondo para el preview

    previewCamera = new THREE.PerspectiveCamera(50, width / height, 0.1, 10);
    previewCamera.position.set(0, 1.0, 2.5); // Posición inicial cámara preview
    previewCamera.lookAt(0, 0.8, 0);      // Mirar hacia el centro del modelo

    previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    previewRenderer.setSize(width, height);
    previewRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limitar pixel ratio
    previewModelContainer.appendChild(previewRenderer.domElement); // Añadir canvas al div

    // Luces básicas para el preview
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    previewScene.add(ambientLight);
    previewLight = new THREE.DirectionalLight(0xffffff, 0.8);
    previewLight.position.set(2, 3, 2);
    previewScene.add(previewLight);

    console.log("Preview Renderer inicializado.");

    // Iniciar un loop de renderizado simple SOLO para el preview
    // (Si ya tienes un loop principal, puedes añadir el renderizado del preview ahí)
    animatePreview();
}

// --- Modificar animatePreview ---
function animatePreview() {
     // *** ALMACENAR EL ID DEL FRAME ***
     previewAnimationLoopId = requestAnimationFrame(animatePreview); // Guardar ID

     // Actualizar mixer si existe
     const deltaTime = previewClock.getDelta();
     if (previewMixer) {
         try { // Añadir try-catch por seguridad
             previewMixer.update(deltaTime);
         } catch(e) {
             console.error("Error actualizando preview mixer:", e);
             previewMixer = null; // Detener si falla
         }
     }
     // Rotar modelo lentamente (opcional)
     const modelInPreview = previewScene?.getObjectByName("PreviewCharacterModel"); // Usar optional chaining
     if(modelInPreview) {
         try { // Añadir try-catch por seguridad
             modelInPreview.rotation.y += 0.008;
         } catch(e) { console.warn("Error rotando modelo preview:", e); }
     }

     // Renderizar la escena del preview
     if (previewRenderer && previewScene && previewCamera) {
         try { // Añadir try-catch por seguridad
             previewRenderer.render(previewScene, previewCamera);
         } catch(e) {
             console.error("Error renderizando preview:", e);
             // Detener bucle si falla el renderizado
             if (previewAnimationLoopId !== null) {
                 cancelAnimationFrame(previewAnimationLoopId);
                 previewAnimationLoopId = null;
             }
         }
     } else {
         // Si falta algo, detener el bucle para no consumir recursos
         if (previewAnimationLoopId !== null) {
             cancelAnimationFrame(previewAnimationLoopId);
             previewAnimationLoopId = null;
             // console.log("Deteniendo bucle preview por falta de renderer/scene/camera.");
         }
     }
}

/**
 * Aplica daño (o curación) a un objetivo, considerando defensas, resistencias,
 * bloqueo y parry. Actualiza la salud y muestra texto flotante.
 * (v9 - Lógica de Mitigación Completa y Retorna Daño Real)
 * @param {THREE.Object3D} target - El objetivo (playerModel o enemigo).
 * @param {number} baseAmount - La cantidad BASE de daño/curación ANTES de mitigación.
 * @param {string} [type='physical'] - Tipo de daño ('physical', 'magic', 'fire', 'poison', 'heal', etc.).
 * @param {boolean} [isCritical=false] - Si el golpe fue crítico (afecta texto flotante).
 * @param {boolean} [isBlocked=false] - Si el ataque fue bloqueado por el objetivo.
 * @param {boolean} [isParried=false] - Si el ataque fue parado (parry) por el objetivo.
 * @returns {number} La cantidad final de daño/curación que se aplicó realmente.
 */
function applyDamage(target, baseAmount, type = 'physical', isCritical = false, isBlocked = false, isParried = false) {
    // --- Validaciones Iniciales ---
    if (!target?.userData || (target.userData.type === 'enemy' && target.userData.isDead)) { return 0; } // Salir si no hay target o está muerto
    if (typeof baseAmount !== 'number' || isNaN(baseAmount)) baseAmount = 0;
    const isPlayerTarget = (target === playerModel);
    const targetData = isPlayerTarget ? playerState : target.userData;
    const stats = targetData.stats || targetData; // Obtener stats
    if (typeof stats.health !== 'number') { console.error("applyDamage: Target sin stats.health"); return 0; } // Salir si no tiene salud

    // --- Curación ---
    if (type === 'heal') {
        const amountHealed = Math.max(0, Math.floor(baseAmount)); // Asegurar entero positivo
        const actualHeal = Math.min(amountHealed, (stats.maxHealth || Infinity) - stats.health); // No curar por encima del máximo
        if (actualHeal > 0) {
            stats.health += actualHeal;
            const textPos = target.position.clone().add(new THREE.Vector3(0, (targetData.heightOffset || 1.0) + 0.4, 0));
            showFloatingText('heal-text', `+${Math.floor(actualHeal)}`, textPos);
            if (isPlayerTarget) AudioManager.playSound('spell_cast', 0.5); // Sonido de cura
             // Actualizar UI (siempre para curación)
             if (isPlayerTarget) { updatePlayerUI(); if(gameState.isCharacterSheetOpen) updateCharacterSheet(); }
             else if (target === gameState.targetEntity) { updateTargetUI(); }
            return actualHeal; // Retornar cuánto se curó realmente
        }
        return 0; // No se curó nada
    }

    // --- Daño (No Curación) ---
    let finalDamage = baseAmount;

    // 1. Inmunidad / Evasión / Parry (ANTES de cualquier reducción)
    if (targetData.isInvulnerable) {
         showFloatingText('miss-text', "Esquiva", target.position.clone().add(new THREE.Vector3(0, (targetData.heightOffset || 1.0) + 0.5, 0)));
         return 0; // 0 daño si es invulnerable/esquiva
    }
    if (isParried && isPlayerTarget && type === 'physical') { // Parry solo aplica a jugador y físico
         // Ya se manejó la lógica del parry (sonido, stagger enemigo) en attackPlayer
         // applyDamage solo confirma que el daño es 0
         return 0;
    }

    // 2. Defensa / Resistencia Mágica
if (type === 'physical') {
    const defenseFromSkill = (isPlayerTarget && playerState.skills?.shield_defense?.level) ? (playerState.skills.shield_defense.level * 0.08) : 0;
    const totalDefense = Math.max(0, (stats.defense || 0) + defenseFromSkill); // Asegurar no negativo

    // NUEVA FÓRMULA: Reducción Porcentual
    const defenseFactor = 150; // <-- ¡AJUSTA ESTE VALOR! Más alto = defensa menos efectiva
    const damageReductionPercent = totalDefense / (totalDefense + defenseFactor);
    finalDamage = baseAmount * (1 - damageReductionPercent);

    // console.log(`Phys DMG: Base=${baseAmount.toFixed(0)}, Def=${totalDefense.toFixed(1)}, Reduc%=${(damageReductionPercent*100).toFixed(1)}%, DmgAfterDef=${finalDamage.toFixed(1)}`); // DEBUG

} else if (type !== 'heal') { // --- REEMPLAZO para Daño Mágico/Elemental ---
    const magicResFromSkill = (isPlayerTarget && playerState.skills?.magic_resistance?.level) ? (playerState.skills.magic_resistance.level * 0.1) : 0;
    const totalMagicRes = Math.max(0, (stats.magicResist || 0) + magicResFromSkill); // Asegurar no negativo

    // NUEVA FÓRMULA: Reducción Porcentual
    const magicResFactor = 120; // <-- ¡AJUSTA ESTE VALOR! Similar a defenseFactor
    const magicDamageReductionPercent = totalMagicRes / (totalMagicRes + magicResFactor);
    finalDamage = baseAmount * (1 - magicDamageReductionPercent);

    // console.log(`Magic DMG: Base=${baseAmount.toFixed(0)}, MRes=${totalMagicRes.toFixed(1)}, Reduc%=${(magicDamageReductionPercent*100).toFixed(1)}%, DmgAfterMRes=${finalDamage.toFixed(1)}`); // DEBUG
}

// --- El resto de la lógica (resistencias, bloqueo, daño mínimo) permanece igual ---
// 3. Resistencias Específicas del Objetivo
if (targetData.resistances && targetData.resistances[type]) {
    finalDamage *= (1 - targetData.resistances[type]);
}
// 4. Reducción por Bloqueo (Si aplica y no fue Parry)
if (isBlocked && isPlayerTarget && type === 'physical') {
    finalDamage *= (1 - BLOCK_DAMAGE_REDUCTION);
}
// 5. Cálculo Final y Aplicación (Mínimo 1 si base era > 0)
finalDamage = Math.max(0, Math.floor(finalDamage));
if (finalDamage <= 0 && baseAmount > 0 && !isParried && !targetData.isInvulnerable) {
    finalDamage = 1;
}

    // --- Aplicar Daño a la Salud ---
    stats.health -= finalDamage;

    // --- Feedback Visual y Sonoro (Solo si hubo daño) ---
    if (finalDamage > 0) {
        const textClass = isCritical ? 'critical-text' : (type === 'poison' ? 'poison-text' : 'damage-text');
        const textContent = isCritical ? `¡${finalDamage}!` : finalDamage.toString();
        const textHeightOffset = (targetData.heightOffset || (isPlayerTarget ? PLAYER_HEIGHT : 1.0)) + 0.4;
        const textPos = target.position.clone().add(new THREE.Vector3(0, textHeightOffset, 0));
        showFloatingText(textClass, textContent, textPos);

        if (isPlayerTarget) {
            AudioManager.playSound('player_hit', 0.6);
            applyHitEffect(); // Efecto rojo en pantalla
        } else {
            AudioManager.playSound(isCritical ? 'hit_flesh_heavy' : 'hit_flesh', 0.55);
            createImpactEffect(target.position.clone().add(new THREE.Vector3(0, textHeightOffset * 0.8, 0)), 0xff0000);
        }
    }

    // --- Lógica Post-Daño ---
    if (stats.health <= 0 && !targetData.isDead && !targetData.isProcessingDeath) {
        targetData.isDead = true;
        if (isPlayerTarget) { playerDeath(); } else { killEnemy(target); }
    } else if (!isPlayerTarget && !targetData.isAggro && !targetData.isDead) { // Hacer aggro si no estaba
        targetData.isAggro = true; targetData.target = playerModel;
        // logMessage(`${targetData.name} es hostil!`, 'warning'); // Log de aggro se puede quitar de aquí
        if (target === gameState.targetEntity) updateTargetUI();
    }

    // --- Actualizar UI ---
    if (isPlayerTarget) { updatePlayerUI(); if (gameState.isCharacterSheetOpen) updateCharacterSheet(); }
    else if (target === gameState.targetEntity) { updateTargetUI(); }

    // --- Devolver Daño Aplicado ---
    return finalDamage; // Retorna el valor que se restó de la vida
}
    
// --- Función applyKnockback (Revisada) ---
    function applyKnockback(target, direction, force) {
        if (!target?.userData || target.userData.isDead || target.userData.isDodging || target.userData.isInvulnerable) { return; }
        const targetType = target.userData.type; if (targetType !== 'enemy' && target !== playerModel) { return; }
        if (!target.userData.knockbackVelocity) { target.userData.knockbackVelocity = new THREE.Vector3(); }
        target.userData.knockbackVelocity.addScaledVector(direction, force); target.userData.isKnockedBack = true;
        if (target === playerModel && playerState) { if (playerState.isChargingAttack) { playerState.isChargingAttack = false; playerState.chargeAttackStartTime = 0; controls.isAttackKeyDown = false; logMessage("Carga interrumpida por golpe.", "warning"); } }
        else if (targetType === 'enemy') { if (target.userData.aiState === 'attacking' || target.userData.aiState === 'charging') { target.userData.aiState = 'chasing'; target.userData.lastAttackTime = Date.now() - ((target.userData.attackCooldown || 2000) * 0.7); } }
    }
    
    function applyHitEffect() {
         // Efecto visual simple en pantalla
         const overlay = document.createElement('div');
         overlay.style.position = 'fixed';
         overlay.style.top = '0'; overlay.style.left = '0';
         overlay.style.width = '100%'; overlay.style.height = '100%';
         overlay.style.backgroundColor = 'rgba(255, 0, 0, 0.25)'; // Rojo semitransparente
         overlay.style.pointerEvents = 'none';
         overlay.style.zIndex = '1000'; // Encima de todo
         overlay.style.opacity = '1';
         overlay.style.transition = 'opacity 0.15s ease-out';
         document.body.appendChild(overlay);
         setTimeout(() => { overlay.style.opacity = '0'; }, 50); // Fade out rápido
         setTimeout(() => { if(overlay.parentNode) overlay.remove(); }, 200); // Eliminar del DOM
    }



    /**
     * Procesa la muerte de un enemigo.
     * Otorga XP, genera loot, inicia animación de muerte y programa respawn.
     * (v8 - Robustez en generación/spawn de loot)
     * @param {THREE.Object3D} enemy - El objeto 3D del enemigo a matar.
     */
    function killEnemy(enemy) {
        // 1. --- Validación y Prevención ---
        if (!enemy || !enemy.userData || enemy.userData.type !== 'enemy') { console.error("killEnemy: Objeto inválido."); return; }
        if (enemy.userData.isProcessingDeath) return;
        enemy.userData.isProcessingDeath = true; enemy.userData.isDead = true;
        console.log(`--- PROCESSING killEnemy for: ${enemy.userData.name} ---`);

        // 2. --- Detener IA y Animación ---
        enemy.userData.isAggro = false; enemy.userData.target = null; enemy.userData.aiState = 'dead';
        if (enemy.userData.knockbackVelocity) enemy.userData.knockbackVelocity.set(0, 0, 0);
        enemy.userData.isKnockedBack = false;
        if (enemy.userData.mixer) {
            if (enemy.userData.deathFinishListener) { try { enemy.userData.mixer.removeEventListener('finished', enemy.userData.deathFinishListener); } catch(e){} enemy.userData.deathFinishListener = null; }
            try { enemy.userData.mixer.stopAllAction(); } catch(e){}
        }

        // 3. --- Sonido ---
        AudioManager.playSound('enemy_die', 0.65);

        // 4. --- XP ---
        const xpGained = enemy.userData.xp || 0;
        if (xpGained > 0 && !gameState.isGhost && playerState.level < MAX_LEVEL) {
            gainExperience(xpGained);
            showFloatingText('xp-text', `+${xpGained} XP`, enemy.position.clone().add(new THREE.Vector3(0, (enemy.userData.heightOffset || 0.5) + 0.3, 0)));
        }

        // 5. --- Generar Loot ---
        console.log(`  Generating loot for ${enemy.userData.name}...`);
        const lootToSpawn = [];
        const commonLootTable = enemy.userData.loot || [];
        const commonLootChance = enemy.userData.lootChance ?? 0.3;
        const equipmentLootTable = enemy.userData.equipmentLoot || [];
        const equipmentLootChance = enemy.userData.equipmentLootChance ?? 0.05;

        console.log(`    Common Loot Chance: ${commonLootChance*100}%, Table:`, commonLootTable);
        if (commonLootTable.length > 0 && Math.random() < commonLootChance) {
            const id = commonLootTable[Math.floor(Math.random() * commonLootTable.length)];
            if (itemDefinitions[id]) {
                console.log(`      + Rolled Common: ${id}`);
                lootToSpawn.push({ id: id, count: 1 });
            } else { console.warn(`      ! Invalid common loot ID in ${enemy.userData.name}: ${id}`); }
        }

        console.log(`    Equipment Loot Chance: ${equipmentLootChance*100}%, Table:`, equipmentLootTable);
        if (equipmentLootTable.length > 0 && Math.random() < equipmentLootChance) {
            const id = equipmentLootTable[Math.floor(Math.random() * equipmentLootTable.length)];
            if (itemDefinitions[id]) {
                 console.log(`      + Rolled Equipment: ${id}`);
                 lootToSpawn.push({ id: id, count: 1 });
            } else { console.warn(`      ! Invalid equipment loot ID in ${enemy.userData.name}: ${id}`); }
        }

        const goldMin = enemy.userData.goldMin ?? Math.floor((enemy.userData.xp || 10) * 0.1);
        const goldMax = enemy.userData.goldMax ?? Math.floor((enemy.userData.xp || 10) * 0.5);
        const goldDrop = Math.floor(Math.random() * (goldMax - goldMin + 1)) + goldMin;
        if (goldDrop > 0) {
             console.log(`      + Rolled Gold: ${goldDrop}`);
             lootToSpawn.push({ id: 'gold_coin', count: goldDrop });
        }
        console.log(`  Loot generated:`, lootToSpawn);

        // 6. --- Soltar Loot (Spawning) ---
        if (lootToSpawn.length > 0) {
            console.log(`  Spawning ${lootToSpawn.length} loot items...`);
            const lootSpawnBasePos = enemy.position.clone().add(new THREE.Vector3(0, 0.2, 0)); // Ligeramente sobre el punto de muerte

            lootToSpawn.forEach((lootItem, index) => {
                try { // *** Envolver cada llamada a spawnItem en try...catch ***
                    const itemDef = itemDefinitions[lootItem.id];
                    if (!itemDef) {
                         console.warn(`    Skipping invalid loot item ID: ${lootItem.id}`);
                         return; // Saltar al siguiente item si la definición no existe
                    }
                    const offset = new THREE.Vector3((Math.random() - 0.5) * 0.6, index * 0.05, (Math.random() - 0.5) * 0.6);
                    const finalSpawnPos = lootSpawnBasePos.clone().add(offset);

                    // La función spawnItem ahora maneja la carga asíncrona
                    // y devuelve true si el proceso se inició, false si falló inmediatamente.
                    const spawnInitiated = spawnItem(lootItem, finalSpawnPos);

                    if (spawnInitiated) {
                        // Loguear éxito solo si el spawn se inició (puede fallar asíncronamente luego)
                         console.log(`    Spawn initiated for ${lootItem.count}x ${itemDef.name}.`);
                         // No loguear al jugador inmediatamente, solo cuando se recoge
                         // logMessage(`${enemy.userData.name} soltó ${lootItem.count} ${itemDef.name}.`, 'loot');
                    } else {
                         // Error inmediato al intentar iniciar el spawn
                         console.error(`    Failed to initiate spawn for ${lootItem.count}x ${itemDef.name}.`);
                         logMessage(`Error al generar loot (${itemDef.name}).`, 'error');
                    }
                } catch (spawnError) {
                     console.error(`    Error during spawn loop for item ${lootItem.id}:`, spawnError);
                     logMessage(`Error interno al soltar loot.`, 'error');
                     // Continuar con el siguiente item incluso si uno falla
                }
            });
             console.log(`  Loot spawning process finished.`);
        } else {
            console.log(`  No loot generated for ${enemy.userData.name}.`);
        }

        // 7. --- Iniciar Animación de Muerte ---
        const enemyAnimations = enemy.userData.animations || {};
        const deathClipNames = ['death', 'die', 'fall'];
        let deathClip = null;
        for (const name of deathClipNames) { if (enemyAnimations[name]) { deathClip = enemyAnimations[name]; break; } }
        const mixer = enemy.userData.mixer;
        const useSpecificAnimation = mixer && deathClip;

        const onDeathAnimationEnd = () => {
             if (enemy.userData.isProcessingDeath) {
                  enemy.visible = false;
                  scheduleEnemyRespawn(enemy);
             }
        };

        if (useSpecificAnimation) {
            console.log(`  killEnemy: Playing dedicated death animation '${deathClip.name}'`);
            try {
                const action = mixer.clipAction(deathClip);
                action.reset().setLoop(THREE.LoopOnce, 1).clampWhenFinished = true;
                action.timeScale = 1.0; action.play();
                const listener = (event) => { if (event.action === action) { try { mixer.removeEventListener('finished', listener); } catch(e){} enemy.userData.deathFinishListener = null; onDeathAnimationEnd(); } };
                enemy.userData.deathFinishListener = listener; mixer.addEventListener('finished', listener);
            } catch (error) { console.error(`Error playing death anim for ${enemy.userData.name}:`, error); animateSimpleDeathFallback(enemy, onDeathAnimationEnd); }
        } else { console.log(`  killEnemy: Using fallback death animation for ${enemy.userData.name}.`); animateSimpleDeathFallback(enemy, onDeathAnimationEnd); }

        // 8. --- Actualizar UI y Misiones ---
        updateQuestObjectives('kill', enemy.userData.enemyType);
        if (gameState.targetEntity === enemy) { gameState.targetEntity = null; updateTargetUI(); }
    }
    
    
    /**
     * Inicia el proceso para crear un objeto 3D para un item en el suelo.
     * La creación real y adición a la escena es asíncrona si se carga un modelo GLB.
     * (v3 - Adaptado para carga asíncrona)
     * @param {{id: string, count: number}} itemData - Los datos del item a spawnear.
     * @param {THREE.Vector3} position - La posición donde aparecerá el item.
     * @returns {boolean} True si el proceso de spawn se inició (o se creó fallback), false si hubo error inicial.
     */
    function spawnItem(itemData, position) {
        if (!itemData || !itemData.id || !position) {
            console.error("spawnItem: Datos inválidos.", itemData, position);
            return false; // Indicar fallo al iniciar
        }
        const itemDef = itemDefinitions[itemData.id];
        if (!itemDef) {
            console.error(`spawnItem: Definición no encontrada para item ID: ${itemData.id}`);
            return false; // Indicar fallo al iniciar
        }

        // Llamar a la función que maneja la carga o el fallback.
        // Esta función ahora se encarga de añadir a la escena internamente.
        // createWorldItemModel devuelve una Promesa si carga GLB, o la malla fallback, o null
        const modelCreationProcess = createWorldItemModel(itemDef, position, itemData);

        // Si devolvió null (error grave inicial o fallo en fallback), indicamos fallo.
        if (modelCreationProcess === null) {
             return false;
        }

        // Si devolvió una promesa (está cargando GLB), el proceso se inició.
        if (modelCreationProcess instanceof Promise) {
             // Podríamos añadir un .catch aquí para loguear errores de carga específicos del item
             modelCreationProcess.catch(loadError => {
                 console.error(`Error asíncrono cargando modelo para ${itemData.id}:`, loadError);
                 // No podemos devolver 'false' aquí porque spawnItem ya retornó.
             });
             return true; // El inicio fue exitoso (asíncrono)
        }

        // Si no es null y no es Promesa, debe ser la malla fallback (síncrono).
        // Ya fue añadido a la escena dentro de createWorldItemModel.
        return true; // El inicio fue exitoso (síncrono)
    }

    /**
     * Inicia la carga de un modelo 3D para un item o crea un fallback visual.
     * La adición a la escena y configuración final ocurren en el callback de carga.
     * (v3 - Carga Modelo GLB Asíncrona, añade a escena internamente)
     * @param {object} itemDef - La definición del item.
     * @param {THREE.Vector3} position - La posición inicial deseada.
     * @param {object} itemData - Datos específicos del item (id, count).
     * @returns {Promise<THREE.Object3D | null> | THREE.Mesh | null} Retorna una promesa si carga GLB,
     *          o la malla fallback directamente, o null si falla.
     */
    function createWorldItemModel(itemDef, position, itemData) {
        // 1. Validaciones Iniciales
        if (!itemDef || !itemDef.id) { console.error("createWorldItemModel: Falta itemDef o itemDef.id."); return null; }
        if (!(position instanceof THREE.Vector3)) { console.error("createWorldItemModel: Posición inválida."); return null; }
        if (!itemData || !itemData.id) { console.error("createWorldItemModel: Faltan itemData o itemData.id."); return null; }

        const modelPath = itemDef.worldModelPath; // Ruta al modelo GLB (puede ser undefined)
        const isGold = itemDef.id === 'gold_coin';
        const rarity = itemDef.rarity || 'common';
        const itemType = itemDef.type || 'junk';

        // 2. --- Función Helper para Crear Fallback Visual ---
        const createFallbackMesh = (fallbackPosition) => {
            console.log(`Creating fallback mesh for ${itemDef.id}`); // Log para saber cuándo se usa
            try {
                let geometry;
                let scaleFactor = 1.0;
                const radius = isGold ? 0.18 : 0.25;
                const detail = 1; // Low-poly

                // Geometría basada en tipo (igual que antes)
                if (isGold) {
                    geometry = new THREE.CylinderGeometry(radius, radius, 0.04, 12);
                    geometry.rotateX(Math.PI / 2); scaleFactor = 1.2;
                } else if (itemType === 'consumable' || itemType === 'potion' || itemDef.id.includes('flask')) {
                     geometry = new THREE.CylinderGeometry(0.1, 0.12, 0.35, 8); scaleFactor = 1.1;
                } else if (itemType === 'material' || itemType === 'ore' || itemType === 'resource' || itemType === 'pelt' || itemType === 'wood') {
                     geometry = Math.random() > 0.5 ? new THREE.IcosahedronGeometry(radius, detail) : new THREE.DodecahedronGeometry(radius * 1.1, detail);
                     scaleFactor = 1.0;
                } else if (itemType === 'weapon' || itemType === 'armor' || itemType === 'tool') {
                     geometry = new THREE.IcosahedronGeometry(0.30, detail); scaleFactor = 1.1;
                } else {
                    geometry = new THREE.SphereGeometry(0.2, 6, 5); scaleFactor = 0.9;
                }

                // Color y Emisión por Rareza (igual que antes)
                let baseColorHex = 0xaaaaaa; let emissiveColorHex = 0x000000; let emissiveIntensity = 0;
                const getRarityColorValue = (rarityName, isEmissive = false) => { /* ... (función color) ... */
                    const cssVar = `--rarity-${rarityName}`;
                    const fallbackColors = { common:'#aaaaaa', uncommon:'#33ff33', rare:'#4488ff', epic:'#cc66ff', legendary:'#ffa500', quest:'#ffeb3b' };
                    const emissiveFactor = 0.7;
                    try { const colorStr = getComputedStyle(document.documentElement).getPropertyValue(cssVar).trim(); if (colorStr) { const baseColor = new THREE.Color(colorStr); if (isEmissive) return baseColor.multiplyScalar(emissiveFactor).getHex(); return baseColor.getHex(); } } catch(e){}
                    const hex = fallbackColors[rarityName] || fallbackColors['common']; if (isEmissive) return new THREE.Color(hex).multiplyScalar(emissiveFactor).getHex(); return new THREE.Color(hex).getHex();
                };
                baseColorHex = getRarityColorValue(rarity);
                emissiveIntensity = { common: 0.1, uncommon: 0.3, rare: 0.5, epic: 0.7, legendary: 0.9, quest: 0.6 }[rarity] || 0.1;
                if (emissiveIntensity > 0) emissiveColorHex = getRarityColorValue(rarity, true);
                if (isGold) { baseColorHex = getRarityColorValue('legendary'); emissiveColorHex = getRarityColorValue('legendary', true); emissiveIntensity = 0.4; }

                const material = new THREE.MeshStandardMaterial({
                    color: baseColorHex, emissive: emissiveColorHex, emissiveIntensity: emissiveIntensity,
                    roughness: 0.35 + Math.random() * 0.25,
                    metalness: (rarity === 'common' && !isGold) ? 0.1 : 0.3,
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.setScalar(scaleFactor);
                mesh.position.copy(fallbackPosition); // Posicionar el fallback
                mesh.castShadow = true;
                mesh.name = `FallbackLoot_${itemDef.name}`;
                return mesh; // Devolver la malla fallback creada
            } catch (fallbackError) {
                 console.error(`Error creando fallback mesh para ${itemDef.id}:`, fallbackError);
                 return null; // Falló la creación del fallback
            }
        };

        // 3. --- Función Helper para añadir al mundo y configurar userData ---
        const finalizeItemSetup = (mesh, isFallback = false) => {
            if (!mesh) {
                console.error(`finalizeItemSetup: Se recibió una malla nula para ${itemDef.id}.`);
                return; // No hacer nada si la malla es nula
            }
            try {
                // Asegurar posición sobre el terreno
                const terrainY = ChunkManager.getTerrainHeightAt(mesh.position.x, mesh.position.z);
                // Asegurarse que baseY en userData se use correctamente
                const baseY = Math.max(terrainY + (isFallback ? 0.15 : 0.1), mesh.position.y);
                mesh.position.y = baseY; // Establecer la posición Y final
                mesh.rotation.y = Math.random() * Math.PI * 2; // Rotación aleatoria (puede sobreescribir la del GLB si se aplica aquí)

                // Configurar UserData (Llama al helper que ya tienes)
                mesh.userData = setupLootUserData(mesh, itemDef, itemData);
                // Asegurarse de que baseY en userData coincida con la posición final
                mesh.userData.baseY = mesh.position.y;

                // *** Añadir al Mundo ***
                scene.add(mesh);
                world.items.push(mesh);
                world.interactables.push(mesh);
                console.log(`  -> Item ${isFallback ? '(Fallback)' : '(Modelo GLB)'} ${itemDef.name} añadido a la escena en Y=${mesh.position.y.toFixed(2)}.`);

            } catch (setupError) {
                 console.error(`Error en finalizeItemSetup para ${itemDef.id}:`, setupError);
                 // Intentar limpiar si falla el setup
                 if(mesh.parent) scene.remove(mesh);
            }
        };
        // --- Fin Helper ---

        // 4. --- Decidir si Cargar Modelo o Usar Fallback ---
        if (modelPath) {
            // --- Cargar Modelo GLB (Asíncrono) ---
            console.log(`Iniciando carga de modelo loot: ${modelPath}`);
            return loadGLBModel(modelPath)
                .then(gltf => {
                    if (!gltf || !gltf.scene) { throw new Error("GLTF inválido o sin escena."); }
                    const loadedMesh = gltf.scene; loadedMesh.name = `Loot_${itemDef.name}`;
                    console.log(`Modelo ${modelPath} cargado.`);

                    // Ajustar Modelo Cargado
                    loadedMesh.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = false; /* ... (ajustes opcionales material) ... */ } });
                    const scale = isGold ? 0.8 : 0.6; loadedMesh.scale.set(scale, scale, scale);
                    // No establecer rotación Y aquí, se hará en finalizeItemSetup
                    loadedMesh.position.copy(position); // Usar posición original como base

                    // Llamar a finalizeItemSetup DESPUÉS de cargar
                    finalizeItemSetup(loadedMesh, false);
                    return loadedMesh; // Devolver la malla configurada
                })
                .catch(error => {
                    console.error(`Error cargando ${modelPath}, usando fallback:`, error);
                    const fallbackMesh = createFallbackMesh(position); // Crear fallback en la posición original
                    finalizeItemSetup(fallbackMesh, true); // Configurar y añadir el fallback
                    // La promesa se resuelve con el fallback si este se creó, o potencialmente null
                    return fallbackMesh;
                });
        } else {
            // --- Crear y Añadir Fallback (Síncrono) ---
            // console.log(`Item ${itemDef.id} sin worldModelPath, usando fallback.`);
            const fallbackMesh = createFallbackMesh(position);
            finalizeItemSetup(fallbackMesh, true); // Configurar y añadir el fallback
            return fallbackMesh; // Devolver malla fallback (o null si falló)
        }
    } // Fin createWorldItemModel (v3)
    
        /** Helper para configurar userData común para loot (modelo real o fallback) */
    function setupLootUserData(mesh, itemDef, itemData) {
        const userData = {
            type: 'item_pickup',
            itemDef: { ...itemDef },
            itemData: { ...itemData },
            spawnTime: Date.now(),
            interactable: true,
            interact: pickupItem, // <<< ASEGÚRATE QUE pickupItem ESTÉ DEFINIDA
            // --- Animación ---
            bobOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.6 + Math.random() * 0.4,
            bobAmplitude: 0.08 + Math.random() * 0.04,
            rotationSpeed: 0.4 + Math.random() * 0.3,
            baseY: mesh.position.y,
            meshRef: mesh,
            update: function(deltaTime) {
                if (!this.baseY && this.meshRef) this.baseY = this.meshRef.position.y;
                if (this.meshRef) {
                    this.bobOffset += this.bobSpeed * deltaTime;
                    this.meshRef.position.y = this.baseY + Math.sin(this.bobOffset) * this.bobAmplitude;
                    this.meshRef.rotation.y += this.rotationSpeed * deltaTime;
                }
            }
        };
        return userData;
    }
    
function animateDeath(enemy) {
        if (!enemy || !enemy.userData || !enemy.userData.isDead) {
            console.warn("animateDeath llamada con enemigo inválido o no muerto.");
            // Si está procesando, no hacer nada más. Si no, marcar y continuar
            if(enemy?.userData?.isProcessingDeath) return;
            if(enemy?.userData) enemy.userData.isProcessingDeath = true; else return;
        }
        console.log(`--- Starting animateDeath (Fall & Fade) for ${enemy.userData.name} ---`);

        const fallDuration = 0.6; const fadeDuration = 1.2; const totalDuration = fallDuration + fadeDuration;
        let elapsed = 0;

        const startScale = enemy.scale.clone(); const targetScale = new THREE.Vector3(0.01, 0.01, 0.01);
        const startRotation = enemy.rotation.clone(); // Guardar Euler inicial
        const startQuaternion = enemy.quaternion.clone(); // Guardar Quaternion inicial
        const fallAxis = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
        if (fallAxis.lengthSq() === 0) fallAxis.set(1,0,0); // Fallback
        const fallAngle = Math.PI / 2 + (Math.random() - 0.5) * (Math.PI / 4);
        const targetQuaternion = new THREE.Quaternion().setFromAxisAngle(fallAxis, fallAngle);

        const initialMaterialStates = new Map(); // Usar Map por si hay mallas sin UUID único fiable
        let materialsFound = false;
        enemy.traverse(child => {
            if (child.isMesh && child.material) {
                materialsFound = true;
                const mat = child.material;
                const matId = child.uuid; // Usar UUID de la malla como ID único para el estado
                if (!initialMaterialStates.has(matId)) {
                    initialMaterialStates.set(matId, {
                        originalOpacity: mat.opacity !== undefined ? mat.opacity : 1.0,
                        originalTransparent: mat.transparent || false,
                        originalDepthWrite: mat.depthWrite !== undefined ? mat.depthWrite : true,
                        wasCloned: false,
                        // Opcional: Guardar referencia al material original si se va a clonar
                        // originalMaterialRef: mat
                    });
                }
                 // Clonar solo si NO es ya un clon de esta animación O si no tiene la marca
                 if (!mat.clonedForDeathAnim) {
                     child.material = mat.clone();
                     child.material.clonedForDeathAnim = true; // Marcar el clon
                     initialMaterialStates.get(matId).wasCloned = true;
                 }
                 // Aplicar propiedades de transparencia al material actual (sea clon o no)
                child.material.transparent = true;
                child.material.depthWrite = false; // Necesario para fade out correcto
            }
        });

        if (!materialsFound) {
            console.warn(`No materials found on ${enemy.userData.name} for death animation.`);
            enemy.visible = false;
            scheduleEnemyRespawn(enemy); // Programar respawn directamente
            return;
        }

        let lastTimestamp = performance.now();

        function step(timestamp) {
            const delta = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;
            elapsed += delta;

            // Verificar si el enemigo sigue siendo válido
            if (!enemy.parent || !enemy.userData.isDead || !enemy.userData.isProcessingDeath) {
                console.log(`Death animation cancelled for ${enemy.userData.name}.`);
                // Podría intentar restaurar estado aquí si es necesario
                return;
            }

            const overallProgress = Math.min(1, elapsed / totalDuration);

            // --- Fase 1: Caída (Rotación) ---
            if (elapsed <= fallDuration) {
                const fallProgress = elapsed / fallDuration;
                const easedFallProgress = fallProgress * fallProgress * (3 - 2 * fallProgress); // EaseInOut
                // Slerp interpola entre quaternions
                enemy.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, easedFallProgress);
            }

            // --- Fase 2: Fundido y Encogimiento (Después de la caída) ---
            if (elapsed > fallDuration) {
                const fadeElapsed = elapsed - fallDuration;
                const fadeProgress = Math.min(1, fadeElapsed / fadeDuration);
                const easedFadeProgress = 1 - Math.pow(1 - fadeProgress, 3); // EaseOutCubic
                enemy.scale.lerpVectors(startScale, targetScale, easedFadeProgress);
                enemy.traverse(child => {
                    if (child.isMesh && child.material && (child.material.clonedForDeathAnim || initialMaterialStates.has(child.uuid))) {
                         const originalOpacity = (initialMaterialStates.get(child.uuid)?.originalOpacity) ?? 1.0;
                         child.material.opacity = Math.max(0, originalOpacity * (1 - easedFadeProgress));
                    }
                });
            }

            // --- Continuar o Finalizar ---
            if (overallProgress < 1) {
                requestAnimationFrame(step);
            } else {
                // --- Animación Completada ---
                enemy.visible = false;
                console.log(`  ${enemy.userData.name} hidden after death animation.`);

                // --- Restaurar Estado Visual Original ---
                enemy.scale.copy(startScale);
                enemy.quaternion.copy(startQuaternion); // Restaurar quaternion inicial
                enemy.traverse(child => {
                     if (child.isMesh && child.material) {
                         const originalState = initialMaterialStates.get(child.uuid);
                         if (originalState) {
                             // Restaurar propiedades en el material actual (sea clon o no)
                             child.material.opacity = originalState.originalOpacity;
                             child.material.transparent = originalState.originalTransparent;
                             child.material.depthWrite = originalState.originalDepthWrite;
                              // Limpiar flag
                              delete child.material.clonedForDeathAnim;
                         } else { // Fallback si no se guardó estado
                              child.material.opacity = 1.0;
                              child.material.transparent = false;
                              child.material.depthWrite = true;
                         }
                     }
                });

                // Programar Respawn (llama a scheduleEnemyRespawn)
                scheduleEnemyRespawn(enemy);
            }
        }
        requestAnimationFrame(step);
    } // Fin de animateDeath


   /**
    * Anima una muerte genérica (caída y fundido) para un enemigo.
    * Se llama cuando no se encuentra una animación de muerte dedicada.
    * Llama a onCompleteCallback al finalizar.
    * (v3 - Acepta callback, limpieza robusta)
    * @param {THREE.Object3D} enemy - El objeto 3D del enemigo.
    * @param {function} onCompleteCallback - Función a llamar cuando la animación termina.
    */
   function animateSimpleDeathFallback(enemy, onCompleteCallback) {
        // --- 1. Validaciones ---
        if (!enemy || !enemy.userData || !enemy.userData.isDead || !enemy.userData.isProcessingDeath) {
            console.warn("animateSimpleDeathFallback: Llamada inválida.");
            if(enemy && enemy.userData) enemy.userData.isProcessingDeath = false;
            if(typeof onCompleteCallback === 'function') {
                 try { onCompleteCallback(); } catch(e) { console.error("Error en callback inmediato de fallback:", e); }
            }
            return;
        }
        console.log(`  animateSimpleDeathFallback: Starting for ${enemy.userData.name}`);

        // --- 2. Constantes y Variables ---
        const fallDuration = 0.7; const fadeDuration = 1.3; const totalDuration = fallDuration + fadeDuration;
        let elapsed = 0;

        // --- 3. Estado Inicial ---
        const startScale = enemy.scale.clone(); const targetScale = new THREE.Vector3(0.01, 0.01, 0.01);
        const startQuaternion = enemy.quaternion.clone();
        const fallAxis = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
        if (fallAxis.lengthSq() === 0) fallAxis.set(1,0,0);
        const fallAngle = -Math.PI / 1.9 + (Math.random() - 0.5) * 0.3;
        const endQuaternion = new THREE.Quaternion().setFromAxisAngle(fallAxis, fallAngle);
        const startPosition = enemy.position.clone();
        const endPositionY = ChunkManager.getTerrainHeightAt(startPosition.x, startPosition.z) + 0.05;

        // --- 4. Preparar Materiales ---
        const initialMaterialStates = new Map();
        let materialsFound = false;
        enemy.traverse((child) => {
            if (child.isMesh && child.material) {
                materialsFound = true;
                const mat = child.material; const matId = child.uuid;
                if (!initialMaterialStates.has(matId)) { initialMaterialStates.set(matId, { originalOpacity: mat.opacity??1.0, originalTransparent: mat.transparent||false, originalDepthWrite: mat.depthWrite??true }); }
                if (!mat.clonedForDeathAnimFallback) { try { child.material = mat.clone(); child.material.clonedForDeathAnimFallback = true; } catch (cloneError) { console.error(`Error clonando mat fallback ${enemy.userData.name}:`, cloneError); child.material.transparent=true; child.material.depthWrite=false; return; } }
                child.material.transparent = true; child.material.depthWrite = false;
            }
        });

        if (!materialsFound) {
            console.warn(`No Mesh materials found in ${enemy.userData.name} for fallback death.`);
            if(typeof onCompleteCallback === 'function') {
                 try { onCompleteCallback(); } catch(e) { console.error("Error en callback inmediato de fallback sin materiales:", e); }
            }
            return;
        }

        // --- 5. Bucle de Animación ---
        let animationFrameId = null; // Para poder cancelar si es necesario
        let lastTimestamp = performance.now();
        function step(timestamp) {
            const delta = (timestamp - lastTimestamp) / 1000; lastTimestamp = timestamp; elapsed += delta;

            // Cancelar si el enemigo ya no es válido o no está procesando muerte
            if (!enemy.parent || !enemy.userData.isDead || !enemy.userData.isProcessingDeath) {
                console.log(`Fallback death anim cancelled externally for ${enemy.userData.name}.`);
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                // Intentar restaurar? Podría ser complicado/inseguro aquí.
                return;
            }

            const overallProgress = Math.min(1, elapsed / totalDuration);
            const easedOverallProgress = 1 - Math.pow(1 - overallProgress, 3);

            if (elapsed <= fallDuration) {
                const fallProgress = elapsed / fallDuration;
                enemy.quaternion.slerpQuaternions(startQuaternion, endQuaternion, fallProgress);
                enemy.position.y = THREE.MathUtils.lerp(startPosition.y, endPositionY, fallProgress);
            } else {
                 enemy.position.y = endPositionY; enemy.quaternion.copy(endQuaternion);
            }

            enemy.scale.lerpVectors(startScale, targetScale, easedOverallProgress);
            enemy.traverse(child => {
                if (child.isMesh && child.material && (child.material.clonedForDeathAnimFallback || initialMaterialStates.has(child.uuid))) {
                    const originalOpacity = (initialMaterialStates.get(child.uuid)?.originalOpacity) ?? 1.0;
                    child.material.opacity = Math.max(0, originalOpacity * (1 - easedOverallProgress));
                }
            });

            if (overallProgress < 1) { animationFrameId = requestAnimationFrame(step); }
            else {
                // --- Animación Completada ---
                console.log(`  Fallback death finished normally for ${enemy.userData.name}.`);
                // --- Restaurar Estado Visual Original (IMPORTANTE ANTES DE OCULTAR/RESPAWNEAR) ---
                try {
                     enemy.scale.copy(startScale);
                     enemy.quaternion.copy(startQuaternion);
                     enemy.position.copy(startPosition); // Restaurar Y original por si acaso
                     enemy.traverse(child => {
                          if (child.isMesh && child.material) {
                              const originalState = initialMaterialStates.get(child.uuid);
                              if (originalState) {
                                  const matToRestore = child.material;
                                  matToRestore.opacity = originalState.originalOpacity;
                                  matToRestore.transparent = originalState.originalTransparent;
                                  matToRestore.depthWrite = originalState.originalDepthWrite;
                                  delete matToRestore.clonedForDeathAnimFallback;
                              } else if(child.material.clonedForDeathAnimFallback) { // Si es clon pero sin estado guardado
                                   child.material.opacity = 1.0; child.material.transparent = false; child.material.depthWrite = true;
                                   delete child.material.clonedForDeathAnimFallback;
                              }
                          }
                     });
                } catch(restoreError) { console.error("Error restaurando estado visual en fallback:", restoreError); }

                // --- Llamar al Callback (que oculta y programa respawn) ---
                if (typeof onCompleteCallback === 'function') {
                    try { onCompleteCallback(); } catch(e) { console.error("Error en callback de fallback:", e); }
                }
            }
        }
        animationFrameId = requestAnimationFrame(step); // Iniciar el bucle
    } // Fin animateSimpleDeathFallback (v3)  
    
    
/**
     * Programa la reaparición de un enemigo después de un tiempo determinado.
     * Guarda el ID del timeout en userData para poder cancelarlo si es necesario.
     * @param {THREE.Object3D} enemy - El enemigo a reaparecer.
     */
    function scheduleEnemyRespawn(enemy) {
         if (!enemy || !enemy.userData) return;
         if (enemy.userData.respawnTimeoutId) clearTimeout(enemy.userData.respawnTimeoutId);
         const respawnDelay = enemy.userData.isUnique
             ? (enemy.userData.respawnTime ?? UNIQUE_ENEMY_RESPAWN_TIME)
             : (enemy.userData.respawnTime ?? ENEMY_RESPAWN_TIME);
         console.log(`  Scheduling respawn for ${enemy.userData.name} in ${respawnDelay} ms.`);
         enemy.userData.respawnTimeoutId = setTimeout(() => {
              console.log(`  Respawn timer finished for ${enemy.userData.name}.`);
              respawnEnemy(enemy);
              enemy.userData.respawnTimeoutId = null;
         }, respawnDelay);
    }
 
    
    /**
     * Reaparece un enemigo, restaurando su estado, posición y visibilidad.
     * @param {THREE.Object3D} enemy - El enemigo a reaparecer.
     */
    function respawnEnemy(enemy) {
        if (!enemy || !enemy.userData || enemy.userData.type !== 'enemy') {
             console.error("respawnEnemy: Intento de respawnear objeto inválido.");
             return;
        }
        console.log(`--- RESPAWNING ENEMY: ${enemy.userData.name} ---`);
        if (enemy.userData.respawnTimeoutId) { clearTimeout(enemy.userData.respawnTimeoutId); enemy.userData.respawnTimeoutId = null; }
        if (enemy.userData.deathFinishListener && enemy.userData.mixer) { try { enemy.userData.mixer.removeEventListener('finished', enemy.userData.deathFinishListener); } catch(e){} enemy.userData.deathFinishListener = null; }

        // --- Resetear Estado Lógico ---
        enemy.userData.health = enemy.userData.maxHealth; enemy.userData.isDead = false; enemy.userData.isProcessingDeath = false;
        enemy.userData.isAggro = false; enemy.userData.aiState = 'idle'; enemy.userData.target = null;
        enemy.userData.lastAttackTime = 0; enemy.userData.isKnockedBack = false;
        if (enemy.userData.knockbackVelocity) enemy.userData.knockbackVelocity.set(0,0,0);
        if (enemy.userData.statusEffects) enemy.userData.statusEffects = [];
        if (enemy.userData.lastAbilityTime) enemy.userData.lastAbilityTime = {};

        // --- Resetear Posición y Rotación ---
        if (enemy.userData.spawnPosition instanceof THREE.Vector3) {
            enemy.position.copy(enemy.userData.spawnPosition);
            const terrainY = ChunkManager.getTerrainHeightAt(enemy.position.x, enemy.position.z);
            enemy.position.y = terrainY + (enemy.userData.heightOffset || 0.1);
        } else { const fallbackY = ChunkManager.getTerrainHeightAt(0,0)+(enemy.userData.heightOffset||0.5); enemy.position.set(0, fallbackY, 0); console.warn(`RespawnEnemy: ${enemy.userData.name} sin spawnPosition.`); }
        enemy.rotation.set(0, Math.random() * Math.PI * 2, 0);
        enemy.updateMatrixWorld(true);

        // --- Restaurar Apariencia Visual ---
         enemy.scale.set(1, 1, 1);
         enemy.traverse(child => {
             if (child.isMesh && child.material) {
                 const originalProps = child.userData?.originalMaterialProperties;
                 const mat = child.material;
                 if (originalProps) {
                      mat.opacity = originalProps.originalOpacity ?? 1.0;
                      mat.transparent = originalProps.originalTransparent || false;
                      mat.depthWrite = originalProps.originalDepthWrite ?? true;
                      delete child.userData.originalMaterialProperties;
                 } else {
                      mat.opacity = 1.0; mat.transparent = false; mat.depthWrite = true;
                 }
                 delete mat.clonedForDeathAnim; delete mat.clonedForDeathAnimFallback;
             }
         });
        enemy.visible = true;

        // --- Resetear Animation Mixer ---
        if (enemy.userData.mixer) {
            try {
                 enemy.userData.mixer.stopAllAction();
                 const animations = enemy.userData.animations || {};
                 const idleClip = animations['idle'] || animations['idle_base'] || Object.values(animations)[0];
                 if (idleClip) { enemy.userData.mixer.clipAction(idleClip).reset().play(); }
            } catch(e) { console.error("Error reseteando mixer en respawn:", e); }
        }
        // logMessage(`${enemy.userData.name} ha reaparecido.`, 'system');
    }
    
    /**
     * Reproduce una animación específica para un enemigo.
     * Maneja transiciones suaves (crossfade) y bucles.
     * @param {THREE.Object3D} enemy - El objeto del enemigo.
     * @param {string} animationName - El nombre de la animación a reproducir (ej: 'walk', 'attack').
     * @param {number} [crossfadeDuration=0.25] - Duración de la transición en segundos.
     * @param {boolean} [loop=true] - Si la animación debe repetirse.
     * @param {number} [timeScale=1.0] - Velocidad de reproducción.
     */
    function playEnemyAnimation(enemy, animationName, crossfadeDuration = 0.25, loop = true, timeScale = 1.0) {
        // Validar entradas básicas
        if (!enemy || !enemy.userData || !animationName) {
            // console.warn("playEnemyAnimation: Datos de entrada inválidos.");
            return;
        }

        const mixer = enemy.userData.mixer;
        const animations = enemy.userData.animations;

        // Validar que el mixer y las animaciones existan
        if (!mixer || typeof animations !== 'object' || animations === null) {
            // console.warn(`playEnemyAnimation: Mixer o animaciones no encontradas para ${enemy.userData.name}`);
             return;
        }

        const nameLower = animationName.toLowerCase();
        // Buscar clip: nombre exacto, sin _, con _base, fallback a idle o el primero
        const clip = animations[nameLower]
                  || animations[nameLower.replace('_', '')]
                  || animations[nameLower + '_base']
                  || animations['idle'] // Intentar fallback a idle explícito
                  || Object.values(animations)[0]; // Último recurso: la primera animación disponible

        if (!clip) {
            // Evitar spam si la animación 'idle' tampoco existe
            if (animationName !== 'idle' && !playEnemyAnimation.warnedMissing) {
                console.warn(`Animación enemigo no encontrada ni fallback: ${animationName} para ${enemy.userData?.name}`);
                playEnemyAnimation.warnedMissing = true; // Advertir solo una vez por sesión?
                setTimeout(() => { playEnemyAnimation.warnedMissing = false; }, 5000); // Resetear advertencia
            }
            // Intentar reproducir 'idle' si la solicitada no existe y 'idle' sí
            if(animationName !== 'idle' && animations['idle']) {
                 playEnemyAnimation(enemy, 'idle', crossfadeDuration, true, timeScale); // Llamada recursiva segura (solo si idle existe)
            }
            return; // Salir si no hay clip válido
        }

        let targetAction;
        try {
             targetAction = mixer.clipAction(clip);
             if (!targetAction) throw new Error("clipAction devolvió undefined");
        } catch (e) {
             console.error(`Error al obtener clipAction para '${clip.name}' en ${enemy.userData.name}:`, e);
             return; // Salir si no se puede obtener la acción
        }


        const currentAction = enemy.userData.currentAction || null;

        // Si ya está reproduciendo la misma animación en bucle, solo ajustar timescale si es necesario
        if (currentAction === targetAction && targetAction.isRunning() && targetAction.loop === THREE.LoopRepeat) {
            if (targetAction.timeScale !== timeScale) {
                targetAction.setEffectiveTimeScale(timeScale);
            }
            return; // Ya está haciendo lo correcto
        }

        // Configurar la nueva acción
        targetAction.reset();
        targetAction.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce, loop ? Infinity : 1);
        targetAction.clampWhenFinished = !loop; // Detener en el último frame si no es loop
        targetAction.setEffectiveTimeScale(timeScale);
        targetAction.weight = 1; // Asegurar peso completo

        // Hacer transición suave si hay una acción anterior corriendo y es diferente
        if (currentAction && currentAction !== targetAction && currentAction.isRunning()) {
            // Detener la acción anterior antes de hacer fade? A veces ayuda con glitches.
            // currentAction.stop(); // Opcional: probar si el crossfade solo no funciona bien
            currentAction.crossFadeTo(targetAction, crossfadeDuration, true); // true = warp (sincronizar tiempos)
        }

        // Iniciar la nueva acción (asegurarse de que no esté ya corriendo por si acaso)
         if (!targetAction.isRunning()) {
             targetAction.play();
         }
        enemy.userData.currentAction = targetAction; // Guardar acción actual
    }
    playEnemyAnimation.warnedMissing = false; // Flag para controlar warnings de animación faltante
    
    
    
/**
 * Actualiza la IA y el estado de un único enemigo.
 * Incluye lógica para retirarse de zonas seguras.
 * (v8 - Zona Segura + Refinamientos)
 * @param {THREE.Object3D} enemy - El objeto 3D del enemigo.
 * @param {number} deltaTime - Tiempo transcurrido.
 */
function updateSingleEnemy(enemy, deltaTime) {
    // --- 0. Validaciones Esenciales ---
    if (!enemy || !enemy.userData || enemy.userData.type !== 'enemy' || enemy.userData.isDead || enemy.userData.isProcessingDeath || !enemy.position || !playerState?.position) {
        return;
    }

    const enemyData = enemy.userData;
    const enemyPos = enemy.position;
    const playerPos = playerState.position;

    // --- 1. Procesar Knockback (SIEMPRE PRIMERO) ---
    if (enemyData.isKnockedBack && enemyData.knockbackVelocity instanceof THREE.Vector3) {
        const knockbackDelta = enemyData.knockbackVelocity.clone().multiplyScalar(deltaTime);
        enemyPos.add(knockbackDelta);
        enemyData.knockbackVelocity.multiplyScalar(1 - (8 * deltaTime));
        const terrainHeight = ChunkManager.getTerrainHeightAt(enemyPos.x, enemyPos.z);
        const finalHeightOffset = enemyData.heightOffset ?? 0.1;
        enemyPos.y = Math.max(terrainHeight + finalHeightOffset, enemyPos.y);
        if (enemyData.knockbackVelocity.lengthSq() < 0.01) {
            enemyData.isKnockedBack = false;
            enemyData.knockbackVelocity.set(0, 0, 0);
            enemyData.aiState = enemyData.isAggro ? 'chasing' : 'idle';
        }
        // Animar reacción a golpe
        if (enemyData.aiState !== 'staggered') playEnemyAnimation(enemy, 'hit_reaction', 0.1, false);
        return; // Salir si está en knockback
    }

    // --- 2. Comprobar Zona Segura ---
    let isInSafeZone = false;
    let shouldReturnToSpawn = false;
    for (const city of (worldData.cities || [])) {
        if (city.isSafeZone && city.center && city.radius) {
            const distanceToCitySq = enemyPos.distanceToSquared(city.center);
            if (distanceToCitySq < city.radius ** 2) {
                // ¡El enemigo está DENTRO de la zona segura!
                isInSafeZone = true;
                shouldReturnToSpawn = true; // Forzar retorno
                break; // Salir del bucle de ciudades
            }
            // Opcional: Comprobar si el JUGADOR está en zona segura para detener la persecución
            // const playerDistSq = playerPos.distanceToSquared(city.center);
            // if (playerDistSq < city.radius ** 2 && enemyData.isAggro) {
            //     shouldReturnToSpawn = true;
            //     logMessage(`${enemyData.name} se retira (objetivo en zona segura).`);
            //     break; // También forzar retorno si el jugador entra
            // }
        }
    }

    // --- 3. Si está en Zona Segura -> RETIRARSE ---
    if (shouldReturnToSpawn) {
        if (enemyData.aiState !== 'returning') { // Solo cambiar si no está ya volviendo
             console.log(`${enemyData.name} entrando/persiguiendo en zona segura, retirándose!`);
             enemyData.isAggro = false; enemyData.target = null; enemyData.aiState = 'returning';
        }
        // Ejecutar lógica de 'returning'
        const spawnPos = enemyData.spawnPosition;
        if (spawnPos) {
            const direction = new THREE.Vector3().subVectors(spawnPos, enemyPos); direction.y = 0;
            if (direction.lengthSq() > 1) {
                direction.normalize(); const returnSpeed = (enemyData.wanderSpeed || 1.2) * 1.8;
                enemyPos.addScaledVector(direction, returnSpeed * deltaTime);
                // Rotar hacia spawn
                const targetAngle = Math.atan2(direction.x, direction.z);
                const currentAngle = enemy.rotation.y; const angleDiff = normalizeAngle(targetAngle - currentAngle);
                enemy.rotation.y = normalizeAngle(currentAngle + angleDiff * Math.PI * 2.0 * deltaTime);
                playEnemyAnimation(enemy, 'run'); // Correr para volver
            } else { enemyData.aiState = 'idle'; playEnemyAnimation(enemy, 'idle'); } // Llegó
        } else { enemyData.aiState = 'idle'; playEnemyAnimation(enemy, 'idle'); } // Sin spawn, ir a idle

        // Ajustar altura
        const terrainHeight = ChunkManager.getTerrainHeightAt(enemyPos.x, enemyPos.z);
        enemyPos.y = Math.max(terrainHeight + (enemyData.heightOffset ?? 0.1), enemyPos.y);
        return; // SALIR de la IA si está en zona segura
    } // --- Fin Check Zona Segura ---


    // --- 4. Variables y Constantes Comunes (si no está en zona segura) ---
    const now = Date.now();
    const distanceToPlayerSq = enemyPos.distanceToSquared(playerPos);
    const detectionRangeSq = (enemyData.detectionRange || 18)**2;
    const attackRangeSq = (enemyData.attackRange || 2.0)**2;
    const loseAggroRangeSq = (enemyData.loseAggroRange || 30)**2;
    const spawnPos = enemyData.spawnPosition instanceof THREE.Vector3 ? enemyData.spawnPosition : null;
    const returnToSpawnDistSq = (enemyData.maxWanderDistance || 25)**2;
    const fleeHealthPercent = enemyData.fleeHealthPercent || 0.15;
    let currentState = enemyData.aiState || 'idle';
    let targetObject = enemyData.target;

    // --- 5. TRANSICIONES DE ESTADO (Normales) ---
    if (currentState === 'staggered' || currentState === 'paralyzed') {
        playEnemyAnimation(enemy, 'hit_reaction');
        return;
    }

    // --- 5.a. HUIDA por baja salud ---
    if (currentState !== 'fleeing' && currentState !== 'returning' && enemyData.canFlee !== false && (enemyData.health / enemyData.maxHealth) <= fleeHealthPercent) {
        currentState = 'fleeing'; enemyData.target = null; enemyData.isAggro = false; AudioManager.playSound('enemy_flee', 0.5);
    } else if (currentState === 'fleeing') {
        if (distanceToPlayerSq > loseAggroRangeSq * 1.3 || gameState.isGhost) { currentState = 'returning'; }
    }
    // --- 5.b. RETORNO al spawn (si no fue forzado por zona segura) ---
    else if (currentState === 'returning') {
        if (!spawnPos || enemyPos.distanceToSquared(spawnPos) < 2 * 2) { currentState = 'idle'; enemyData.wanderTarget = null; }
    }
    // --- 5.c. Lógica de AGGRO ---
    else if (enemyData.isAggro) {
        const targetValid = targetObject && targetObject.userData && !targetObject.userData.isDead && !(targetObject === playerModel && gameState.isGhost);
        if (!targetValid || distanceToPlayerSq > loseAggroRangeSq) {
            enemyData.isAggro = false; currentState = 'returning'; enemyData.target = null;
        } else {
            const distanceToTargetSq = enemyPos.distanceToSquared(targetObject.position);
            const canSeeTarget = checkLineOfSight(enemyPos.clone().add(new THREE.Vector3(0, enemyData.heightOffset * 0.8, 0)), targetObject.position.clone().add(new THREE.Vector3(0, (targetObject.userData.heightOffset || PLAYER_HALF_HEIGHT), 0)));

            if (canSeeTarget) {
                 let usedAbility = false;
                 if (enemyData.abilities && enemyData.abilities.length > 0 && Math.random() < 0.08) {
                     for (const ability of enemyData.abilities) { /* ... lógica de usar habilidad ... */ }
                 }
                 if (!usedAbility) {
                     if (distanceToTargetSq <= attackRangeSq) { currentState = 'attacking'; } else { currentState = 'chasing'; }
                 } else { currentState = 'attacking'; }
            } else { currentState = 'chasing'; } // Seguir persiguiendo si pierde LOS pero tiene aggro
        }
    }
    // --- 5.d. Detección/Wander (SIN AGGRO) ---
    else {
        if (distanceToPlayerSq < detectionRangeSq && !gameState.isGhost) {
            const canSee = checkLineOfSight(enemyPos.clone().add(new THREE.Vector3(0, enemyData.heightOffset * 0.8, 0)), playerPos.clone().add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT, 0)));
            if (canSee) { enemyData.isAggro = true; currentState = 'chasing'; enemyData.target = playerModel; }
        }
        if (!enemyData.isAggro) {
            if (currentState === 'idle' && Math.random() < 0.015) { currentState = 'wandering'; enemyData.wanderTarget = findWanderTarget(enemyPos, spawnPos, returnToSpawnDistSq**0.5); }
            else if (currentState === 'wandering') { const wt = enemyData.wanderTarget; if (!wt || enemyPos.distanceToSquared(wt) < 1.5*1.5 || Math.random() < 0.008 || (spawnPos && enemyPos.distanceToSquared(spawnPos) > returnToSpawnDistSq * 1.1)) { currentState = 'idle'; enemyData.wanderTarget = null; if (spawnPos && enemyPos.distanceToSquared(spawnPos) > returnToSpawnDistSq) { currentState = 'returning'; } } }
            else { currentState = 'idle'; }
        }
    }
    enemyData.aiState = currentState;

    // --- 6. DETERMINAR OBJETIVO DE MOVIMIENTO Y ROTACIÓN ---
    let targetPosition = null; let lookAtPosition = null; let animationToPlay = 'idle';
    const moveSpeedBase = enemyData.isAggro ? (enemyData.chaseSpeed || 3.5) : (enemyData.wanderSpeed || 1.2);
    const turnSpeed = Math.PI * (enemyData.isAggro ? 2.2 : 1.0);

    if (currentState === 'chasing' && enemyData.target?.position) { targetPosition = enemyData.target.position; lookAtPosition = targetPosition; animationToPlay = 'walk'; }
    else if (currentState === 'wandering' && enemyData.wanderTarget instanceof THREE.Vector3) { targetPosition = enemyData.wanderTarget; lookAtPosition = targetPosition; animationToPlay = 'walk'; }
    else if (currentState === 'returning' && spawnPos instanceof THREE.Vector3) { targetPosition = spawnPos; lookAtPosition = targetPosition; animationToPlay = 'run'; } // Corre para volver
    else if (currentState === 'fleeing') { targetPosition = playerPos; lookAtPosition = null; animationToPlay = 'run'; } // Corre para huir
    else if (currentState === 'attacking' && enemyData.target?.position) { targetPosition = null; lookAtPosition = enemyData.target.position; animationToPlay = 'attack_idle'; }
    else { animationToPlay = 'idle'; }

    // --- 7. APLICAR MOVIMIENTO Y ROTACIÓN ---
    // Rotación
    if (lookAtPosition instanceof THREE.Vector3) {
        const directionToLook = new THREE.Vector3().subVectors(lookAtPosition, enemyPos); directionToLook.y = 0;
        if (directionToLook.lengthSq() > 0.01) {
            const targetAngle = Math.atan2(directionToLook.x, directionToLook.z); const currentAngle = enemy.rotation.y;
            const angleDiff = normalizeAngle(targetAngle - currentAngle); const maxRotation = turnSpeed * deltaTime;
            enemy.rotation.y = normalizeAngle(currentAngle + Math.max(-maxRotation, Math.min(maxRotation, angleDiff)));
        }
    }
// Movimiento (con evasión simple)
if (targetPosition instanceof THREE.Vector3) {
    const directionToMoveRaw = new THREE.Vector3().subVectors(targetPosition, enemyPos);
    directionToMoveRaw.y = 0; // Ignorar diferencia vertical para dirección base
    const targetDistSq = directionToMoveRaw.lengthSq();
    const shouldMove = (currentState === 'chasing' || currentState === 'wandering' || currentState === 'returning' || currentState === 'fleeing');
    const tooCloseToAttack = (currentState === 'attacking' || currentState === 'chasing') && targetDistSq < attackRangeSq * 0.6;

    if (shouldMove && !tooCloseToAttack && targetDistSq > 0.01) {
        let moveDirectionBase = directionToMoveRaw.normalize(); // Dirección ideal
        if (currentState === 'fleeing') moveDirectionBase.negate(); // Invertir para huir

        // *** LLAMADA A LA NUEVA FUNCIÓN DE EVASIÓN ***
        const finalMoveDirection = avoidObstacles(enemy, moveDirectionBase, deltaTime);
        // *******************************************

        const moveSpeed = currentState === 'fleeing' ? moveSpeedBase * 1.3 : moveSpeedBase;
        const moveAmount = moveSpeed * deltaTime;

        // Aplicar el movimiento usando la dirección FINAL (ajustada o no)
        enemyPos.addScaledVector(finalMoveDirection, moveAmount);

    }
}
    // --- 8. ATAQUE ---
    if (currentState === 'attacking') {
        if (now - enemyData.lastAttackTime > (enemyData.attackCooldown || 2000)) {
            if (enemyData.target?.position && enemyPos.distanceToSquared(enemyData.target.position) <= attackRangeSq * 1.1) {
                 const canSee = checkLineOfSight(enemyPos.clone().add(new THREE.Vector3(0, enemyData.heightOffset * 0.8, 0)), enemyData.target.position.clone().add(new THREE.Vector3(0, (enemyData.target.userData.heightOffset || PLAYER_HALF_HEIGHT), 0)));
                 if (canSee) {
                      const direction = new THREE.Vector3().subVectors(enemyData.target.position, enemyPos); enemy.rotation.y = normalizeAngle(Math.atan2(direction.x, direction.z));
                      attackPlayer(enemy); enemyData.lastAttackTime = now;
                      animationToPlay = 'attack'; // Animación de ataque
                 } else { currentState = 'chasing'; enemyData.aiState = 'chasing'; animationToPlay = 'walk'; }
            } else { currentState = 'chasing'; enemyData.aiState = 'chasing'; animationToPlay = 'walk'; }
        } else { animationToPlay = 'attack_idle'; }
    }

    // --- 9. AJUSTAR ALTURA Y GRAVEDAD ---
    const terrainHeight = ChunkManager.getTerrainHeightAt(enemyPos.x, enemyPos.z);
    const finalHeightOffset = enemyData.heightOffset ?? 0.1;
    const isOnGround = enemyPos.y <= terrainHeight + finalHeightOffset + 0.15;
    if (!isOnGround) { if (!enemyData.verticalVelocity) enemyData.verticalVelocity = 0; enemyData.verticalVelocity += GRAVITY * deltaTime * 0.9; enemyPos.y += enemyData.verticalVelocity * deltaTime; }
    else { if(enemyData.verticalVelocity && enemyData.verticalVelocity < 0) enemyData.verticalVelocity = 0; }
    enemyPos.y = Math.max(terrainHeight + finalHeightOffset, enemyPos.y);

    // --- 10. ACTUALIZAR ANIMACIÓN ---
    try { if (typeof playEnemyAnimation === 'function') playEnemyAnimation(enemy, animationToPlay); }
    catch (animError) { console.error(`Error animando ${enemyData.name} a '${animationToPlay}':`, animError); }

} // --- Fin updateSingleEnemy (v8) ---

/**
 * Verifica si hay una línea de visión directa entre dos puntos.
 * (v2 - Sin cambios)
 * @param {THREE.Vector3} startPos - Punto de inicio del rayo.
 * @param {THREE.Vector3} endPos - Punto final del rayo (objetivo).
 * @returns {boolean} True si hay línea de visión, False si está bloqueada.
 */
function checkLineOfSight(startPos, endPos) {
     // ... (código completo de checkLineOfSight v2 que te proporcioné antes) ...
      const direction = new THREE.Vector3().subVectors(endPos, startPos);
      const distance = direction.length();
      if(distance < 0.1) return true;
      direction.normalize();

      const sightRaycaster = window.collisionRaycasterLOS || new THREE.Raycaster();
      window.collisionRaycasterLOS = sightRaycaster;

      sightRaycaster.set(startPos.clone().add(new THREE.Vector3(0, 0.1, 0)), direction);
      sightRaycaster.near = 0.1;
      sightRaycaster.far = distance - 0.1;

      const obstacles = [];
      const checkedChunks = new Set();
      const playerCX = Math.floor((playerState.position.x + worldData.size.width/2) / worldData.chunkSize);
      const playerCZ = Math.floor((playerState.position.z + worldData.size.depth/2) / worldData.chunkSize);
      const targetCX = Math.floor((endPos.x + worldData.size.width/2) / worldData.chunkSize);
      const targetCZ = Math.floor((endPos.z + worldData.size.depth/2) / worldData.chunkSize);
      const checkRadius = 1;

      for (let dx = -checkRadius; dx <= checkRadius; dx++) {
          for (let dz = -checkRadius; dz <= checkRadius; dz++) {
              const keyPlayer = `${playerCX + dx}_${playerCZ + dz}`;
              if (!checkedChunks.has(keyPlayer)) {
                  const chunkPlayer = ChunkManager.activeChunks.get(keyPlayer);
                  if (chunkPlayer?.terrainMesh?.visible) obstacles.push(chunkPlayer.terrainMesh);
                  if (chunkPlayer?.objects) obstacles.push(...chunkPlayer.objects.filter(o => o?.visible && o.userData?.boundingBox));
                  checkedChunks.add(keyPlayer);
              }
              const keyTarget = `${targetCX + dx}_${targetCZ + dz}`;
               if (!checkedChunks.has(keyTarget)) {
                   const chunkTarget = ChunkManager.activeChunks.get(keyTarget);
                   if (chunkTarget?.terrainMesh?.visible && !obstacles.includes(chunkTarget.terrainMesh)) obstacles.push(chunkTarget.terrainMesh);
                   if (chunkTarget?.objects) obstacles.push(...chunkTarget.objects.filter(o => o?.visible && o.userData?.boundingBox));
                   checkedChunks.add(keyTarget);
              }
          }
      }
      const validObstacles = obstacles.filter(o => o && o !== playerModel); // Excluir jugador
      try {
          const intersects = sightRaycaster.intersectObjects(validObstacles, true);
          const filteredIntersects = intersects.filter(intersect => {
               let parentObj = intersect.object; let depth = 0;
               while(parentObj.parent && !parentObj.userData?.type && depth < 5) { parentObj = parentObj.parent; depth++; }
               return parentObj !== playerModel;
          });
          if (filteredIntersects.length > 0) {
              console.log(`[LOS Check] Blocked by: ${filteredIntersects[0].object.name || 'Unknown'} at dist ${filteredIntersects[0].distance.toFixed(1)}`);
              return false;
          }
          return true;
      } catch(e){ console.error("Error en Raycaster LOS:", e); return false; }
}

/**
 * Obtiene la altura del suelo en una coordenada XZ,
 * considerando si el jugador está en el mundo o en un dungeon.
 * (NUEVA v1)
 * @param {number} worldX - Coordenada X en el mundo/dungeon.
 * @param {number} worldZ - Coordenada Z en el mundo/dungeon.
 * @returns {number} La altura Y del suelo, o un valor por defecto si no se encuentra.
 */
function getGroundHeightAt(worldX, worldZ) {
    if (gameState.currentLocation === 'world') {
        // Si estamos en el overworld, usar ChunkManager
        if (typeof ChunkManager !== 'undefined' && ChunkManager.getTerrainHeightAt) {
            return ChunkManager.getTerrainHeightAt(worldX, worldZ);
        } else {
            // console.warn("getGroundHeightAt: ChunkManager no disponible en overworld.");
            return WATER_LEVEL; // Fallback para overworld
        }
    } else {
        // Si estamos en un dungeon, hacer raycast hacia abajo contra la geometría del dungeon
        const dungeonGroup = world.dungeon?.geometryGroup;
        const floorMesh = dungeonGroup?.getObjectByName("DungeonFloor"); // Asume que el suelo se llama así

        if (!floorMesh || !raycaster) {
            // console.warn("getGroundHeightAt: Geometría de suelo dungeon o raycaster no disponible.");
            return 0; // Fallback para dungeon (asume suelo en Y=0)
        }

        try {
            // Raycast desde arriba hacia abajo
            const rayOrigin = new THREE.Vector3(worldX, 50, worldZ); // Empezar desde arriba
            const rayDirection = new THREE.Vector3(0, -1, 0);
            raycaster.set(rayOrigin, rayDirection);
            raycaster.far = 100; // Distancia suficiente

            const intersects = raycaster.intersectObject(floorMesh, false); // No recursivo

            if (intersects.length > 0) {
                return intersects[0].point.y; // Retorna la altura Y de la intersección
            } else {
                // Si no intersecta (ej. fuera de los límites del suelo definido), retornar 0
                return 0;
            }
        } catch (e) {
            console.error("Error en raycast de suelo dungeon:", e);
            return 0; // Fallback en caso de error
        }
    }
}
 
    function findWanderTarget(currentPos, spawnPos, maxDistance) {
         const angle = Math.random() * Math.PI * 2;
         const distance = Math.random() * maxDistance * 0.6 + maxDistance * 0.3; // 30%-90% de la distancia max
         let targetX = currentPos.x + Math.cos(angle) * distance;
         let targetZ = currentPos.z + Math.sin(angle) * distance;
         // Limitar al radio de spawn si se proporciona
         if (spawnPos && maxDistance > 0) {
            const distFromSpawnSq = (targetX - spawnPos.x)**2 + (targetZ - spawnPos.z)**2;
             const maxDistSq = maxDistance * maxDistance * 1.1; // Permitir un poco más allá
             if (distFromSpawnSq > maxDistSq) {
                 // Si se aleja demasiado, redirigir hacia el spawn point
                 targetX = spawnPos.x + (Math.random() - 0.5) * maxDistance * 0.5; // Más cerca del spawn
                 targetZ = spawnPos.z + (Math.random() - 0.5) * maxDistance * 0.5;
             }
         }
        const targetY = ChunkManager.getTerrainHeightAt(targetX, targetZ);
        // Comprobar si el punto es válido (no agua, no dentro de otro objeto?)
        const biome = getBiome(targetX, targetZ);
        if (targetY < WATER_LEVEL + 0.1 || biome === 'water') return null; // No ir al agua
        // Podría añadirse un check simple de colisión con objetos grandes aquí
        return new THREE.Vector3(targetX, targetY, targetZ);
     }


function attackPlayer(enemy) {
    // --- Validaciones ---
    if (gameState.isGhost || !enemy?.userData || !playerModel?.userData) return;

    // --- Calcular Daño Base del Enemigo ---
    const damageMin = enemy.userData.damage?.min || 3;
    const damageMax = enemy.userData.damage?.max || 6;
    const damageType = enemy.userData.damage?.type || 'physical';
    let baseDamage = Math.floor(Math.random() * (damageMax - damageMin + 1)) + damageMin;

    // --- Determinar si fue Bloqueado o Parado (Parry) ---
    let blocked = false;
    let parried = false;
    if (playerState.isBlocking && damageType === 'physical') {
        const playerForward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), playerState.rotationY);
        const dirFromEnemy = new THREE.Vector3().subVectors(playerState.position, enemy.position).normalize();
        const dotProduct = playerForward.dot(dirFromEnemy);

        if (dotProduct > 0.3) { // Ángulo frontal
            if (playerState.isParrying) {
                parried = true;
                // -- Lógica de Parry (Ejecutada AQUÍ, ANTES de applyDamage) --
                AudioManager.playSound('parry_success', 0.7);
                showFloatingText('system-text', "¡PARRY!", playerState.position.clone().add(new THREE.Vector3(0, 1.2, 0)));
                playerState.stats.stamina = Math.min(playerState.stats.maxStamina, playerState.stats.stamina + PARRY_STAMINA_REWARD);
                updatePlayerUI();
                // Aplicar stagger al enemigo
                addStatusEffectToTarget(enemy.userData, {
                    id: 'stagger', name: 'Aturdido', icon: 'fa-star', duration: PARRY_STAGGER_DURATION / 1000,
                    onApply: (t) => { t.aiState = 'staggered'; if (t.mixer) t.mixer.stopAllAction(); },
                    onEnd: (t) => { if (!t.isDead) t.aiState = t.isAggro ? 'chasing' : 'idle'; },
                    class: 'status-stun', description: 'Incapacitado temporalmente.'
                });
                playerState.isParrying = false; // Consumir parry window
                // --- FIN Lógica Parry ---
            } else {
                blocked = true; // Fue bloqueo normal
                AudioManager.playSound('block', 0.5); // Sonido de bloqueo
            }
        }
    }

    // --- Llamar a applyDamage PASANDO el daño BASE y los flags ---
    // applyDamage ahora hará todas las reducciones y devolverá el daño real
    const actualDamageDealt = applyDamage(playerModel, baseDamage, damageType, false, blocked, parried);

    // --- Loguear el DAÑO REAL APLICADO ---
    if (!parried) { // No loguear si fue parry exitoso (ya tiene su propio mensaje)
        // Comprobar si se esquivó (applyDamage devuelve 0 si es invulnerable)
        if (actualDamageDealt === 0 && playerState.isInvulnerable) {
             logMessage(`¡Esquivaste el ataque de ${enemy.userData.name}!`, 'info');
             // El texto flotante "Esquiva" ya lo puso applyDamage
        } else if (actualDamageDealt > 0) {
            logMessage(`${enemy.userData.name} te ataca por ${actualDamageDealt} de daño ${damageType}${blocked ? ' (Bloqueado)' : ''}.`, 'combat');
        } else if (blocked) { // Bloqueado pero daño final fue 0
            logMessage(`Bloqueaste completamente el ataque de ${enemy.userData.name}.`, "combat");
            showFloatingText("system-text", `Bloqueado (0)`, playerState.position.clone().add(new THREE.Vector3(0,1.2,0))); // Texto flotante
        } else if (actualDamageDealt <= 0 && baseDamage > 0) { // No bloqueado, pero daño 0 (por defensas/resists)
            logMessage(`El ataque de ${enemy.userData.name} no te hizo daño.`, "combat");
        }
    }

    // Aplicar habilidades del enemigo (si no fue parry y si golpeó - daño > 0 O no bloqueado)
    if (enemy.userData.abilities && !parried && actualDamageDealt >= 0 && !blocked) {
        enemy.userData.abilities.forEach(ability => {
            if (ability.id === 'poison_attack' && Math.random() < (ability.chance || 0)) {
                addStatusEffect({...POISON_EFFECT_DATA});
            }
            // Añadir más habilidades aquí
        });
    }
}
    function executeEnemyAbility(enemy, target, ability) {
         const enemyData = enemy.userData;
         console.log(`${enemyData.name} usa ${ability.id}`);
         // playEnemyAnimation(enemy, ability.animation || 'attack_special', 0.1, false);

         switch(ability.id) {
              case 'poison_attack': // Este se aplica en attackPlayer ahora
                   break;
              case 'cast_magic_arrow':
                   if(spellDefinitions.magic_arrow && target?.position) {
                        const targetPos = target.position.clone().add(new THREE.Vector3(0, target.userData.heightOffset || 0.6, 0));
                        createProjectile(enemy, targetPos, 'magic_arrow'); // Enemigo lanza flecha mágica
                        AudioManager.playSound('spell_cast', 0.4); // Sonido diferente para enemigo?
                   }
                   break;
              case 'charge':
                   enemyData.aiState = 'charging';
                   const direction = new THREE.Vector3().subVectors(target.position, enemy.position).normalize();
                   enemyData.knockbackVelocity = direction.multiplyScalar( (ability.chargeSpeed || 8) );
                   enemyData.isKnockedBack = true; // Usar flag knockback para el movimiento
                   setTimeout(() => { if(enemyData.aiState === 'charging') { enemyData.knockbackVelocity.set(0,0,0); enemyData.isKnockedBack = false; enemyData.aiState = 'chasing';} }, ability.chargeDuration || 1000);
                   break;
              case 'cast_curse': // Ejemplo Debuff
                   if (target?.userData) {
                       addStatusEffectToTarget(target.userData, {id:'curse', name:'Maldición', icon:'fa-skull', duration: 15, statsModifiers:{defense:-5, magicResist:-5}, class:'status-debuff', description:'Defensas reducidas.'});
                       AudioManager.playSound('spell_buff', 0.5); // Sonido placeholder
                   }
                   break;
               // Añadir más habilidades
         }
    }

    /**
     * Maneja la muerte del jugador.
     * Activa estado fantasma, suelta TODO el inventario y equipo (no quest items).
     * El bucle principal de updateGame CONTINUARÁ ejecutándose.
     * (v8 - Integrated Loop)
     */
    function playerDeath() {
        // 1. --- Prevent Multiple Executions & Validate ---
        if (gameState.isGhost || !playerState || !playerState.position) {
            console.log("playerDeath: Already ghost or invalid player state.");
            return;
        }

        console.log("Player has died. Processing death...");
        gameState.isGhost = true; // <<< SET GHOST STATE
        gameState.isGameOver = true;
        gameState.isPlaying = true;  // Keep playing
        gameState.isPaused = false;

        // --- 2. Save Death Location & Stop Actions ---
        playerState.lastWorldPosition = playerState.position.clone();
        playerState.lastWorldRotationY = playerState.rotationY;
        // Stop all player actions (same as before)
        Object.keys(controls).forEach(key => { if (typeof controls[key] === 'boolean') controls[key] = false; if (typeof controls[key] === 'number') controls[key] = 0; });
        playerState.isChargingAttack = false; playerState.isAttacking = false; playerState.isBlocking = false; playerState.isDodging = false; playerState.isSprinting = false; playerState.isJumping = false;
        if (playerState.castingSpellTimeoutId) { clearTimeout(playerState.castingSpellTimeoutId); playerState.castingSpellTimeoutId = null; playerState.isCastingSpell = false; }
        if (gameState.isAimingWithBow) cancelAiming();
        if (gameState.isTargetingSpell) exitSpellTargetingMode();
        if (playerState.mixer) playerState.mixer.stopAllAction();

        console.log(`Death location recorded: (${playerState.lastWorldPosition.x.toFixed(1)}, ${playerState.lastWorldPosition.y.toFixed(1)}, ${playerState.lastWorldPosition.z.toFixed(1)})`);

        // --- 3. Drop Inventory & Equipment (Same as before) ---
        const itemsToDrop = [];
        const baseDropPosition = playerState.lastWorldPosition.clone();
        // Collect from inventory
        inventory.items.forEach(item => { if (item && !itemDefinitions[item.id]?.questItem) itemsToDrop.push({ ...item }); });
        inventory.items = []; inventory.selectedItemIndex = null;
        // Collect from equipment
        let equipmentDroppedCount = 0;
        for (const slot in playerState.equipment) { const equippedItem = playerState.equipment[slot]; if (equippedItem && !itemDefinitions[equippedItem.id]?.questItem) { const itemToDrop = { ...equippedItem, count: 1 }; itemsToDrop.push(itemToDrop); equipmentDroppedCount++; } playerState.equipment[slot] = null; }
        console.log(`Collected ${itemsToDrop.length} total items to drop.`);
        // Spawn items
        itemsToDrop.forEach((item, index) => { /* ... (spawn logic same as before) ... */ const dropPosOffset = new THREE.Vector3((Math.random()-0.5)*1.2, 0.2+index*0.03, (Math.random()-0.5)*1.2); const finalDropPos = baseDropPosition.clone().add(dropPosOffset); const terrainY = ChunkManager.getTerrainHeightAt(finalDropPos.x, finalDropPos.z); finalDropPos.y = Math.max(terrainY + 0.15, finalDropPos.y); spawnItem(item, finalDropPos); });
        if (itemsToDrop.length > 0) logMessage("Has soltado tus pertenencias.", "warning");

        // --- 4. Sound & Music ---
        AudioManager.playSound('player_death', 0.7);
        AudioManager.stopMusic(); // Stop normal music, maybe play ghost music later?

        // --- *** REMOVED stopGameLoop() call *** ---

        // --- 5. Apply Ghost Visual Effect (Same as before) ---
        try { /* ... (apply ghost visual effect code) ... */
             const ghostColorValue = getComputedStyle(document.documentElement).getPropertyValue('--color-ghost').trim(); const ghostColorTHREE = new THREE.Color(ghostColorValue||'#a29bfe'); const playerVisual = playerModel?.getObjectByName("PlayerVisualModel")||playerModel?.getObjectByName("PlayerVisualFallbackGLB");
             if(playerVisual){ playerVisual.traverse(child => { if (child.isMesh && child.material instanceof THREE.MeshStandardMaterial) { if (!child.userData.originalMaterialProperties) { child.userData.originalMaterialProperties = { color: child.material.color.getHex(), opacity: child.material.opacity, emissive: child.material.emissive.getHex(), emissiveIntensity: child.material.emissiveIntensity, transparent: child.material.transparent, depthWrite: child.material.depthWrite }; } if (!child.material.clonedForGhost) { try { child.material = child.material.clone(); child.material.clonedForGhost = true; } catch (cloneError) { console.error("Error clonando material fantasma:", cloneError); } } child.material.color.set(ghostColorTHREE); child.material.emissive.set(ghostColorTHREE); child.material.emissiveIntensity = 0.4; child.material.opacity = 0.65; child.material.transparent = true; child.material.depthWrite = false; } }); }
        } catch (error) { console.error("Error aplicando efecto visual fantasma:", error); }


        // --- 6. Update UI & Status (Ensure health bar class is added) ---
        const healthBar = domCache['health-bar']; if (healthBar instanceof HTMLElement) healthBar.classList.add('ghost-mode');
        addStatusEffect({ id: 'ghost', name: 'Fantasma', icon: 'fa-ghost', duration: Infinity, class: 'status-ghost', description: 'Busca un sacerdote para revivir.' });
        updatePlayerUI();
        updateInventoryUI();
        updateEquipmentUI();
        updateActionButtons();
        updateActionSlotsUI();

        logMessage("HAS MUERTO. Busca un sacerdote para revivir.", 'error');
        showNotification("Has muerto. Busca un sacerdote.", "error", 5000);

        // --- 7. Ghost Loop NOT Started Separately ---
        // The main updateGame loop will now handle the ghost state.
        console.log("Player death processed. Ghost state active. Main loop continues.");
    } // --- Fin playerDeath (v8) ---  

// Keep the original stopGameLoop if it's used elsewhere (like exiting to menu)
function stopGameLoop() {
    if (gameLoopId !== null) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
        console.log("Game Loop Stopped."); // Keep original name for clarity
    } else {
         console.log("stopGameLoop: No loop active to stop.");
    }
}

     /**
      * Comprueba si el jugador fantasma está intentando interactuar
      * con un sacerdote cercano y lo revive si es el caso.
      */
     function checkGhostInteractions() {
         // Solo relevante si es fantasma y presiona interactuar
         if (!gameState.isGhost || !controls.interact) {
             // Si no interactúa o no es fantasma, asegurarse de limpiar el target si no es sacerdote
             if (gameState.targetEntity && gameState.targetEntity.userData?.type !== 'npc' && gameState.targetEntity.userData?.npcType !== 'priest') {
                 gameState.targetEntity = null;
                 updateTargetUI(); // Limpiar UI si el target fantasma no es un sacerdote
             }
             return;
         }

         let closestPriest = null;
         let minDistSq = INTERACT_DISTANCE_SQ * 1.5; // Rango interacción fantasma

         // Buscar sacerdote más cercano visible
         world.npcs.forEach(npc => {
             // Buscar por npcType específico y asegurar que esté visible
             if (npc?.userData?.npcType === 'priest' && npc.position && npc.visible) {
                  const distSq = npc.position.distanceToSquared(playerState.position);
                  if (distSq < minDistSq) {
                      // Verificar Línea de Visión (importante para evitar revivir a través de paredes)
                      const npcHeadPos = npc.position.clone().add(new THREE.Vector3(0, (npc.userData.heightOffset || 1.5) * 0.8, 0));
                      const playerGhostPos = playerState.position.clone().add(new THREE.Vector3(0, 0.5, 0)); // Posición ojos fantasma aprox.
                      if (checkLineOfSight(playerGhostPos, npcHeadPos)) {
                           closestPriest = npc;
                           minDistSq = distSq;
                      }
                  }
             }
         });

         // Actualizar targetEntity para UI (muestra al sacerdote si está cerca y visible)
         if (closestPriest !== gameState.targetEntity) {
              gameState.targetEntity = closestPriest; // Mostrar sacerdote como target
              updateTargetUI();
         }


         // Si se encontró un sacerdote Y se presionó interactuar (ya verificado al inicio)
         if (closestPriest) {
             console.log("Fantasma interactuando con sacerdote. Iniciando resurrección...");
             revivePlayer(); // <<< LLAMAR DIRECTAMENTE A REVIVE PLAYER
             controls.interact = false; // Consumir la acción de interactuar INMEDIATAMENTE
             gameState.targetEntity = null; // Limpiar target después de revivir
             updateTargetUI();
         } else {
              // Si se presionó interactuar pero no había sacerdote, limpiar target por si acaso
              if(gameState.targetEntity) {
                  gameState.targetEntity = null;
                  updateTargetUI();
              }
              // No hacer nada más, el flag controls.interact se reseteará en keyup
         }
     }
   
    /**
     * Revive al jugador del estado fantasma.
     * Restaura stats, lo posiciona EN EL LUGAR ACTUAL (cerca del sacerdote),
     * restaura apariencia. El bucle principal updateGame sigue corriendo.
     * (v7 - Integrated Loop)
     */
    function revivePlayer() {
        // 1. --- Validation ---
        if (!gameState.isGhost) {
            console.warn("revivePlayer called but player is not a ghost.");
            return;
        }

        console.log("--- Reviving Player (At Current Location) ---");
        gameState.isGhost = false; // <<< SET GHOST STATE TO FALSE
        gameState.isGameOver = false;
        gameState.isPlaying = true; // Ensure playing state is true
        gameState.isPaused = false;

        // 2. --- Restore Stats (Same as before) ---
        const healthPercent = 0.6; const manaPercent = 0.8; const staminaPercent = 1.0;
        playerState.stats.health = Math.max(1, Math.floor(playerState.stats.maxHealth * healthPercent));
        playerState.stats.mana = Math.max(0, Math.floor(playerState.stats.maxMana * manaPercent));
        playerState.stats.stamina = Math.max(1, Math.floor(playerState.stats.maxStamina * staminaPercent));
        console.log(`Stats restored: HP=${playerState.stats.health}, MP=${playerState.stats.mana}, SP=${playerState.stats.stamina}`);

        // 3. --- Set Position to CURRENT Location & Adjust Y (Same as before) ---
        const revivePosition = playerState.position.clone();
        console.log(`Reviving at current position: (${revivePosition.x.toFixed(1)}, ${revivePosition.y.toFixed(1)}, ${revivePosition.z.toFixed(1)})`);
        const terrainY = ChunkManager.getTerrainHeightAt(revivePosition.x, revivePosition.z);
        playerState.position.copy(revivePosition).setY(terrainY + PLAYER_HALF_HEIGHT);
        playerState.velocity.set(0, 0, 0);
        playerState.onGround = true;
        if (playerModel) { playerModel.position.copy(playerState.position); playerModel.rotation.y = playerState.rotationY; }
        playerState.lastWorldPosition = null; playerState.lastWorldRotationY = Math.PI;
        console.log(`Player final position set to Y=${playerState.position.y.toFixed(2)}`);

        // 4. --- Sound & Music ---
        AudioManager.playSound('respawn', 0.7);
        AudioManager.updateMusic(); // Resume appropriate music

        // 5. --- Restore Visual Appearance (Same as before) ---
        try { /* ... (restore visual appearance code) ... */
            const playerVisual = playerModel?.getObjectByName("PlayerVisualModel")||playerModel?.getObjectByName("PlayerVisualFallbackGLB");
            if(playerVisual){ playerVisual.traverse(child => { if (child.isMesh && child.material) { const originalProps = child.userData?.originalMaterialProperties; const mat = child.material; if(mat.clonedForGhost){ if (originalProps) { mat.color.setHex(originalProps.color); mat.emissive.setHex(originalProps.emissive); mat.emissiveIntensity = originalProps.emissiveIntensity??0; mat.opacity = originalProps.opacity??1.0; mat.transparent = originalProps.transparent||false; mat.depthWrite = originalProps.originalDepthWrite??true; delete child.userData.originalMaterialProperties; } else { mat.opacity = 1.0; mat.transparent = false; mat.depthWrite = true; } delete mat.clonedForGhost; } } }); console.log("Player visual appearance restored."); } else { console.warn("Could not find player visual model to restore appearance."); }
        } catch(restoreError) { console.error("Error restaurando apariencia al revivir:", restoreError); }
        const healthBar = domCache['health-bar']; if (healthBar instanceof HTMLElement) healthBar.classList.remove('ghost-mode');

        // 6. --- Clean Up Ghost State ---
        removeStatusEffect('ghost');
        logMessage("¡Has sido resucitado!", 'success');
        showNotification("¡Resucitado!", "success");

        // 7. --- Update UI (Loop is already running) ---
        updatePlayerUI();
        updateStatusEffectsUI();
        updateActionButtons(); // Re-enable actions
        // Ensure camera target is reset correctly
        if (camera && orbitControls) { orbitControls.target.copy(playerState.position).add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.8, 0)); orbitControls.update(); }

        // --- *** REMOVED Loop Start/Stop Calls *** ---
        console.log("Player Revived. Main game loop continues.");
    } // --- Fin revivePlayer (v7) ---

  
function healPlayerForGold() {
        const cost = 10; // Costo de la curación
        const npc = gameState.currentDialogNPC; // NPC actual (sacerdote)
        const npcData = npc ? npcDefinitions[npc.userData.npcType] : null;

        if (playerState.gold < cost) {
            // Si no hay oro, intentar mostrar diálogo específico
            if (npcData?.dialogues?.noGoldHeal) {
                 startDialogStep(npcData.dialogues.noGoldHeal);
            } else { // Fallback si no hay diálogo específico
                 logMessage("No tienes suficiente oro para curarte.", "warning");
                 closeDialog();
            }
            AudioManager.playSound('ui_error', 0.4);
            return;
        }
        if (playerState.stats.health >= playerState.stats.maxHealth) {
             // Si ya está sano, intentar mostrar diálogo específico
             if (npcData?.dialogues?.fullHealth) {
                  startDialogStep(npcData.dialogues.fullHealth);
             } else { // Fallback
                  logMessage("Ya tienes la salud al máximo.", "info");
                  closeDialog();
             }
             return;
        }

        // Procesar curación
        playerState.gold -= cost;
        const healthRestored = playerState.stats.maxHealth - playerState.stats.health; // Calcular cuánto se curó
        playerState.stats.health = playerState.stats.maxHealth; // Curación completa
        updatePlayerUI(); // Actualizar UI (oro y salud)
        logMessage("El sacerdote ha restaurado tu salud.", "system");
        showFloatingText("heal-text", `+${Math.floor(healthRestored)}`, playerState.position.clone().add(new THREE.Vector3(0,1,0)));
        AudioManager.playSound('spell_cast', 0.6); // Reusar sonido de hechizo? O sonido específico 'heal'?
        closeDialog(); // Cerrar diálogo después de curar
    }

    // --- Funciones de Proyectiles ---
    function createProjectile(caster, targetPos, type) {
        const spellDef = spellDefinitions[type]; if (!spellDef) return;
        const casterPos = caster?.position || new THREE.Vector3(); // Posición del lanzador
        const casterHeightOffset = (caster === playerModel ? PLAYER_HALF_HEIGHT : (caster?.userData?.heightOffset || 0.5)) + 0.3; // Punto de origen ligeramente elevado
        const startPos = casterPos.clone().add(new THREE.Vector3(0, casterHeightOffset, 0));

        // Asegurar que targetPos sea un Vector3 válido
        if (!(targetPos instanceof THREE.Vector3) || isNaN(targetPos.x) || isNaN(targetPos.y) || isNaN(targetPos.z)) {
            console.error("createProjectile: targetPos inválido.", targetPos);
            return; // No crear si el objetivo no es válido
        }

        const direction = new THREE.Vector3().subVectors(targetPos, startPos);
        if (direction.lengthSq() < 0.01) { // Evitar dirección cero
            console.warn("createProjectile: Start y Target muy cerca, usando dirección forward del caster.");
            if (caster?.getWorldDirection) caster.getWorldDirection(direction);
            else direction.set(0,0,-1); // Fallback genérico
        }
        direction.normalize();

        let geometry, material; let particleColor = 0xffffff; let lightIntensity = 0;
        switch (type) {
            case 'fireball':
                geometry = new THREE.SphereGeometry(0.25, 10, 10);
                material = new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 1.2 });
                particleColor = 0xff8800; lightIntensity = 0.8; break;
            case 'ice_shard':
                geometry = new THREE.ConeGeometry(0.12, 0.5, 8); geometry.rotateX(Math.PI/2); // Apuntar cono hacia adelante
                material = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.85, emissive: 0x55aaff, emissiveIntensity: 0.6 });
                particleColor = 0x88ccff; lightIntensity = 0.4; break;
            case 'magic_arrow':
                geometry = new THREE.SphereGeometry(0.18, 8, 8); // Flecha simple
                material = new THREE.MeshStandardMaterial({ color: 0xaa88ff, emissive: 0x8866dd, emissiveIntensity: 0.7 });
                particleColor = 0xaa88ff; lightIntensity = 0.5; break;
            default: // Fallback
                geometry = new THREE.SphereGeometry(0.15, 6, 6);
                material = new THREE.MeshStandardMaterial({ color: 0xdddddd }); particleColor = 0xdddddd;
        }

        const projectileMesh = new THREE.Mesh(geometry, material);
        projectileMesh.position.copy(startPos);
        projectileMesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction); // Orientar Z+ hacia la dirección

        // Añadir luz puntual al proyectil si tiene intensidad definida
        if (lightIntensity > 0) {
             const projLight = new THREE.PointLight(particleColor, lightIntensity, 3, 1.5); // Color, Int, Dist, Decay
             projectileMesh.add(projLight);
        }

        projectileMesh.userData = {
            type: 'projectile', spellType: type, name: spellDef.name, direction: direction, speed: PROJECTILE_SPEED * (spellDef.speedMultiplier || 1.0),
            damage: { min: spellDef.damageMin || 0, max: spellDef.damageMax || 0, type: spellDef.element || 'magic' },
            caster: caster, lifetime: spellDef.lifetime || 5, // Segundos
            particleColor: particleColor, spellDef: { ...spellDef } // Guardar copia de def para efectos
        };
        scene.add(projectileMesh); world.activeProjectiles.push(projectileMesh);
    }
    
    

    /**
     * Actualiza la posición de los proyectiles activos,
     * comprueba colisiones y maneja impactos.
     * (v2 - Logs Detallados)
     */
    function updateProjectiles(deltaTime) {
        // Iterar hacia atrás para poder eliminar elementos de forma segura
        for (let i = world.activeProjectiles.length - 1; i >= 0; i--) {
            const proj = world.activeProjectiles[i];
            const data = proj?.userData;

            // --- Validación del Proyectil ---
            if (!proj || !data || !(data.direction instanceof THREE.Vector3) || typeof data.speed !== 'number' || typeof data.lifetime !== 'number') {
                console.warn(`updateProjectiles: Eliminando proyectil inválido en índice ${i}.`, proj);
                if (proj?.parent) scene.remove(proj); // Intentar remover de escena
                world.activeProjectiles.splice(i, 1); // Eliminar del array
                continue; // Saltar al siguiente
            }

            // --- Mover Proyectil ---
            const displacement = data.direction.clone().multiplyScalar(data.speed * deltaTime);
            proj.position.add(displacement);
            data.lifetime -= deltaTime;

            // --- Comprobar Fin de Vida o Colisión con Terreno ---
            const projectileExpired = data.lifetime <= 0;
            const terrainHeight = ChunkManager.getTerrainHeightAt(proj.position.x, proj.position.z);
            const hitGround = proj.position.y < terrainHeight + 0.1;

            if (projectileExpired || hitGround) {
                // console.log(`Projectile ${data.projectileType} ${proj.uuid} removing. Expired: ${projectileExpired}, HitGround: ${hitGround}`); // DEBUG
                handleProjectileImpact(proj, null); // Impacto sin objetivo (terreno/expirado)
                // handleProjectileImpact se encarga de removerlo de la escena y del array
                continue; // Saltar al siguiente
            }

            // --- Comprobar Colisión con Objetivos ---
            let impactedTarget = null;
            const projSize = 0.4; // Radio de colisión aproximado
            // Crear BBox para el proyectil en su posición actual
            const projBox = new THREE.Box3().setFromCenterAndSize(proj.position, new THREE.Vector3(projSize, projSize, projSize));

            // Determinar lista de posibles objetivos
            let potentialTargets = [];
            if (data.caster === playerModel) { // Proyectil del jugador -> golpea enemigos
                 potentialTargets = world.enemies.filter(e => e?.userData && !e.userData.isDead && e.visible && e.position);
            } else { // Proyectil de enemigo -> golpea jugador
                 if (!gameState.isGhost && playerModel && playerCollider) potentialTargets = [playerModel];
            }

            // Comprobar intersección con los colliders de los objetivos
            for (const target of potentialTargets) {
                 // Obtener o crear collider del objetivo
                 let targetCollider;
                 if (target === playerModel) {
                     targetCollider = playerCollider.clone().translate(playerState.position.clone().sub(playerModel.position)); // Asegurar que el collider lógico esté centrado en la posición REAL
                 } else if (target.userData?.boundingBox instanceof THREE.Box3) {
                     // Actualizar bounding box si es necesario (si el enemigo se mueve)
                     // NOTA: Actualizar BBox en cada frame puede ser costoso.
                     // Una alternativa es usar esferas de colisión (más simple)
                     // Por ahora, asumimos que userData.boundingBox está razonablemente actualizado
                     targetCollider = target.userData.boundingBox;
                 } else {
                     // Fallback: Crear BBox al vuelo (menos preciso si el origen del modelo no es el centro)
                     const size = target.userData?.hitRadius ? target.userData.hitRadius*2 : 1.0;
                     targetCollider = new THREE.Box3().setFromCenterAndSize(target.position, new THREE.Vector3(size,size,size));
                 }

                 // Comprobar intersección
                 if (projBox.intersectsBox(targetCollider)) {
                     // console.log(`Projectile ${data.projectileType} hit target: ${target.userData?.name || 'Player'}`); // DEBUG
                     impactedTarget = target;
                     break; // Detener al primer impacto
                 }
            }

            // --- Manejar Impacto si Ocurrió ---
            if (impactedTarget) {
                handleProjectileImpact(proj, impactedTarget);
                // handleProjectileImpact se encarga de removerlo de la escena y del array
                continue; // Saltar al siguiente proyectil
            }

            // --- Efecto de Estela (Opcional) ---
            if (frameCount % (data.projectileType === 'arrow' ? 5 : 4) === 0) {
                 // Añadir una pequeña aleatoriedad a la posición de la estela
                 const trailPos = proj.position.clone().add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.2));
                 createParticleTrail(trailPos, data.particleColor);
            }
        }
    }


    /**
     * Maneja el impacto de un proyectil con un objetivo o el entorno.
     * Aplica daño/efectos, crea efectos visuales y elimina el proyectil.
     * @param {THREE.Object3D} projectile - El objeto 3D del proyectil.
     * @param {THREE.Object3D | null} target - El objetivo impactado (o null si es terreno/expirado).
     */
    function handleProjectileImpact(projectile, target) {
        const data = projectile?.userData;

        // Salir si el proyectil ya no es válido (podría ser llamado dos veces?)
        const currentIndex = world.activeProjectiles.indexOf(projectile);
        if (!projectile || !data || currentIndex === -1) {
             // console.warn("handleProjectileImpact: Proyectil inválido o ya eliminado.");
             // Asegurarse de removerlo de la escena si aún existe
             if(projectile?.parent) scene.remove(projectile);
             return;
        }

        // --- Efectos Visuales y Sonido de Impacto ---
        createImpactEffect(projectile.position, data.particleColor || 0xffffff);
        const impactSound = data.projectileType === 'arrow' ? 'arrow_hit' : 'spell_impact';
        AudioManager.playSound(impactSound, 0.55); // Sonido ajustado

        // --- Aplicar Daño y Efectos si hay Objetivo Válido ---
        if (target && target.userData && !(target.userData.isDead || target.userData.isProcessingDeath) && target !== data.caster) { // Asegurar no golpearse a sí mismo
            const damageData = data.damage || {};
            const dmgMin = damageData.min || 0;
            const dmgMax = damageData.max || 1;
            const damageType = damageData.type || (data.projectileType === 'arrow' ? 'physical' : 'magic');
            const finalDamageMin = Math.min(dmgMin, dmgMax);
            const finalDamageMax = Math.max(dmgMin, dmgMax);
            let damageAmount = Math.floor(Math.random() * (finalDamageMax - finalDamageMin + 1)) + finalDamageMin;

            // Calcular crítico (solo para proyectiles no-flecha, o podrías añadirlo para flechas también)
            const isCasterPlayer = (data.caster === playerModel);
            const baseCritChance = isCasterPlayer ? (playerState.stats?.critChance || 0) : 5; // Chance base
            const finalCritChance = baseCritChance + (data.critChanceBonus || 0); // Añadir bonus de proyectil
            const isCritical = (data.projectileType !== 'arrow') && (Math.random() * 100 < finalCritChance); // Crítico para hechizos?

            // Aplicar daño
            if (damageAmount > 0) {
                 // Podrías pasar hitChanceBonus a applyDamage si esa función lo usa
                 applyDamage(target, damageAmount, damageType, isCritical);
            }

            // Aplicar Efectos Secundarios (Slow, Burn, etc.)
            if (data.spellDef) { // Si viene de un hechizo
                 const spellDef = data.spellDef;
                 const targetData = (target === playerModel) ? playerState : target.userData;
                 if (targetData) { // Asegurar que targetData exista
                     // Ejemplo Hielo
                     if (spellDef.id === 'ice_shard' && spellDef.slowChance && Math.random() < spellDef.slowChance) {
                          addStatusEffectToTarget(targetData, { id: 'slow', name: 'Ralentizado', icon: 'fa-person-falling', duration: spellDef.slowDuration || 3, statsModifiers: { moveSpeedMultiplier: 0.5 }, class: 'status-slow', description: 'Mov. reducido.' });
                     }
                     // Ejemplo Fuego
                      if (spellDef.element === 'fire' && spellDef.burnChance && Math.random() < spellDef.burnChance) {
                          addStatusEffectToTarget(targetData, {...BURN_EFFECT_DATA, duration: spellDef.burnDuration || 5, damagePerTick: { amount: spellDef.burnDmg || 4, type: 'fire'}});
                      }
                     // Añadir más efectos aquí
                 }
            }
        } else {
            // Impacto sin objetivo válido (terreno, etc.)
            // console.log(`Projectile ${data.projectileType} impacted terrain/expired.`); // DEBUG
        }

        // --- Limpiar Proyectil ---
        // Remover de la escena
        if (projectile.parent) {
             scene.remove(projectile);
        }
        // Remover del array de proyectiles activos (usando el índice precalculado)
        world.activeProjectiles.splice(currentIndex, 1);

        // Opcional: Limpiar geometría/material para liberar memoria (puede ser overkill)
        // if (projectile.geometry) projectile.geometry.dispose();
        // if (projectile.material) { /* ... dispose logic ... */ }
    }

    function createImpactEffect(position, color = 0xffffff) {
        const particleCount = 12; // Más partículas
        for (let i = 0; i < particleCount; i++) {
            const speed = 5 + Math.random() * 5;
            const life = 0.3 + Math.random() * 0.4;
            world.particles.push({
                position: position.clone(),
                velocity: new THREE.Vector3((Math.random()-0.5)*speed, (Math.random()-0.5)*speed, (Math.random()-0.5)*speed),
                color: `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.9)`,
                size: 2.0 + Math.random() * 2.0,
                lifetime: life,
                type: 'impact'
            });
        }
        // AudioManager.playSound('spell_impact', 0.6); // Sonido ya se reproduce en handleProjectileImpact
    }

     function createParticleTrail(position, color = 0xffffff) {
         world.particles.push({
             position: position.clone().add(new THREE.Vector3((Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.3)),
             velocity: new THREE.Vector3(0,0,0),
             color: `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.7)`,
             size: 1.5 + Math.random() * 1.8,
             lifetime: 0.4 + Math.random() * 0.3,
             type: 'trail'
         });
     }

    // --- Funciones de Partículas ---
    function updateParticles(deltaTime) {
        for (let i = world.particles.length - 1; i >= 0; i--) {
            const p = world.particles[i]; p.lifetime -= deltaTime;
            if (p.lifetime <= 0) { world.particles.splice(i, 1); continue; }
            if (p.velocity) {
                p.position.addScaledVector(p.velocity, deltaTime);
                if (p.type === 'impact') {
                     p.velocity.y -= 20 * deltaTime; // Gravedad
                     p.velocity.multiplyScalar(1 - 1.5 * deltaTime); // Fricción
                } else if (p.type === 'text') {
                     p.velocity.y -= 8 * deltaTime; // El texto flota hacia abajo más lento
                     p.velocity.multiplyScalar(1 - 0.5 * deltaTime);
                }
            }
        }
    }

    function renderParticles(ctx) {
        if (!ctx || !camera || ctx.isDummyContext) return;
        const count = Math.min(world.particles.length, PARTICLE_RENDER_BATCH_SIZE);
        ctx.save(); // Guardar estado global del canvas
        for (let i = 0; i < count; i++) {
            const p = world.particles[i]; const screenPos = projectToScreen(p.position);
            if (!screenPos) continue;

            // Calcular alfa basado en lifetime restante
            const alpha = Math.min(1, Math.max(0, p.lifetime / (p.type === 'text' ? DAMAGE_TEXT_DURATION/1000 : 0.6))); // Duración base para fade out
            ctx.globalAlpha = alpha * (p.type === 'text' ? 1.0 : 0.8); // Textos más opacos
            ctx.fillStyle = p.color;

            if (p.type === 'impact' || p.type === 'trail') {
                ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, p.size * alpha, 0, Math.PI * 2); ctx.fill();
            } else if (p.type === 'text') {
                 ctx.font = `${p.fontWeight || 'bold'} ${p.size}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-primary')}, serif`;
                 ctx.textAlign = 'center';
                 ctx.shadowColor = 'rgba(0,0,0,0.8)'; ctx.shadowBlur = 4; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
                 ctx.fillStyle = p.color; // Usar el color guardado (puede ser variable CSS resuelta o #hex)
                 ctx.fillText(p.text, screenPos.x, screenPos.y);
                 ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; // Resetear sombra
            }
        }
        ctx.restore(); // Restaurar estado global (incluyendo globalAlpha)
    }

     function renderWeatherParticles(ctx) {
                 if (!weatherEffectsEnabled || !ctx || !camera || ctx.isDummyContext || !world.weatherSystem.active) return;

         if (!ctx || !camera || ctx.isDummyContext || !world.weatherSystem.active) return;
         const count = Math.min(world.weatherSystem.particles.length, MAX_WEATHER_PARTICLES);
         ctx.save(); // Guardar estado
         ctx.lineWidth = 1.5; // Grosor para lluvia
         for (let i = 0; i < count; i++) {
             const p = world.weatherSystem.particles[i];
             const screenPos = projectToScreen(p.position);
             if (!screenPos) continue;
             ctx.globalAlpha = p.alpha * 0.8; // Ligeramente más transparentes
             ctx.fillStyle = p.color;
             ctx.strokeStyle = p.color;

             if (world.weatherSystem.type === 'rain') {
                 const length = p.size * 4; // Hacer líneas más largas
                 ctx.beginPath(); ctx.moveTo(screenPos.x, screenPos.y); ctx.lineTo(screenPos.x, screenPos.y + length); ctx.stroke();
             } else if (world.weatherSystem.type === 'snow') {
                 ctx.beginPath(); ctx.arc(screenPos.x, screenPos.y, p.size, 0, Math.PI * 2); ctx.fill();
             }
         }
         ctx.restore(); // Restaurar estado
     }

    //===========================================
    // FUNCTION: render (COMPLETE - vStatsCall)
    //===========================================
    function render() {
        // --- 1. Start FPS Counter (if enabled) ---
        if (statsMonitor && showFPS) { // Check BOTH conditions
            statsMonitor.begin();
        }
        // --- 2. Renderizado Principal del Juego (WebGL) ---
        if (!renderer || !scene || !camera) {
            if (!render.warnedMainMissing) {
                console.warn("Render skipped: Falta el renderer principal, la escena o la cámara.");
                render.warnedMainMissing = true;
            }
            // End FPS counter even if render fails, to avoid locking up
            if (statsMonitor && showFPS) statsMonitor.end();
            return;
        }
        render.warnedMainMissing = false; // Reset warning

        try {
            renderer.render(scene, camera);
        } catch (renderError) {
            console.error("Error crítico durante renderer.render() de la escena principal:", renderError);
            stopGameLoop();
            logMessage("Error gráfico crítico. El juego se ha detenido.", "error");
            // End FPS counter even if render fails
            if (statsMonitor && showFPS) statsMonitor.end();
            return;
        }

        // --- 3. Renderizado del Preview de Personaje ---
        if (previewRenderer && previewScene && previewCamera) {
            try {
                previewRenderer.render(previewScene, previewCamera);
            } catch (previewRenderError) {
                console.error("Error renderizando la vista previa del personaje:", previewRenderError);
            }
        }

        // --- 4. Renderizado de Partículas 2D ---
        const particleCtx = domCache.particleCtx;
        if (particleCtx && typeof particleCtx.clearRect === 'function' && !particleCtx.isDummyContext) {
            try {
                particleCtx.clearRect(0, 0, particleCtx.canvas.width, particleCtx.canvas.height);
                // Render weather only if enabled
                if (weatherEffectsEnabled && world.weatherSystem?.active && typeof renderWeatherParticles === 'function') {
                    renderWeatherParticles(particleCtx);
                }
                if (world.particles?.length > 0 && typeof renderParticles === 'function') {
                    renderParticles(particleCtx);
                }
                if (render.loggedInvalidOrDummyWarning) { render.loggedInvalidOrDummyWarning = false; }
            } catch (renderError2D) { console.error("Error durante el renderizado 2D (partículas/clima):", renderError2D); }
        } else {
            if (!render.loggedInvalidOrDummyWarning) { console.warn("Contexto particleCtx inválido o dummy. Omitiendo renderizado 2D."); console.log("Valor actual de domCache.particleCtx:", particleCtx); render.loggedInvalidOrDummyWarning = true; }
        }

        // --- 5. End FPS Counter (if enabled) ---
        if (statsMonitor && showFPS) { // Check BOTH conditions
            statsMonitor.end();
        }
    }
    // Initialize warning flags
    render.warnedMainMissing = false;
    render.loggedInvalidOrDummyWarning = false;


// Inicializar flags de advertencia fuera de la función para que persistan entre llamadas
render.warnedMainMissing = false;
render.loggedInvalidOrDummyWarning = false;
    // --- Funciones UI Móvil ---
    function updateMobileTopBar() {
        // 1. Actualizar Minimapa Móvil
        drawMobileMinimap();
        // 2. Actualizar Barras de Estado Móviles
        updateMobileStatusBars();
    }

    function drawMobileMinimap() {
        const ctx = domCache.mobileMinimapCtx;
        const canvas = domCache['mobile-minimap-canvas'];
        if (!ctx || !(canvas instanceof HTMLCanvasElement) || ctx.isDummyContext || canvas.width <= 0) return;
        if (!playerState?.position) return;

        const canvasSize = canvas.width; const worldRadiusToShow = MINIMAP_WORLD_RADIUS * 0.8;
        const scale = canvasSize / (worldRadiusToShow * 2);
        const centerX = canvasSize / 2; const centerY = canvasSize / 2;
        const playerWorldX = playerState.position.x; const playerWorldZ = playerState.position.z;
        const playerAngle = playerState.rotationY;

        // Fondo (Muestreo directo simplificado)
        ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvasSize, canvasSize);
        const sampleStep = 5; // Muestreo más grueso
        for (let py = 0; py < canvasSize; py += sampleStep) { for (let px = 0; px < canvasSize; px += sampleStep) { const wx = playerWorldX + (px - centerX) / scale; const wz = playerWorldZ + (py - centerY) / scale; const h = ChunkManager.getTerrainHeightAt(wx, wz); let tc = new THREE.Color(0x446633); const biome = getBiome(wx, wz); if(h < WATER_LEVEL) tc.setHex(worldData.biomeColors?.water || 0x336699); else { tc.setHex(worldData.biomeColors?.[biome] || worldData.biomeColors?.grassland || 0x55903a); const snowL = BIOME_PARAMS.heightMountain * 1.05; if (h > snowL) tc.lerp(new THREE.Color(worldData.biomeColors?.snow || 0xf0f8ff), 0.8); } const roadInf = getRoadInfluence(wx, wz); if (roadInf > 0) tc.lerp(new THREE.Color(worldData.biomeColors?.road || 0x907458), roadInf * 0.8); ctx.fillStyle = tc.getStyle(); ctx.fillRect(px, py, sampleStep, sampleStep); } }

        // Dibujar Jugador (Centro)
        const playerIconSize = 2.5; ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(playerAngle);
        ctx.fillStyle = gameState.isGhost ? '#a29bfe' : '#ffffff'; ctx.strokeStyle = '#000'; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(0,-playerIconSize*0.9); ctx.lineTo(playerIconSize*0.7,playerIconSize*0.7); ctx.lineTo(-playerIconSize*0.7,playerIconSize*0.7); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.restore();

        // Dibujar Borde
        ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.arc(centerX, centerY, canvasSize/2 - 0.5, 0, Math.PI * 2); ctx.stroke();
        try { ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-secondary').trim() || '#b89b40'; } catch(e){ ctx.strokeStyle = '#b89b40'; }
        ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(centerX, centerY, canvasSize/2 - 1, 0, Math.PI * 2); ctx.stroke();
    }

    function updateMobileStatusBars() {
        if (!playerState?.stats) return;
        const updateMobileBar = (type, current, max) => { const bar = domCache[`mobile-${type}-bar`]; if (bar instanceof HTMLElement) { const maxV = Math.max(1, max); const currV = Math.max(0, current); const p = Math.min(100, (currV / maxV) * 100); const w = `${p.toFixed(1)}%`; if (bar.style.width !== w) bar.style.width = w; if(type==='health'){ const cont = bar.parentElement; if(cont) cont.classList.toggle('low-health', p<25&&max>0); } } };
        updateMobileBar('health', playerState.stats.health, playerState.stats.maxHealth);
        updateMobileBar('mana', playerState.stats.mana, playerState.stats.maxMana);
        updateMobileBar('stamina', playerState.stats.stamina, playerState.stats.maxStamina);
    }

    function toggleMobileSidebar() {
        const sidebar = domCache['sidebar'];
        if (sidebar instanceof HTMLElement) {
            const isVisible = sidebar.classList.contains('mobile-visible');
            sidebar.classList.toggle('mobile-visible');
            if (!isVisible) { AudioManager?.playSound('ui_open', 0.35); } // Sonido al abrir
            else { AudioManager?.playSound('ui_close', 0.35); hideTooltip(); } // Sonido y ocultar tooltip al cerrar
        }
    }


    function handleMobileAttackStart(event) { // En 'touchstart'
        event.preventDefault();
        if (!gameState.isPlaying || gameState.isPaused || gameState.isGhost || playerState.isAttacking || playerState.isChargingAttack || playerState.isBlocking || gameState.isAimingWithBow || controls.isAttackKeyDown || playerState.isDodging) {
            return; // Ignorar si está ocupado
        }
        controls.isAttackKeyDown = true; // Marcar botón presionado

        const weapon = playerState.equipment.weapon;
        const weaponDef = weapon ? itemDefinitions[weapon.id] : null;
        const isBowEquipped = weaponDef?.weaponType === 'bow';

        if (isBowEquipped) {
            enterAimingMode(); // Entrar en modo apuntar con arco
        } else { // Arma Melee o sin arma
            playerState.isChargingAttack = true; // Empezar a cargar ataque melee
            playerState.chargeAttackStartTime = Date.now();
            // Podría iniciarse una animación de carga aquí
            // playPlayerAnimation('charge_start', 0.1, false);
        }
    }

    function handleMobileAttackEnd(event) { // En 'touchend' o 'touchcancel'
        event.preventDefault();
        if (controls.isAttackKeyDown) { // Solo si el botón estaba realmente presionado
            controls.isAttackKeyDown = false; // Marcar que se soltó

            const weaponDef = itemDefinitions[playerState.equipment.weapon?.id];
            const isBowEquipped = weaponDef?.weaponType === 'bow';

            if (isBowEquipped) {
                // Si suelta el botón de ataque mientras apunta con arco, NO dispara.
                // El disparo se maneja al tocar el OBJETIVO.
                // Podríamos cancelar el apuntado si se mantiene mucho y se suelta? Opcional.
                // if (gameState.isAimingWithBow) cancelAiming();
            } else if (playerState.isChargingAttack) {
                // Si estaba cargando un ataque melee, ejecutarlo al soltar
                const chargeDuration = Date.now() - playerState.chargeAttackStartTime;
                executeMeleeAttack(chargeDuration); // Ejecutar con la duración de carga
                // Resetear estado de carga
                playerState.isChargingAttack = false;
                playerState.chargeAttackStartTime = 0;
            }
            // Si no estaba cargando (fue un toque rápido), la lógica de KeyDown/MouseDown ya manejó el ataque rápido si aplica.
        }
    }

    function handleMobileInteract(event) {
        event.preventDefault();
        if (!gameState.isPlaying || gameState.isPaused || gameState.isGhost) return;
        controls.interact = true; // Marcar flag
        checkInteractions(); // Buscar objetivo
        // La lógica en updatePlayer() intentará llamar a interact() si hay target
        // Resetear el flag después de un frame para simular pulsación
        requestAnimationFrame(() => { controls.interact = false; });
    }

    function handleMobileJump(event) {
        event.preventDefault();
        if (!gameState.isPlaying || gameState.isPaused || gameState.isGhost || playerState.isJumping || !playerState.onGround) return; // Solo saltar si está en suelo y no saltando ya
        controls.jump = true; // Marcar para que updatePlayerMovement lo procese
        // El flag controls.jump se resetea dentro de updatePlayerMovement al iniciar el salto
    }

    function handleMobileSprintToggle(event) {
        event.preventDefault();
        if (!gameState.isPlaying || gameState.isPaused || gameState.isGhost) return;
        mobileSprintToggleActive = !mobileSprintToggleActive; // Alternar estado
        const sprintButton = domCache['mobile-sprint-toggle-btn'];
        if (sprintButton instanceof HTMLElement) {
            sprintButton.classList.toggle('sprint-active', mobileSprintToggleActive);
        }
        logMessage(`Correr rápido ${mobileSprintToggleActive ? 'Activado' : 'Desactivado'}`, 'system');
        AudioManager.playSound('ui_confirm', 0.3);
    }

    function handleMobileCloseSidebar(event) {
        event.preventDefault();
        const sidebar = domCache['sidebar'];
        if (sidebar instanceof HTMLElement && sidebar.classList.contains('mobile-visible')) {
            toggleMobileSidebar(); // Usar toggle para cerrar
        }
    }


    // --- Funciones de Efectos de Estado ---
    function updateStatusEffects(deltaTime) {
        let uiNeedsUpdate = false; let statsNeedRecalc = false;
        for (let i = playerState.statusEffects.length - 1; i >= 0; i--) {
            const effect = playerState.statusEffects[i];
            if (effect.id === 'ghost' && !gameState.isGhost) { playerState.statusEffects.splice(i, 1); uiNeedsUpdate = true; continue; }
            if (gameState.isGhost && effect.id !== 'ghost') continue;
            if (effect.duration !== Infinity) {
                effect.duration -= deltaTime;
                if (effect.duration <= 0) {
                    if (effect.onEnd) effect.onEnd(playerState);
                    playerState.statusEffects.splice(i, 1); uiNeedsUpdate = true; statsNeedRecalc = true;
                    logMessage(`Efecto ${effect.name} terminado.`, 'system'); continue;
                }
            }
            if (effect.tickTime) {
                effect.timeSinceLastTick = (effect.timeSinceLastTick || 0) + deltaTime;
                if (effect.timeSinceLastTick >= effect.tickTime) {
                    if (effect.onTick) {
                         try { effect.onTick(playerState, effect); } // Usar playerState directamente
                         catch(e){ console.error(`Error en onTick (${effect.id}):`, e); }
                    }
                    effect.timeSinceLastTick = 0; // Resetear tiempo para el próximo tick
                }
            }
        }
         // Actualizar UI/Stats solo si es necesario
        if (uiNeedsUpdate) updateStatusEffectsUI();
        if (statsNeedRecalc) { updatePlayerStats(); updatePlayerUI(); updateCharacterSheet();}
    }

    function addStatusEffect(effectData) {
        const existingEffect = playerState.statusEffects.find(e => e.id === effectData.id);
        if (existingEffect) {
            existingEffect.duration = Math.max(existingEffect.duration, effectData.duration); // Refrescar duración
            existingEffect.timeSinceLastTick = 0; // Resetear tick
            if (existingEffect.onApply) existingEffect.onApply(playerState); // Reaplicar
        } else {
            const newEffect = { ...effectData, timeSinceLastTick: 0, target: 'player' }; // Marcar target
            playerState.statusEffects.push(newEffect);
            if (newEffect.onApply) newEffect.onApply(playerState);
        }
        updateStatusEffectsUI(); updatePlayerStats(); updatePlayerUI(); updateCharacterSheet();
    }

function removeStatusEffect(effectId) {
        const index = playerState.statusEffects.findIndex(e => e.id === effectId);
        if (index > -1) {
            const effect = playerState.statusEffects[index];
            // Ejecutar lógica de limpieza si existe
            if (effect.onEnd) {
                 try { effect.onEnd(playerState); }
                 catch(e) { console.error(`Error en onEnd para efecto ${effectId}:`, e); }
            }
            // Eliminar del array
            playerState.statusEffects.splice(index, 1);
            // Actualizar UI y Stats porque los modificadores se pierden
            updateStatusEffectsUI();
            updatePlayerStats();
            updatePlayerUI();
            updateCharacterSheet(); // Actualizar hoja si está abierta
            console.log(`Efecto ${effectId} eliminado.`); // DEBUG
            return true; // Indicar que se eliminó
        }
        return false; // Indicar que no se encontró
    }

    function addStatusEffectToTarget(targetData, effectData) {
        if (!targetData) return; // Salir si no hay datos de objetivo

        // Si el objetivo es el jugador, usar la función específica
        if (targetData === playerState) {
            addStatusEffect(effectData);
            return;
        }

        // Lógica para añadir efectos a NPCs/Enemigos
        if (!targetData.statusEffects) targetData.statusEffects = []; // Inicializar array si no existe

        const existingEffect = targetData.statusEffects.find(e => e.id === effectData.id);
        let addedOrRefreshed = false;

        if (existingEffect) {
            // Refrescar duración si se puede reaplicar o si la nueva es mayor
            const canRefresh = effectData.canRefresh !== false; // Asumir que se puede refrescar por defecto
            if (canRefresh) {
                existingEffect.duration = Math.max(existingEffect.duration, effectData.duration);
                existingEffect.timeSinceLastTick = 0; // Resetear tick al refrescar
                 // Re-ejecutar onApply si existe? Opcional.
                 if (existingEffect.onApply) {
                     try { existingEffect.onApply(targetData); } catch(e) { console.error(`Error en onApply (refresh) para ${effectData.id} en ${targetData.name}:`, e);}
                 }
                addedOrRefreshed = true;
            }
        } else {
            // Añadir nuevo efecto, guardando referencia a los datos del objetivo para onTick/onEnd
            const newEffect = {
                 ...effectData,
                 timeSinceLastTick: 0,
                 targetDataRef: targetData // Referencia a userData del enemigo/NPC
            };
            targetData.statusEffects.push(newEffect);
            if (newEffect.onApply) {
                 try { newEffect.onApply(targetData); } catch(e) { console.error(`Error en onApply (new) para ${effectData.id} en ${targetData.name}:`, e);}
            }
            addedOrRefreshed = true;
        }

        // Actualizar UI del objetivo si es el target actual del jugador
        if (addedOrRefreshed && targetData === gameState.targetEntity?.userData) {
             updateTargetUI(); // Actualizar para mostrar icono de efecto si la UI lo soporta
        }
        // console.log(`Aplicado/Refrescado efecto ${effectData.id} a ${targetData.name || 'NPC/Enemigo'}`); // DEBUG
    }

    function updateStatusEffectsUI() {
        const container = domCache['status-effects-bar'];
        if (!(container instanceof HTMLElement)) return;
        container.innerHTML = ''; // Limpiar iconos anteriores
        playerState.statusEffects.forEach(effect => {
            const icon = document.createElement('i');
            icon.className = `fas ${effect.icon || 'fa-question-circle'} ${effect.class || ''}`;
            icon.title = effect.name; // Tooltip básico
            icon.dataset.effectId = effect.id; // Guardar ID para referencia

            // Limpiar listeners anteriores si se reutilizan elementos (aunque aquí limpiamos innerHTML)
            // icon.removeEventListener('mouseenter', ...); icon.removeEventListener('mouseleave', ...);

            icon.addEventListener('mouseenter', (e) => showStatusTooltip(effect, e));
            icon.addEventListener('mouseleave', hideTooltip);
            container.appendChild(icon);
        });
    }

    function showStatusTooltip(effect, event) {
        const tooltip = domCache['status-tooltip']; if (!(tooltip instanceof HTMLElement) || !effect ) return;
        const colorVar = effect.class ? `var(--${effect.class})` : 'var(--color-text)'; // Usar color de clase si existe
        let content = `<div class="tooltip-section">
                           <span class="name-tooltip status-name-tooltip" style="color: ${colorVar};">${effect.name}</span>`;
        if (effect.description) content += `<span class="desc-tooltip">${effect.description}</span>`;
        if (effect.duration !== Infinity && typeof effect.duration === 'number') {
            content += `<span class="duration-tooltip">Duración: ${effect.duration.toFixed(1)}s</span>`;
        } else if (effect.duration === Infinity) {
            content += `<span class="duration-tooltip">Duración: Permanente</span>`;
        }
        // Mostrar modificadores de stats si existen
        if (effect.statsModifiers) {
            content += `<div class="stats-tooltip" style="margin-top: 5px;">`;
             for(const [stat, value] of Object.entries(effect.statsModifiers)) {
                 if(value !== 0) {
                     const sign = value > 0 ? '+' : '';
                     const suffix = stat.includes('Multiplier') ? 'x' : (stat.includes('Chance') ? '%' : '');
                     const valueFormatted = stat.includes('Multiplier') ? value.toFixed(2) : value;
                     content += `<span>${sign}${valueFormatted}${suffix} ${getStatName(stat)}</span>`;
                 }
             }
            content += `</div>`;
        }
         // Mostrar info de DoT si existe
         if(effect.damagePerTick) {
              content += `<div class="desc-tooltip" style="margin-top: 3px; color: var(--color-danger);">Daño: ${effect.damagePerTick.amount} ${effect.damagePerTick.type || 'tipo'} cada ${effect.tickTime || 1}s</div>`;
         }

        content += `</div>`;
        tooltip.innerHTML = content; positionTooltip(tooltip, event); tooltip.style.display = 'block'; gameState.activeTooltip = tooltip;
    }

    // --- Definiciones de Efectos Base ---
    const POISON_EFFECT_DATA = { id: 'poison', name: 'Envenenado', icon: 'fa-skull-crossbones', duration: 8, tickTime: 1.0, damagePerTick: { amount: 4, type: 'poison' }, onApply: (t) => logMessage(`${t.name||'Objetivo'} envenenado.`, 'warning'), onTick: (t, e) => { if(e.damagePerTick.amount > 0) { const targetObj = (t === playerState) ? playerModel : world.enemies.find(en => en.userData === t); if (targetObj) applyDamage(targetObj, e.damagePerTick.amount, e.damagePerTick.type || 'poison', false); } }, onEnd: (t) => logMessage(`Veneno en ${t.name||'Objetivo'} disipado.`, 'system'), class: 'status-poison', description: 'Recibiendo daño periódico.' };
    const BLEED_EFFECT_DATA = { id: 'bleed', name: 'Sangrando', icon: 'fa-tint', duration: 6, tickTime: 1.5, damagePerTick: { amount: 5, type: 'physical' }, /* ... onApply/onTick/onEnd similar a poison ... */ class: 'status-bleed', description: 'Perdiendo salud por herida.' };
    const BURN_EFFECT_DATA = { id: 'burn', name: 'Quemándose', icon: 'fa-fire', duration: 5, tickTime: 1.0, damagePerTick: { amount: 6, type: 'fire' }, /* ... onApply/onTick/onEnd similar a poison ... */ class: 'status-burn', description: 'Recibiendo daño por fuego.' };
    // Podrían definirse más aquí (Slow, Stun, Buffs genéricos, etc.)

    // --- Funciones de Hechizos ---
    function updateSpellCooldowns(deltaTime) {
         let uiNeedsUpdate = false;
         spells.known.forEach(spell => {
             if (spell.cooldownRemaining && spell.cooldownRemaining > 0) {
                 spell.cooldownRemaining -= deltaTime * 1000; // Cooldowns en ms
                 if (spell.cooldownRemaining <= 0) {
                      spell.cooldownRemaining = 0;
                      // Opcional: Notificación de que el hechizo está listo
                      // if (spell.id === spells.known[spells.selectedSpellIndex]?.id) { showNotification(`${spell.name} está listo!`, 'info', 1500); }
                 }
                 uiNeedsUpdate = true;
             }
         });
         // Actualizar UI solo si está visible y hubo cambios
         if (uiNeedsUpdate && domCache['spells-tab']?.classList.contains('active')) {
             updateSpellsUI();
             // También actualizar hotbar si el hechizo está ahí
             updateActionSlotsUI();
         }
     }

    function updateSpellsUI() {
        const spellsList = domCache['spells-list']; if (!(spellsList instanceof HTMLElement)) return;
        spellsList.innerHTML = '';
        spells.known.forEach((spell, index) => {
            const spellDef = spellDefinitions[spell.id]; if (!spellDef) return;
            const item = document.createElement('div'); item.className = 'spell-item'; item.dataset.index = index.toString();
            if (index === spells.selectedSpellIndex) item.classList.add('selected');
            const isOnCooldown = (spell.cooldownRemaining || 0) > 0;
            const cooldownPercent = spellDef.cooldown > 0 ? Math.min(100, (spell.cooldownRemaining / spellDef.cooldown) * 100) : 0;
            let cooldownText = 'Listo'; if (isOnCooldown) { const s = (spell.cooldownRemaining/1000).toFixed(1); cooldownText = `${s}s`; }
            const finalManaCost = Math.floor((spellDef.manaCost||0)*(playerState.manaCostMultiplier||1)); // Coste con modificadores

            item.innerHTML = `
                <span class="spell-icon">${spellDef.icon || '❓'}</span>
                <div class="spell-info">
                    <div class="spell-name">${spellDef.name}</div>
                    <div class="spell-cost-cd">
                        <span class="spell-cost">Coste: ${finalManaCost} PM</span>
                        <span class="spell-cooldown ${isOnCooldown ? 'on-cooldown' : ''}">${cooldownText}</span>
                    </div>
                </div>
                ${isOnCooldown ? `<div class="spell-cooldown-overlay" style="height: ${cooldownPercent}%"></div>` : ''}
            `;
            item.addEventListener('click', () => selectSpell(index));
            item.addEventListener('mouseenter', (e) => showSpellTooltip(spellDef, spell, e));
            item.addEventListener('mouseleave', hideTooltip);
            spellsList.appendChild(item);
        });
    }

    function selectSpell(index) {
        // Cancelar otros modos de apuntado/acción
        exitSpellTargetingMode(); cancelAiming();
        playerState.isChargingAttack = false; // Cancelar carga si estaba activa

        const prevIndex = spells.selectedSpellIndex;
        if (prevIndex !== null) { const prevEl = domCache['spells-list']?.querySelector(`.spell-item[data-index="${prevIndex}"]`); if (prevEl) prevEl.classList.remove('selected'); }
        if (prevIndex === index) { // Deseleccionar si se clickea el mismo
            spells.selectedSpellIndex = null;
        } else { // Seleccionar nuevo
            spells.selectedSpellIndex = index;
            const newEl = domCache['spells-list']?.querySelector(`.spell-item[data-index="${index}"]`); if (newEl) newEl.classList.add('selected');
        }
        updateActionButtons(); AudioManager.playSound('ui_confirm', 0.3);
    }

    function showSpellTooltip(spellDef, spellInstance, event) {
        const tooltip = domCache['spell-tooltip']; if (!tooltip || !spellDef) return;
        const finalManaCost = Math.floor((spellDef.manaCost||0)*(playerState.manaCostMultiplier||1));
        let content = `<div class="tooltip-section"><span class="name-tooltip spell-name-tooltip">${spellDef.name}</span><span class="type-tooltip">Hechizo (${spellDef.type || 'General'})</span>`;
        if (spellDef.element) content += `<span class="type-tooltip">Elemento: ${spellDef.element}</span>`;
        if (spellDef.description) content += `<span class="desc-tooltip">${spellDef.description}</span>`;
        content += `</div><div class="tooltip-section">`;
        if (spellDef.manaCost) content += `<span class="cost-tooltip">Coste Maná: ${finalManaCost} ${playerState.manaCostMultiplier !== 1.0 ? `(${spellDef.manaCost} base)`: ''}</span>`;
        if (spellDef.castTime) content += `<span class="details-tooltip">Lanzamiento: ${spellDef.castTime / 1000}s</span>`;
        if (spellDef.cooldown) { const cdR = spellInstance.cooldownRemaining || 0; const cdT = cdR > 0 ? `${(cdR/1000).toFixed(1)}s restante` : 'Listo'; content += `<span class="cooldown-tooltip">Enfriamiento: ${spellDef.cooldown / 1000}s (${cdT})</span>`; }
        if (spellDef.range) content += `<span class="details-tooltip">Alcance: ${spellDef.range}m</span>`;
        if (spellDef.requiredSkillLevel) {
             const reqMet = (playerState.skills[Object.keys(spellDef.requiredSkillLevel)[0]]?.level || 0) >= Object.values(spellDef.requiredSkillLevel)[0];
             content += `<span class="recipe-skill-tooltip ${reqMet ? 'req-met' : 'req-not-met'}">Req: ${Object.keys(spellDef.requiredSkillLevel)[0]} ${Object.values(spellDef.requiredSkillLevel)[0]}</span>`;
        }
        content += `</div>`;
        tooltip.innerHTML = content; positionTooltip(tooltip, event); tooltip.style.display = 'block'; gameState.activeTooltip = tooltip;
    }

    /**
     * Entra en modo apuntar hechizo.
     * (Sin cambios funcionales, pero reconfirmada)
     * @param {object} spellDefinition La definición del hechizo.
     */
     function enterSpellTargetingMode(spellDefinition) {
         if (gameState.isTargetingSpell || gameState.isAimingWithBow || !gameState.isPlaying || gameState.isPaused || gameState.isGhost) return;
         if (!spellDefinition) { console.error("enterSpellTargetingMode sin spellDefinition"); return; }

         gameState.isTargetingSpell = true;
         gameState.spellBeingTargeted = spellDefinition;

         document.body.classList.add('targeting');
         const gameCanvas = domCache['game-canvas'];
         if (gameCanvas instanceof HTMLElement) gameCanvas.classList.add('targeting');

         logMessage(`Selecciona objetivo para ${spellDefinition.name}. (Clic Izq: Lanzar, Clic Der/Esc: Cancelar)`, "info");
         showNotification(`Apuntando: ${spellDefinition.name}`, "system", 2500);
         console.log(`[enterSpellTargetingMode] Entered targeting for ${spellDefinition.name}`);
     }

   /**
     * Sale del modo apuntar hechizo.
     * (v4 - Clearer Logs, Force Cursor Reset)
     */
    function exitSpellTargetingMode() {
        const functionName = "exitSpellTargetingMode (v4)";
        if (!gameState.isTargetingSpell) {
            // console.log(`[${functionName}] Already not targeting.`); // Optional log
            return;
        }

        console.log(`[${functionName}] Exiting spell targeting mode...`);
        gameState.isTargetingSpell = false;
        gameState.spellBeingTargeted = null;

        // Remove targeting class from body and canvas
        document.body.classList.remove('targeting');
        const gameCanvas = domCache['game-canvas'];
        if (gameCanvas instanceof HTMLElement) {
            gameCanvas.classList.remove('targeting');
            // --- Force cursor reset on canvas ---
            gameCanvas.style.cursor = ''; // Reset to CSS default
            console.log(`[${functionName}] Canvas cursor style reset.`);
        }
        // --- Force cursor reset on body ---
        document.body.style.cursor = ''; // Reset to CSS default
        console.log(`[${functionName}] Body cursor style reset.`);


        console.log(`[${functionName}] Targeting state and cursor reset.`);
    } // --- Fin exitSpellTargetingMode (v4) ---
    
    
    /**
     * Realiza un raycast desde el cursor y devuelve el primer objetivo válido
     * (entidad o punto en el suelo) según las reglas del arma/hechizo.
     * (v6 - Clearer Logging, Robust Entity Finding)
     * @param {'bow' | object} weaponOrSpellDef - 'bow' o definición del hechizo.
     * @returns {THREE.Object3D | THREE.Vector3 | null} El objetivo encontrado o null.
     */
    function findValidTargetUnderCursor(weaponOrSpellDef) {
        const functionName = "findValidTargetUnderCursor (v6)";
        console.log(`[${functionName}] Started.`);
        if (!raycaster || !camera || !mouse || !weaponOrSpellDef || !playerState?.position) {
            console.warn(`[${functionName}] Aborting: Missing essential data (Ray, Cam, Mouse, Def, PlayerPos).`);
            return null;
        }

        // --- 1. Determine Parameters ---
        let maxRangeSq = 0; let targetType = 'any'; let canTargetGround = false;
        let spellName = '[Unknown Action]'; let rangeCheckOrigin = playerState.position;

        if (weaponOrSpellDef === 'bow') {
            maxRangeSq = (60) ** 2; targetType = 'enemy'; canTargetGround = false; spellName = 'Bow Shot';
        } else if (typeof weaponOrSpellDef === 'object' && weaponOrSpellDef.id) {
            maxRangeSq = (weaponOrSpellDef.range || 30) ** 2;
            targetType = weaponOrSpellDef.targetType || 'any';
            canTargetGround = (targetType === 'ground' || weaponOrSpellDef.type === 'area_effect' || weaponOrSpellDef.type === 'summon');
            spellName = weaponOrSpellDef.name || weaponOrSpellDef.id;
        } else { console.error(`[${functionName}] Invalid weaponOrSpellDef.`); return null; }
        console.log(`[${functionName}] Action: ${spellName}, RequiredType: ${targetType}, RangeSq: ${maxRangeSq.toFixed(0)}, CanTargetGround: ${canTargetGround}`);

        // --- 2. Update Raycaster (Crucial - ensure it uses current mouse coords) ---
        try {
            raycaster.setFromCamera(mouse, camera); // Update ray from latest mouse position
        } catch (e) {
            console.error(`[${functionName}] Error setting raycaster from camera:`, e);
            return null;
        }


        // --- 3. Raycast Entities ---
        let potentialTargets = [];
        // Build potential target list based on targetType
        if (targetType === 'enemy') potentialTargets = world.enemies.filter(e => e?.userData && !e.userData.isDead && e.visible);
        else if (targetType === 'friendly') potentialTargets = world.npcs.filter(n => n?.userData);
        else if (targetType === 'self') potentialTargets = [playerModel];
        else if (targetType === 'any' || canTargetGround || targetType === 'friendly') { // Combine cases that include NPCs/Enemies
             potentialTargets = world.enemies.filter(e => e?.userData && !e.userData.isDead && e.visible)
                                .concat(world.npcs.filter(n => n?.userData));
        }
        // Always add player if they can be targeted
        if (['friendly', 'self', 'any'].includes(targetType) && playerModel && !potentialTargets.includes(playerModel)) {
             potentialTargets.push(playerModel);
        }
        potentialTargets = potentialTargets.filter(t => t != null); // Final filter for nulls


        console.log(`[${functionName}] Potential entity targets count: ${potentialTargets.length}`);
        let firstValidEntity = null;
        let intersectedEntity = null; // Store the first entity hit by raycast

        if (potentialTargets.length > 0) {
            try {
                const intersects = raycaster.intersectObjects(potentialTargets, true);
                console.log(`[${functionName}] Entity Raycast Intersects: ${intersects.length}`);

                if (intersects.length > 0) {
                    console.log(`[${functionName}] --- Intersection Details ---`);
                     intersects.forEach((intersect, index) => { let obj=intersect.object; let name=obj.name||"[no name]"; let type=obj.userData?.type||"[no type]"; let parentInfo=""; if(obj.parent&&obj.parent!==scene){parentInfo=` (Parent: ${obj.parent.name||"[no name]"}${obj.parent.userData?.type?`[${obj.parent.userData.type}]`:''})`}; console.log(`  [${index}] Hit: ${name} [${type}]${parentInfo} at dist ${intersect.distance.toFixed(2)}`); });
                    console.log(`[${functionName}] --- End Intersection Details ---`);

                    // --- Find the actual game entity object from the intersection ---
                    for (const intersect of intersects) {
                        let currentObject = intersect.object;
                        let entityFound = null;
                        let depth = 0;
                        while (currentObject && depth < 10) {
                            const ud = currentObject.userData;
                            if (ud && (ud.type === 'enemy' || ud.type === 'npc' || currentObject === playerModel)) {
                                entityFound = currentObject; break;
                            }
                            if (!currentObject.parent || currentObject.parent === scene) break;
                            currentObject = currentObject.parent; depth++;
                        }

                        if (entityFound) {
                            intersectedEntity = entityFound; // Found the first game entity hit
                            console.log(`[${functionName}] Identified Intersected Entity: ${intersectedEntity.userData?.name || (intersectedEntity === playerModel ? 'Player' : 'Entity')}`);
                            break; // Stop checking intersections once we find the first entity
                        } else {
                             console.log(`[${functionName}] Intersected object (${intersect.object.name}) did not lead to a valid game entity.`);
                        }
                    } // end for intersects
                } else { console.log(`[${functionName}] Raycast did not intersect any potential entity targets.`); }
            } catch (e) { console.error(`[${functionName}] Error during entity raycast:`, e); }
        } else { console.log(`[${functionName}] No potential entity targets defined.`); }

        // --- 4. Validate the Intersected Entity (Range & LOS) ---
        if (intersectedEntity) {
            const targetName = intersectedEntity.userData?.name || (intersectedEntity === playerModel ? 'Player' : 'Entity');
            console.log(`[${functionName}] Validating intersected entity: ${targetName}`);

            // a. Check Range
            const distSq = rangeCheckOrigin.distanceToSquared(intersectedEntity.position);
            if (distSq > maxRangeSq) {
                console.log(`    - FAILED: Out of range (${Math.sqrt(distSq).toFixed(1)}m > ${Math.sqrt(maxRangeSq).toFixed(1)}m).`);
            } else {
                console.log(`    - PASSED: In range (${Math.sqrt(distSq).toFixed(1)}m).`);
                // b. Check Line of Sight (LOS)
                const losStart = rangeCheckOrigin.clone().add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.8, 0));
                const losEnd = intersectedEntity.position.clone().add(new THREE.Vector3(0, intersectedEntity.userData?.heightOffset || (intersectedEntity === playerModel ? PLAYER_HALF_HEIGHT : 0.5), 0));
                if (!checkLineOfSight(losStart, losEnd)) {
                    console.log("    - FAILED: Line of sight blocked.");
                } else {
                    console.log("    - PASSED: Line of sight clear.");
                    // c. Passed all checks!
                    console.log(`[${functionName}] --> ENTITY TARGET VALIDATED: ${targetName}`);
                    firstValidEntity = intersectedEntity;
                }
            }
        }

        // --- 5. If a Valid Entity was Found, Return It ---
        if (firstValidEntity) {
            console.log(`[${functionName}] Returning valid entity: ${firstValidEntity.userData?.name || 'Player'}`);
            return firstValidEntity;
        }

        // --- 6. If No Valid Entity, Check Ground (if allowed) ---
        if (canTargetGround) {
            console.log(`[${functionName}] No valid entity found/validated, checking ground intersection...`);
            const terrainMeshes = [];
            // Get terrain/floor meshes (same as before)
             if (gameState.currentLocation === 'world') { ChunkManager.activeChunks.forEach(chunk => { if (chunk.terrainMesh?.visible) terrainMeshes.push(chunk.terrainMesh); }); }
             else { const floorMesh = world.dungeon?.geometryGroup?.getObjectByName("DungeonFloor"); if (floorMesh?.visible) terrainMeshes.push(floorMesh); }
            console.log(`[${functionName}] Terrain/Floor meshes for ground check: ${terrainMeshes.length}`);

            if (terrainMeshes.length > 0) {
                try {
                    const groundIntersects = raycaster.intersectObjects(terrainMeshes, false);
                    console.log(`[${functionName}] Ground Intersects Found: ${groundIntersects.length}`);
                    if (groundIntersects.length > 0) {
                        const groundPoint = groundIntersects[0].point;
                        const groundDistSq = rangeCheckOrigin.distanceToSquared(groundPoint);
                        if (groundDistSq <= maxRangeSq) {
                            console.log(`[${functionName}] --> GROUND TARGET FOUND & VALIDATED at (${groundPoint.x.toFixed(1)}, ${groundPoint.z.toFixed(1)}).`);
                            return groundPoint; // Valid ground point in range
                        } else { console.log("    - Ground target out of range."); }
                    } else { console.log("    - Raycast missed ground."); }
                } catch (e) { console.error(`[${functionName}] Error Raycasting Ground:`, e); }
            } else { console.log(`[${functionName}] No terrain/floor meshes found for ground check.`); }
        } else {
            console.log(`[${functionName}] Ground targeting not allowed.`);
        }

        // --- 7. No Valid Target Found ---
        console.log(`[${functionName}] No valid target found after all checks.`);
        return null;
    } // --- Fin findValidTargetUnderCursor (v6) ---


   /**
     * Ejecuta el lanzamiento final de un hechizo sobre un objetivo validado.
     * (v3.2 - Refined Logs, Target Validity Check in Timeout)
     * @param {object} spellDef - La definición completa del hechizo.
     * @param {THREE.Object3D | THREE.Vector3} target - El objetivo (Object3D o Vector3).
     */
    function castSpellAtTarget(spellDef, target) {
        const functionName = "castSpellAtTarget (v3.2)";
        // --- 1. Validations (Same as before) ---
        if (!spellDef || !spellDef.id || !target) { console.error(`[${functionName}] Invalid data.`); return; }
        const spellInstance = spells.known.find(s => s.id === spellDef.id);
        if (!spellInstance) { console.error(`[${functionName}] Spell instance not found: ${spellDef.id}`); return; }
        if ((spellInstance.cooldownRemaining || 0) > 100 && !gameState.isTargetingSpell) { /* ... cooldown log ... */ return; }
        const finalManaCost = Math.floor((spellDef.manaCost || 0) * (playerState.manaCostMultiplier || 1));
        if (playerState.stats.mana < finalManaCost) { /* ... mana log ... */ return; }
        if (spellDef.requiredSkillLevel) { /* ... skill check ... */ const skillId = Object.keys(spellDef.requiredSkillLevel)[0]; const reqLevel = spellDef.requiredSkillLevel[skillId]; if ((playerState.skills[skillId]?.level || 0) < reqLevel) { logMessage(`Requiere Nivel ${reqLevel} de ${skillDefinitions[skillId]?.name || skillId}.`, "warning"); console.log(`[${functionName}] Aborted: Skill requirement not met.`); return; } }


        const targetNameDesc = target instanceof THREE.Vector3 ? `Ground(${target.x.toFixed(1)},${target.z.toFixed(1)})` : (target.userData?.name || target.uuid || '[Object]');
        console.log(`[${functionName}] === CASTING ${spellDef.name} at ${targetNameDesc} ===`);

        // --- 2. Consume Resources & Start Cooldown (Same as before) ---
        playerState.stats.mana -= finalManaCost;
        spellInstance.cooldownRemaining = spellDef.cooldown || 0;
        console.log(`[${functionName}] Mana consumed: ${finalManaCost}. Cooldown started: ${spellInstance.cooldownRemaining}ms`);

        // --- 3. Handle Cast Time ---
        playerState.isCastingSpell = true;
        const castTime = spellDef.castTime || 500; // Default cast time
        AudioManager.playSound('spell_cast', 0.55);
        console.log(`[${functionName}] Cast time started: ${castTime}ms`);
        if (playerState.castingSpellTimeoutId) clearTimeout(playerState.castingSpellTimeoutId);

        // --- Store target reference for the timeout ---
        // If it's an object, store its UUID. If it's a Vector3, store a clone.
        const targetReference = (target instanceof THREE.Object3D) ? target.uuid : target.clone();

        playerState.castingSpellTimeoutId = setTimeout(() => {
            console.log(`[${functionName}] Cast time FINISHED for ${spellDef.name}.`);
            playerState.isCastingSpell = false;
            playerState.castingSpellTimeoutId = null;

            // --- Re-validate Target Inside Timeout ---
            let finalTarget = null;
            if (targetReference instanceof THREE.Vector3) {
                finalTarget = targetReference; // Ground target is always valid
                console.log(`[${functionName}] Target is ground point.`);
            } else if (typeof targetReference === 'string') { // It was an object UUID
                // Find the object again using the UUID
                finalTarget = scene.getObjectByProperty('uuid', targetReference);
                // Check if the target still exists and is valid (e.g., not dead if it's an enemy)
                if (!finalTarget || (finalTarget.userData?.type === 'enemy' && finalTarget.userData?.isDead)) {
                    console.warn(`[${functionName}] Target entity (UUID: ${targetReference}) no longer valid or is dead. Spell fizzles.`);
                    logMessage(`${spellDef.name} falló (objetivo inválido).`, "warning");
                    finalTarget = null; // Invalidate the target
                } else {
                     console.log(`[${functionName}] Target entity (UUID: ${targetReference}, Name: ${finalTarget.userData?.name}) re-validated.`);
                }
            }

            // --- Execute Spell Effect if Target is Still Valid ---
            if (finalTarget && typeof spellDef.cast === 'function') {
                try {
                    console.log(`[${functionName}] Executing spellDef.cast() on final target...`);
                    spellDef.cast(playerModel, finalTarget, spellDef.id);
                    console.log(`[${functionName}] spellDef.cast() executed for ${spellDef.name}.`);
                } catch (e) {
                    console.error(`[${functionName}] *** Error executing cast() for ${spellDef.id}:`, e);
                    logMessage(`Error al lanzar ${spellDef.name}.`, "error");
                }
            } else if (finalTarget && typeof spellDef.cast !== 'function') {
                 console.warn(`[${functionName}] Spell ${spellDef.id} has no cast() function.`);
                 logMessage(`Error: ${spellDef.name} sin efecto.`, "error");
            } else {
                 // Fizzle message already logged if target became invalid
                 console.log(`[${functionName}] Spell effect aborted due to invalid final target.`);
            }

            // --- Update UI After Effect (or fizzle) ---
            console.log(`[${functionName}] Updating UI after cast finished/fizzled.`);
            updatePlayerUI(); updateSpellsUI(); updateActionButtons();

        }, castTime);

        // --- 4. Immediate Feedback & Exit Targeting (Crucial: exit happens *before* timeout) ---
        logMessage(`Lanzando ${spellDef.name}...`, 'magic');
        updatePlayerUI(); // Update mana bar immediately
        updateSpellsUI(); // Show cooldown starting
        updateActionButtons();
        console.log(`[${functionName}] Calling exitSpellTargetingMode immediately after STARTING cast...`);
        exitSpellTargetingMode(); // Exit targeting mode NOW

        console.log(`[${functionName}] Cast initiated, timeout set.`);
    } // --- Fin castSpellAtTarget (v3.2) ---



function getTargetPositionFromCamera() {
        const screenCenter = new THREE.Vector2(0, 0); // Centro de la pantalla
        const targetRaycaster = new THREE.Raycaster();
        targetRaycaster.setFromCamera(screenCenter, camera);

        // Intersectar con enemigos y terreno
        const targets = [...world.enemies.filter(e => e?.userData && !e.userData.isDead && e.visible), ChunkManager.activeChunks.get(`${ChunkManager.playerChunkCoords.x}_${ChunkManager.playerChunkCoords.z}`)?.terrainMesh].filter(t => t != null);
         // Añadir terreno de chunks adyacentes si es necesario para largo alcance
         // ... (lógica para añadir más terreno a targets) ...

        try {
            const intersects = targetRaycaster.intersectObjects(targets, true); // true = recursivo

            if (intersects.length > 0) {
                 // Priorizar enemigos sobre terreno si están cerca
                 const firstEnemy = intersects.find(i => i.object.userData?.type === 'enemy' || i.object.parent?.userData?.type === 'enemy');
                 if (firstEnemy) return firstEnemy.point; // Punto de impacto en el enemigo
                 // Si no hay enemigo, devolver el punto en el terreno
                 return intersects[0].point;
            } else {
                // Si no intersecta nada cercano, proyectar a una distancia fija
                const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
                return playerState.position.clone().addScaledVector(forward, 35); // Punto a 35m por defecto
            }
        } catch (e) {
             console.error("Error en raycaster para objetivo de cámara:", e);
             const forward = new THREE.Vector3(); camera.getWorldDirection(forward);
             return playerState.position.clone().addScaledVector(forward, 35); // Fallback
        }
    }


    // --- Funciones de Habilidades y Fabricación ---
    function updateSkillsUI() {
        const skillsList = domCache['modal-skills-modal-skillsList'];
        const pointsInfo = domCache['modal-skills-modal-skillPointsInfo'];

        // --- VALIDATION ---
        if (!(skillsList instanceof HTMLElement) || !(pointsInfo instanceof HTMLElement)) {
            if(domCache['skills-modal']) console.error("updateSkillsUI: Elementos internos modal (#skills-list o #skill-points-info) no encontrados.");
            return;
        }
        console.log("[updateSkillsUI] Updating..."); // DEBUG

        skillsList.innerHTML = ''; // Clear previous list
        pointsInfo.textContent = `Puntos de Habilidad Asignables: ${playerState.skillPoints}`; // Update points display

        // --- Iterate and Build ---
        Object.entries(playerState.skills || {}).forEach(([skillId, skillData]) => {
            const skillDef = skillDefinitions[skillId];
            if (!skillDef) {
                console.warn(`[updateSkillsUI] Skill definition not found for ID: ${skillId}`);
                return; // Skip if definition is missing
            }

            const entry = document.createElement('div');
            entry.className = 'skill-entry';
            entry.dataset.skillId = skillId;

            // --- Name, Level, Assigned Points Display ---
            const nameLevelDiv = document.createElement('div');
            nameLevelDiv.className = 'skill-name-level';
            const assignedPoints = playerState.assignedSkillPoints?.[skillId] || 0; // Use separate tracker
            const currentLevel = skillData.level || 1; // Get current level
            nameLevelDiv.innerHTML = `<span class="skill-name">${skillDef.name}</span><span class="skill-level">Nvl ${currentLevel} (${assignedPoints} pts)</span>`;

            // --- Allocate Button Logic ---
            const canAssignPoint = playerState.skillPoints > 0 && assignedPoints < 100 && !skillDef.requiresAssign;

            if (!skillDef.requiresAssign) { // Only show '+' if it's not an assign-only skill
                 const addButton = document.createElement('button');
                 addButton.className = 'skill-alloc-button';
                 addButton.innerHTML = `<i class="fas fa-plus"></i>`;
                 addButton.title = `Asignar punto (Restantes: ${playerState.skillPoints})`;
                 addButton.dataset.skillId = skillId; // Set skillId for the listener

                 // *** Set disabled state BEFORE adding listener ***
                 addButton.disabled = !canAssignPoint;

                 // *** Clear previous listener and add new one ***
                 if (addButton.currentClickListener) addButton.removeEventListener('click', addButton.currentClickListener);
                 addButton.currentClickListener = (e) => {
                     e.stopPropagation(); // Prevent triggering tooltip/entry click
                     const sId = e.currentTarget.dataset.skillId; // Get skillId from button
                     if (sId) {
                         console.log(`[+] Button clicked for skill: ${sId}`); // DEBUG
                         allocateSkillPoint(sId); // Call allocation function
                     } else {
                         console.error("Skill ID missing from allocate button dataset!");
                     }
                 };
                 addButton.addEventListener('click', addButton.currentClickListener);

                 nameLevelDiv.appendChild(addButton); // Add button to the div
                 nameLevelDiv.style.alignItems = 'center'; // Align items vertically
             } else {
                  // Optionally add placeholder or info for assign-only skills
             }


            entry.appendChild(nameLevelDiv); // Add name/level/button div

            // --- XP Bar ---
            const xpPercent = (skillData.xpToNext || 1) > 0 ? Math.min(100, ((skillData.xp || 0) / skillData.xpToNext) * 100) : 100;
            const xpBarContainer = document.createElement('div');
            xpBarContainer.className = 'skill-xp-bar-container';
            xpBarContainer.innerHTML = `<div class="skill-xp-bar" style="width: ${xpPercent.toFixed(1)}%"></div>`;
            entry.appendChild(xpBarContainer);

            // --- Tooltip Listeners ---
            const tooltipElement = domCache['modal-skills-modal-skillTooltip'] || domCache['skill-tooltip'];
            // Clear previous listeners
            if (entry.currentMouseEnterListener) entry.removeEventListener('mouseenter', entry.currentMouseEnterListener);
            if (entry.currentMouseLeaveListener) entry.removeEventListener('mouseleave', entry.currentMouseLeaveListener);
            // Add new listeners
            entry.currentMouseEnterListener = (e) => showSkillTooltip(skillDef, skillData, e, tooltipElement);
            entry.currentMouseLeaveListener = hideTooltip;
            entry.addEventListener('mouseenter', entry.currentMouseEnterListener);
            entry.addEventListener('mouseleave', entry.currentMouseLeaveListener);

            skillsList.appendChild(entry); // Add the complete entry to the list
        });
        console.log("[updateSkillsUI] Update finished."); // DEBUG
    }

    function showSkillTooltip(skillDef, skillData, event, tooltipElement) { // Acepta elemento tooltip
        const tooltip = tooltipElement || domCache['skill-tooltip']; // Usa el pasado o el global
        if (!(tooltip instanceof HTMLElement) || !skillDef) return;

        const skillLevel = skillData.level || 1;
        const assignedPoints = skillData.assignedPoints || 0;
        const currentXP = skillData.xp || 0;
        const xpToNext = skillData.xpToNext || calculateSkillXPForLevel(skillDef.id, skillLevel + 1);
        const naturalCap = calculateNaturalSkillCap(playerState.level); // Límite natural actual
        const isNatBlocked = assignedPoints > naturalCap && skillLevel >= naturalCap;

        let content = `<div class="tooltip-section">
                         <span class="name-tooltip">${skillDef.name}</span>`;
        if (skillDef.description) content += `<span class="desc-tooltip">${skillDef.description}</span>`;
        content += `<span class="skill-level-tooltip">Nivel: ${skillLevel} / 100</span>`;
        content += `<span class="desc-tooltip" style="font-size:9px;">Puntos Asignados: ${assignedPoints}</span>`;

        if (skillLevel < 100) {
            content += `<span class="skill-xp-tooltip">XP: ${currentXP} / ${xpToNext}</span>`;
            content += `<span class="desc-tooltip" style="font-size:9px;">Límite Natural (Nvl ${playerState.level}): ${naturalCap}</span>`;
            if(isNatBlocked) content += `<span class="desc-tooltip" style="font-size:9px; color: var(--color-warning);"> (Ganancia natural bloqueada)</span>`;
        } else {
             content += `<span class="skill-xp-tooltip">XP: MAX</span>`;
        }
        content += `</div>`;

         if (skillDef.bonuses && skillDef.bonuses.length > 0) {
             content += `<div class="tooltip-section"><span class="stats-tooltip">Bonificaciones:</span>`;
             skillDef.bonuses.forEach(bonus => {
                  const bonusMet = skillLevel >= bonus.level;
                  const bonusValue = typeof bonus.value === 'function' ? bonus.value(skillLevel) : bonus.value; // Permitir cálculo dinámico
                  content += `<span class="skill-bonuses-tooltip" style="opacity: ${bonusMet ? 1 : 0.6};"> - Nvl ${bonus.level}: +${bonusValue}${bonus.stat.includes('Chance') || bonus.stat.includes('Reduction') ? '%' : ''} ${getStatName(bonus.stat)}</span><br>`;
             });
             content += `</div>`;
         }
        tooltip.innerHTML = content; positionTooltip(tooltip, event); tooltip.style.display = 'block'; gameState.activeTooltip = tooltip;
    }

    function gainSkillExperience(skillId, amount) {
        const skill = playerState.skills[skillId];
        const skillDef = skillDefinitions[skillId];
        if (!skill || !skillDef || skill.level >= 100) return;

        // Comprobar bloqueo por puntos asignados
        const naturalCap = calculateNaturalSkillCap(playerState.level);
        const assignedPts = playerState.assignedSkillPoints?.[skillId] || 0; // Usar el tracker separado
        if (assignedPts > naturalCap) { return; } // No ganar XP natural si asignados > cap

        skill.xp = (skill.xp || 0) + amount;
        logMessage(`Ganas ${amount} XP en ${skillDef.name}.`, 'info');

        let levelUp = false;
        while (skill.xp >= skill.xpToNext && skill.level < 100) {
            skill.level++; skill.xp -= skill.xpToNext;
            skill.xpToNext = calculateSkillXPForLevel(skillId, skill.level + 1);
            levelUp = true;
            logMessage(`¡${skillDef.name} Nivel ${skill.level}!`, 'success');
            updatePlayerStats(); // Recalcular stats si aplica
        }

        if (levelUp) { updateSkillsUI(); updatePlayerUI(); updateCharacterSheet(); }
        else if (domCache['skills-modal']?.style.display !== 'none') { // Actualizar barra si modal visible
            const skillBar = domCache['skills-modal'].querySelector(`#skills-list .skill-entry[data-skill-id="${skillId}"] .skill-xp-bar`);
            if (skillBar instanceof HTMLElement) { const p = skill.xpToNext > 0 ? Math.min(100, (skill.xp / skill.xpToNext) * 100) : 100; skillBar.style.width = `${p.toFixed(1)}%`; }
        }
    }

    // --- REVISIÓN: calculateNaturalSkillCap ---
    // Esta función necesita una implementación precisa basada en la tabla/ciclo 3-5-7-10.
    // Como placeholder, mantenemos la aproximación lineal pero es INCORRECTA.
    function calculateNaturalSkillCap(playerLevel) {
         if (playerLevel <= 0) return 0;
         if (playerLevel >= 40) return 100;
         // TABLA REAL (Ejemplo parcial - DEBE COMPLETARSE)
         const levelCaps = {
             1: 3, 2: 8, 3: 15, 4: 25, 5: 28, 6: 33, 7: 40, 8: 50,
             9: 53, 10: 58, 11: 65, 12: 75, 13: 78, /* ... */ 39: 90, 40: 100
             // Rellenar todos los niveles intermedios según el ciclo 3-5-7-10
         };
         // Buscar el cap del nivel más alto <= playerLevel
         let cap = 0;
         for (let lvl = 1; lvl <= playerLevel; lvl++) {
              if (levelCaps[lvl] !== undefined) cap = levelCaps[lvl];
              else if (lvl > 40) cap = 100; // Si se pasa
         }
          // Si no se encontró en la tabla (porque está incompleta), usar aproximación
          if (cap === 0 && playerLevel > 0) cap = Math.min(100, Math.floor(playerLevel * 2.5));

         return cap;
    }


    function allocateSkillPoint(skillId) {
        console.log(`[allocateSkillPoint] Attempting to allocate point to: ${skillId}`); // DEBUG

        // --- 1. Validate Inputs & State ---
        if (!skillId) { console.error("[allocateSkillPoint] Error: skillId is missing."); return; }
        const skill = playerState.skills?.[skillId];
        const skillDef = skillDefinitions?.[skillId];

        if (!skill || !skillDef) {
            logMessage("Error interno de habilidad.", "error");
            console.error(`[allocateSkillPoint] Error: Skill data or definition not found for ${skillId}`);
            return;
        }
        if (skillDef.requiresAssign) { // Double-check this condition
            logMessage("No puedes asignar puntos manualmente a esta habilidad.", "warning");
            console.log(`[allocateSkillPoint] Prevented allocation: ${skillId} requires specific assignment.`);
            AudioManager.playSound('ui_error', 0.4);
            return;
        }
        if (playerState.skillPoints <= 0) {
            logMessage("No tienes puntos de habilidad disponibles.", "warning");
            console.log("[allocateSkillPoint] Prevented allocation: No skill points remaining.");
            AudioManager.playSound('ui_error', 0.4);
            return;
        }
        const assignedPts = playerState.assignedSkillPoints?.[skillId] || 0;
        if (assignedPts >= 100) {
            logMessage(`${skillDef.name} ya tiene el máximo de puntos asignados (100).`, "info");
            console.log(`[allocateSkillPoint] Prevented allocation: ${skillId} already at max assigned points.`);
            return;
        }

        // --- 2. Allocate Point ---
        playerState.skillPoints--;
        playerState.assignedSkillPoints[skillId] = assignedPts + 1; // Increment the specific tracker
        const newAssignedPts = playerState.assignedSkillPoints[skillId];
        console.log(`[allocateSkillPoint] Point allocated to ${skillId}. Remaining: ${playerState.skillPoints}. New assigned: ${newAssignedPts}`); // DEBUG

        // --- 3. Update Skill Level (Max of XP level and Assigned points) ---
        // Ensure skill.level exists before comparing
        if (skill.level === undefined) skill.level = 1;
        const previousLevel = skill.level;
        skill.level = Math.max(previousLevel, newAssignedPts); // Level is the HIGHER of natural level or points assigned
        skill.level = Math.min(100, skill.level); // Ensure it doesn't exceed 100
        const levelIncreased = skill.level > previousLevel;
        console.log(`[allocateSkillPoint] ${skillId} level updated from ${previousLevel} to ${skill.level}. Increased: ${levelIncreased}`); // DEBUG

        // --- 4. Feedback and UI Update ---
        logMessage(`Asignaste 1 punto a ${skillDef.name} (Total Asignados: ${newAssignedPts}). Puntos restantes: ${playerState.skillPoints}`, "success");
        AudioManager.playSound('level_up', 0.5); // Use level up sound for assigning point

        // --- 5. Trigger Necessary Recalculations and UI Refresh ---
        if (levelIncreased || skillDef.bonuses) { // Recalculate stats if level increased OR if the skill has bonuses (even if level didn't change, the points did)
             console.log(`[allocateSkillPoint] Recalculating player stats due to allocation in ${skillId}.`);
             updatePlayerStats();
        }
        updateSkillsUI(); // ALWAYS refresh the skills UI after allocation
        updatePlayerUI(); // Update main UI (might affect regen if skill gave bonuses)
        if (gameState.isCharacterSheetOpen) updateCharacterSheet(); // Update sheet if open
    }

// Firma y lógica modificada
function updateCraftingUI(specificStationType = null, recipeIdsToDisplay = null) {
    const recipeList = domCache['modal-crafting-modal-recipeList'];
    if (!(recipeList instanceof HTMLElement)) { console.error("updateCraftingUI: Contenedor #recipe-list no encontrado."); return; }
    recipeList.innerHTML = '';
    gameState.selectedRecipeId = null;
    updateCraftingDetails(specificStationType); // <-- Pasar stationType a updateCraftingDetails

    // Usar recetas filtradas si se pasaron, si no, usar todas las conocidas
    const recipesToShow = recipeIdsToDisplay || playerState.knownRecipes || [];

    if (recipesToShow.length === 0) {
        recipeList.innerHTML = `<div class="recipe-item cannot-craft">${specificStationType ? 'No conoces recetas para esta estación.' : 'No conoces ninguna receta.'}</div>`;
        return;
    }

    recipesToShow.forEach(recipeId => {
        const recipeDef = recipeDefinitions[recipeId]; if (!recipeDef) { console.warn(`Definición no encontrada para receta ID: ${recipeId}`); return; }
        // *** PASAR stationType a canCraftRecipe ***
        const canCraftCheck = canCraftRecipe(recipeDef, specificStationType);

        const item = document.createElement('div');
        item.className = `recipe-item ${!canCraftCheck.canCraft ? 'cannot-craft' : ''}`;
        item.dataset.recipeId = recipeId;

        let skillReqText = '';
        if (recipeDef.skillReq) {
            const skillMet = canCraftCheck.skillMet;
            const skillName = skillDefinitions[recipeDef.skillReq.skill]?.name || recipeDef.skillReq.skill;
            skillReqText = `<span class="recipe-skill-req ${skillMet ? 'req-met' : 'req-not-met'}">(${skillName} ${recipeDef.skillReq.level})</span>`;
        }

        const resultItemName = getItemName(recipeDef.result);
        const resultCount = recipeDef.count > 1 ? ` x${recipeDef.count}` : '';
        item.innerHTML = `<span>${recipeDef.name || resultItemName}${resultCount} ${skillReqText}</span>`;

        // Limpiar y añadir listeners
        if (item.currentClickListener) item.removeEventListener('click', item.currentClickListener);
        item.currentClickListener = () => selectRecipe(recipeId); // selectRecipe llama a updateCraftingDetails CON stationType
        item.addEventListener('click', item.currentClickListener);

        if (item.currentMouseEnterListener) item.removeEventListener('mouseenter', item.currentMouseEnterListener);
        item.currentMouseEnterListener = (e) => showRecipeTooltip(recipeDef, e);
        item.addEventListener('mouseenter', item.currentMouseEnterListener);

        if (item.currentMouseLeaveListener) item.removeEventListener('mouseleave', item.currentMouseLeaveListener);
        item.currentMouseLeaveListener = hideTooltip;
        item.addEventListener('mouseleave', item.currentMouseLeaveListener);

        recipeList.appendChild(item);
    });
}

/**
 * Actualiza el panel de detalles de fabricación basado en la receta seleccionada
 * y opcionalmente en la estación de crafteo que se está utilizando.
 * (v3 - Incorpora specificStationType)
 * @param {string | null} [specificStationType=null] - El tipo de estación con la que se interactuó (si aplica).
 */
function updateCraftingDetails(specificStationType = null) {
    // --- 1. Obtener Elementos DOM ---
    // Usar claves cacheadas del modal
    const materialsDiv = domCache['modal-crafting-modal-craftingMaterials'];
    const descriptionDiv = domCache['modal-crafting-modal-craftingDescription'];
    const craftButton = domCache['modal-crafting-modal-craftButton'];
    // Buscar el título dentro del contenedor de detalles (asume estructura HTML)
    const detailsContainer = domCache['crafting-details']; // ID del div contenedor de detalles
    const detailsTitle = detailsContainer instanceof HTMLElement ? detailsContainer.querySelector('h4') : null;

    // --- 2. Validación Rigurosa de Elementos UI ---
    if (!(materialsDiv instanceof HTMLElement) ||
        !(descriptionDiv instanceof HTMLElement) ||
        !(craftButton instanceof HTMLButtonElement) ||
        !(detailsTitle instanceof HTMLElement)) {
        // Solo advertir si el modal de crafting existe, indicando un problema interno
        if (domCache['crafting-modal']) {
             console.error("updateCraftingDetails: Faltan elementos UI esenciales en el modal de crafting (#crafting-details h4, #crafting-materials, #crafting-description, #craft-button).");
        }
        // Deshabilitar botón como fallback si es posible
        if (craftButton instanceof HTMLButtonElement) craftButton.disabled = true;
        return;
    }

    // --- 3. Obtener Receta Seleccionada ---
    const recipeId = gameState.selectedRecipeId;

    // --- 4. Limpiar UI si no hay Receta Seleccionada ---
    if (!recipeId || !recipeDefinitions[recipeId]) {
        detailsTitle.textContent = 'Detalles de Receta';
        materialsDiv.innerHTML = 'Requiere: <span>Ninguno</span>';
        descriptionDiv.textContent = 'Selecciona una receta de la lista superior.';
        craftButton.disabled = true;
        craftButton.textContent = 'Fabricar';
        return;
    }

    // --- 5. Procesar Receta Seleccionada ---
    const recipeDef = recipeDefinitions[recipeId];
    // *** LLAMAR a canCraftRecipe PASANDO la estación actual ***
    const canCraftCheck = canCraftRecipe(recipeDef, specificStationType);
    const resultItemDef = itemDefinitions[recipeDef.result];

    // a. Actualizar Título
    detailsTitle.textContent = recipeDef.name || `Fabricar ${resultItemDef?.name || 'Objeto'}`;

    // b. Mostrar Materiales Requeridos y Disponibilidad
    if (recipeDef.materials && recipeDef.materials.length > 0) {
        materialsDiv.innerHTML = 'Requiere: '; // Resetear contenido
        recipeDef.materials.forEach(mat => {
            // Verificar si el material está disponible según el check previo
            const hasMat = canCraftCheck.materialsAvailable[mat.id] === true; // Acceso seguro
            const itemName = getItemName(mat.id); // Usar función helper
            const currentCount = countItemsInInventory(mat.id); // Usar función helper
            // Añadir span con clase y tooltip
            materialsDiv.innerHTML += `<span class="${hasMat ? 'has-mats' : 'no-mats'}" title="Tienes ${currentCount}">${itemName} (${mat.count})</span> `;
        });
    } else {
        materialsDiv.innerHTML = 'Requiere: <span>Ninguno</span>';
    }

    // c. Mostrar Descripción del Resultado y Requisito de Estación
    descriptionDiv.textContent = resultItemDef?.description || 'Crea un objeto útil.'; // Descripción base
    if (recipeDef.requiredStation) {
        const stationName = getStationName(recipeDef.requiredStation); // Usar función helper
        const stationMet = canCraftCheck.stationOk; // Usar el flag del check
        // Añadir el requisito al final de la descripción
        descriptionDiv.innerHTML += `<br><span style="font-size:10px; color: var(${stationMet ? '--color-success' : '--color-warning'});">(Requiere ${stationName} cercana)</span>`;
    }
     // Añadir requisito de clase si existe
     if (recipeDef.classRequirement) {
          const classMet = recipeDef.classRequirement.includes(playerState.class);
          descriptionDiv.innerHTML += `<br><span style="font-size:10px; color: var(${classMet ? '--color-success' : '--color-danger'});">(Req: Clase ${recipeDef.classRequirement.join('/')})</span>`;
     }


    // d. Habilitar/Deshabilitar y Configurar Botón de Fabricar
    craftButton.disabled = !canCraftCheck.canCraft; // Habilitar solo si TODOS los checks pasaron
    craftButton.textContent = `Fabricar ${resultItemDef?.name || 'Objeto'}${recipeDef.count > 1 ? ` x${recipeDef.count}` : ''}`;

} // --- Fin updateCraftingDetails ---



/**
 * Verifica si el jugador puede fabricar una receta específica,
 * considerando habilidad, materiales y la estación de crafteo (si aplica).
 * (v3 - Lógica Estación Mejorada con stationTypeUsed)
 * @param {object} recipeDef - La definición de la receta a comprobar.
 * @param {string | null} [stationTypeUsed=null] - El tipo de estación específica con la que se está interactuando, o null si es el panel general.
 * @returns {{canCraft: boolean, skillMet: boolean, materialsAvailable: {[itemId: string]: boolean}, stationOk: boolean}} - Objeto con los resultados de la comprobación.
 */
function canCraftRecipe(recipeDef, stationTypeUsed = null) {
    // 1. Inicializar resultado
    const result = {
        canCraft: true,      // Empieza asumiendo que sí se puede
        skillMet: true,      // Asume que cumple skill inicialmente
        materialsAvailable: {}, // Objeto para rastrear cada material
        stationOk: true       // Asume que la estación está bien inicialmente
    };

    // Salir si no hay definición de receta
    if (!recipeDef) {
        console.error("canCraftRecipe: recipeDef es undefined.");
        result.canCraft = false;
        return result;
    }

    // 2. Comprobar Nivel de Habilidad
    if (recipeDef.skillReq) {
        const playerSkillLevel = playerState.skills?.[recipeDef.skillReq.skill]?.level || 0;
        if (playerSkillLevel < recipeDef.skillReq.level) {
            result.canCraft = false;
            result.skillMet = false;
        }
    }

    // 3. Comprobar Requisito de Clase (si existe)
    if (recipeDef.classRequirement && !recipeDef.classRequirement.includes(playerState.class)) {
        result.canCraft = false;
        // result.classMet = false; // Podrías añadir flag si quieres mostrarlo
    }

    // 4. Comprobar Materiales
    if (recipeDef.materials) {
        for (const mat of recipeDef.materials) {
            if (!mat || !mat.id || typeof mat.count !== 'number' || mat.count <= 0) {
                console.warn("Material inválido en receta:", recipeDef.id, mat);
                continue; // Saltar material inválido
            }
            const count = countItemsInInventory(mat.id); // Usar función helper
            result.materialsAvailable[mat.id] = count >= mat.count;
            if (!result.materialsAvailable[mat.id]) {
                result.canCraft = false; // Si falta UN material, ya no se puede craftear
            }
        }
    }

    // 5. Comprobar Estación de Crafteo Cercana (Lógica Modificada)
    if (recipeDef.requiredStation) {
        const requiredType = recipeDef.requiredStation;
        result.stationOk = false; // Asumir que NO está ok hasta encontrarla

        // CASO A: El jugador está interactuando con una estación específica (`stationTypeUsed` tiene valor)
        if (stationTypeUsed) {
            if (requiredType === stationTypeUsed) {
                // Está en la estación correcta. Validar distancia como doble check.
                let foundCorrectStationNearby = false;
                // Iterar solo sobre los objetos interactuables para eficiencia
                world.interactables.forEach(obj => {
                    if (obj?.userData?.type === 'crafting_station' &&
                        obj.userData.stationType === requiredType &&
                        obj.position.distanceToSquared(playerState.position) < INTERACT_DISTANCE_SQ * 1.1) { // Margen pequeño
                        foundCorrectStationNearby = true;
                    }
                });
                if (foundCorrectStationNearby) {
                    result.stationOk = true; // La estación es la correcta Y está cerca
                } else {
                    // Esto es raro: debería estar cerca si interactuó, pero por si acaso
                    console.warn(`[canCraft] Usando estación ${stationTypeUsed}, pero no se encontró físicamente cerca.`);
                    result.canCraft = false; // No puede craftear si no está cerca
                }
            } else {
                // Está interactuando, pero con la estación INCORRECTA para esta receta
                result.canCraft = false; // No puede craftear
                // result.stationOk sigue false
            }
        }
        // CASO B: El jugador abrió el panel general de crafteo (`stationTypeUsed` es null)
        else {
            // Buscar si HAY ALGUNA estación del tipo requerido cerca
            let foundRequiredStationNearby = false;
            world.interactables.forEach(obj => { // Iterar sobre interactables
                if (foundRequiredStationNearby) return; // Optimización: Salir si ya se encontró
                if (obj?.userData?.type === 'crafting_station' &&
                    obj.userData.stationType === requiredType &&
                    obj.position.distanceToSquared(playerState.position) < INTERACT_DISTANCE_SQ * 1.1) { // Margen
                    foundRequiredStationNearby = true;
                }
            });

            if (!foundRequiredStationNearby) {
                result.canCraft = false; // Falla si no hay estación requerida cerca
                result.stationOk = false;
            } else {
                result.stationOk = true; // Pasa el check de estación porque hay una cerca (aunque no esté interactuando)
            }
        }
    } else {
        result.stationOk = true; // No requiere estación, pasa el check
    }

    // Si stationOk es falso, canCraft también debe ser falso
    if (!result.stationOk) {
        result.canCraft = false;
    }

    // 6. Devolver el resultado completo
    return result;
}
     function countItemsInInventory(itemId) {
         let count = 0;
         for (const item of inventory.items) {
             if (item && item.id === itemId) { // Añadir check por si hay nulls
                 count += item.count || 1;
             }
         }
         return count;
     }

     function removeItemsFromInventory(itemId, countToRemove) {
         let remainingToRemove = countToRemove;
         let itemWasSelected = false; // Flag si el item eliminado estaba seleccionado
         let indexShift = 0; // Cuánto se desplazan los índices

         for (let i = inventory.items.length - 1; i >= 0 && remainingToRemove > 0; i--) {
             const item = inventory.items[i];
             if (item && item.id === itemId) { // Check extra por si hay nulls
                 const amountToRemoveFromThisStack = Math.min(remainingToRemove, item.count || 1);
                 item.count -= amountToRemoveFromThisStack;
                 remainingToRemove -= amountToRemoveFromThisStack;

                 if (item.count <= 0) {
                     if (i === inventory.selectedItemIndex) itemWasSelected = true; // Marcar si se elimina el seleccionado
                     inventory.items.splice(i, 1); // Eliminar el stack vacío
                     if (inventory.selectedItemIndex !== null && i < inventory.selectedItemIndex) {
                          indexShift++; // Un item anterior fue eliminado, hay que ajustar el índice seleccionado
                     }
                 }
             }
         }

         // Ajustar índice seleccionado si es necesario
         if (itemWasSelected) {
              inventory.selectedItemIndex = null; // Deseleccionar si se eliminó el stack seleccionado
         } else if (inventory.selectedItemIndex !== null && indexShift > 0) {
              inventory.selectedItemIndex -= indexShift; // Ajustar índice
         }


         return remainingToRemove <= 0; // Devuelve true si se eliminaron todos
     }

     function craftSelectedItem() {
         const recipeId = gameState.selectedRecipeId; if (!recipeId) return;
         const recipeDef = recipeDefinitions[recipeId]; if (!recipeDef) return;
         const check = canCraftRecipe(recipeDef);
         if (!check.canCraft) {
              if(!check.skillMet) logMessage("Habilidad insuficiente.", "warning");
              else if (!check.stationOk) logMessage(`Requiere ${getStationName(recipeDef.requiredStation)}.`, "warning");
              else logMessage("Materiales insuficientes.", "warning");
              AudioManager.playSound('ui_error', 0.4); return;
         }

         // Consumir materiales
         if (recipeDef.materials) {
             for (const mat of recipeDef.materials) {
                 if (!removeItemsFromInventory(mat.id, mat.count)) {
                      console.error(`Error al consumir ${mat.id} para ${recipeId}`);
                      logMessage("Error al consumir materiales.", "error");
                      updateInventoryUI(); updateCraftingDetails(); // Revertir UI si falla
                      return;
                 }
             }
         }

         // Añadir resultado
         const resultItemDef = itemDefinitions[recipeDef.result];
         if (resultItemDef) {
              const added = addItemToInventory(recipeDef.result, recipeDef.count || 1);
              logMessage(`Has fabricado ${recipeDef.count || 1} ${resultItemDef.name}.`, 'success');
              AudioManager.playSound('craft', 0.6);
              if(!added) showNotification("Inventario lleno, algunos objetos cayeron.", "warning");
         } else { logMessage("Error al crear objeto.", "error"); }

         // Otorgar XP
         if (recipeDef.xpGain?.skill && recipeDef.xpGain?.amount > 0) {
             gainSkillExperience(recipeDef.xpGain.skill, recipeDef.xpGain.amount);
         }

         // Actualizar UI (inventario ya se actualiza en remove/add)
         updateCraftingUI(); // Re-evaluará y actualizará detalles/botones
     }

     function showRecipeTooltip(recipeDef, event) {
         const tooltip = domCache['recipe-tooltip']; if (!tooltip || !recipeDef) return;
         const resultItemDef = itemDefinitions[recipeDef.result];
         const check = canCraftRecipe(recipeDef);

         let content = `<div class="tooltip-section"><span class="name-tooltip recipe-name-tooltip">${recipeDef.name || `Fabricar ${resultItemDef?.name || 'Objeto'}`}</span>`;
         if(resultItemDef) content += `<span class="recipe-result-tooltip">Resultado: ${resultItemDef.name} x${recipeDef.count || 1}</span>`;
         content += `</div>`;

         if (recipeDef.materials && recipeDef.materials.length > 0) {
             content += `<div class="tooltip-section"><span class="stats-tooltip">Materiales:</span><div class="recipe-mats-tooltip">`;
             recipeDef.materials.forEach(mat => {
                 const hasMat = check.materialsAvailable[mat.id];
                 const currentCount = countItemsInInventory(mat.id);
                 content += `<span class="${hasMat ? 'has-mats' : 'no-mats'}" title="Tienes ${currentCount}">${getItemName(mat.id)} x${mat.count}</span>`;
             });
             content += `</div></div>`;
         }

         if (recipeDef.skillReq || recipeDef.requiredStation || recipeDef.classRequirement) {
              content += `<div class="tooltip-section">`;
               if (recipeDef.skillReq) {
                   const skillMet = check.skillMet;
                   content += `<span class="recipe-skill-tooltip ${skillMet ? 'req-met' : 'req-not-met'}">Req: ${skillDefinitions[recipeDef.skillReq.skill]?.name || '?'} Nivel ${recipeDef.skillReq.level}</span><br>`;
               }
               if (recipeDef.requiredStation) {
                   const stationMet = check.stationOk;
                   content += `<span class="recipe-skill-tooltip ${stationMet ? 'req-met' : 'req-not-met'}">Req: ${getStationName(recipeDef.requiredStation)}</span><br>`;
               }
                if (recipeDef.classRequirement) {
                    const classMet = recipeDef.classRequirement.includes(playerState.class);
                     content += `<span class="recipe-skill-tooltip ${classMet ? 'req-met' : 'req-not-met'}">Req: Clase ${recipeDef.classRequirement.join('/')}</span><br>`;
                }
              content += `</div>`;
         }

         tooltip.innerHTML = content; positionTooltip(tooltip, event); tooltip.style.display = 'block'; gameState.activeTooltip = tooltip;
     }

    /** Cierra todos los paneles modales/UI principales abiertos */
    function closeOtherModals() {
        if (gameState.isCharacterSheetOpen) toggleCharacterSheet(); // Usa toggle para cerrar
        if (gameState.isShopOpen) closeShop();
        if (gameState.isInDialog) closeDialog();
        if (gameState.isOptionsMenuOpen) closeOptionsMenu();
        if (gameState.isLargeMapOpen) closeLargeMap();
        if (gameState.isEquipmentModalOpen) closeEquipmentModal();
        if (gameState.isCraftingModalOpen) closeCraftingModal();
        if (gameState.isQuestsModalOpen) closeQuestsModal();
        if (gameState.isSkillsModalOpen) closeSkillsModal();
        // --- AÑADIR ESTA LÍNEA ---
        if (currentDropItemId !== null) hideDropQuantityPrompt(); // Cierra el prompt si está abierto
        // --------------------------
        hideTooltip(); // Siempre ocultar tooltip al cambiar de modal
    }
function openEquipmentModal() {
        console.log("Intentando abrir Modal Equipo...");
        if (gameState.isEquipmentModalOpen || gameState.isGhost) return;
        closeOtherModals(); // Cerrar otros paneles/modales primero
        const modal = domCache['equipment-modal'];
        if (modal instanceof HTMLElement) {
            updateEquipmentUI(); // Actualizar slots ANTES de mostrar
            modal.style.display = 'flex';
            gameState.isEquipmentModalOpen = true;
            AudioManager.playSound('ui_open', 0.4);
            console.log("Modal de Equipo abierto.");
        } else { console.error("Error al abrir modal de equipo: #equipment-modal no encontrado."); }
    }

    function closeEquipmentModal() {
        if (!gameState.isEquipmentModalOpen) return;
        const modal = domCache['equipment-modal'];
        if (modal instanceof HTMLElement) {
            modal.style.display = 'none';
            gameState.isEquipmentModalOpen = false;
            AudioManager.playSound('ui_close', 0.4);
            hideTooltip(); // Ocultar tooltip de item si estaba abierto
            console.log("Modal de Equipo cerrado.");
        }
    }

    // --- Fabricación ---
function openCraftingModal(specificStationType = null, filteredRecipeIds = null) { // Firma modificada
    console.log(`Intentando abrir Modal Fabricación (Estación: ${specificStationType || 'Ninguna'})...`);
    if (gameState.isCraftingModalOpen || gameState.isGhost) return;
    closeOtherModals();
    const modal = domCache['crafting-modal'];
    if (modal instanceof HTMLElement) {
        // *** PASAR ARGUMENTOS a updateCraftingUI ***
        updateCraftingUI(specificStationType, filteredRecipeIds); // Actualizar recetas ANTES

        // Ajustar Título
        const modalTitle = domCache['modal-crafting-modal-craftingTitle'] || modal.querySelector('.modal-title'); // Buscar título
        if (modalTitle instanceof HTMLElement) {
             modalTitle.textContent = specificStationType ? getStationName(specificStationType) : 'Fabricación';
        }

        modal.style.display = 'flex';
        gameState.isCraftingModalOpen = true;
        AudioManager.playSound('ui_open', 0.4);
        console.log(`Modal de Fabricación abierto para ${specificStationType || 'todas las recetas'}.`);
    } else { console.error("Error al abrir modal de fabricación: #crafting-modal no encontrado."); }
}


    function closeCraftingModal() {
        if (!gameState.isCraftingModalOpen) return;
        const modal = domCache['crafting-modal'];
        if (modal instanceof HTMLElement) {
            modal.style.display = 'none';
            gameState.isCraftingModalOpen = false;
            AudioManager.playSound('ui_close', 0.4);
            hideTooltip(); // Ocultar tooltip de receta
            console.log("Modal de Fabricación cerrado.");
        }
    }

    // --- Misiones ---
    function openQuestsModal() {
        console.log("Intentando abrir Modal Misiones...");
        if (gameState.isQuestsModalOpen || gameState.isGhost) return;
        closeOtherModals();
        const modal = domCache['quests-modal'];
        if (modal instanceof HTMLElement) {
            updateQuestLog(); // Actualizar log ANTES
            modal.style.display = 'flex';
            gameState.isQuestsModalOpen = true;
            AudioManager.playSound('ui_open', 0.4);
            console.log("Modal de Misiones abierto.");
        } else { console.error("Error al abrir modal de misiones: #quests-modal no encontrado."); }
    }

    function closeQuestsModal() {
        if (!gameState.isQuestsModalOpen) return;
        const modal = domCache['quests-modal'];
        if (modal instanceof HTMLElement) {
            modal.style.display = 'none';
            gameState.isQuestsModalOpen = false;
            AudioManager.playSound('ui_close', 0.4);
            console.log("Modal de Misiones cerrado.");
        }
    }

    // --- Habilidades ---
    function openSkillsModal() {
        console.log("Intentando abrir Modal Habilidades...");
        if (gameState.isSkillsModalOpen || gameState.isGhost) return;
        closeOtherModals();
        const modal = domCache['skills-modal'];
        if (modal instanceof HTMLElement) {
            updateSkillsUI(); // Actualizar skills ANTES
            modal.style.display = 'flex';
            gameState.isSkillsModalOpen = true;
            AudioManager.playSound('ui_open', 0.4);
            console.log("Modal de Habilidades abierto.");
        } else { console.error("Error al abrir modal de habilidades: #skills-modal no encontrado."); }
    }

    function closeSkillsModal() {
        if (!gameState.isSkillsModalOpen) return;
        const modal = domCache['skills-modal'];
        if (modal instanceof HTMLElement) {
            modal.style.display = 'none';
            gameState.isSkillsModalOpen = false;
            AudioManager.playSound('ui_close', 0.4);
            hideTooltip(); // Ocultar tooltip de skill
            console.log("Modal de Habilidades cerrado.");
        }
    }

    //==================================================
    // FUNCTION: openOptionsMenu (MODIFICADA)
    //==================================================
    function openOptionsMenu() {
        if (gameState.isOptionsMenuOpen) return;
        const optionsPanel = domCache['options-panel'];
        if (!(optionsPanel instanceof HTMLElement)) { console.error("Panel de opciones no encontrado."); return; }
        console.log("Abriendo menú de opciones...");
        closeOtherModals(); // Cerrar otros modales primero
        gameState.isOptionsMenuOpen = true;

        // Cargar valores ACTUALES en los sliders
        try {
            // Volumen (existente)
            const setupVolume = (type) => { const slider = domCache[`volume-${type}`]; const valEl = domCache[`volume-${type}-value`]; if(slider instanceof HTMLInputElement) slider.value = (AudioManager[`${type}Volume`] * 100).toString(); if(valEl instanceof HTMLElement) valEl.textContent = `${Math.round(AudioManager[`${type}Volume`]*100)}%`; };
            setupVolume('master'); setupVolume('sfx'); setupVolume('music'); setupVolume('weather');

            // Rendimiento (existente)
            const fpsCheck = domCache['option-show-fps']; if(fpsCheck instanceof HTMLInputElement) fpsCheck.checked = showFPS;
            const shadowSelect = domCache['option-shadow-quality']; if (shadowSelect instanceof HTMLSelectElement) shadowSelect.value = shadowQuality;
            const particleSelect = domCache['option-particle-limit']; if(particleSelect instanceof HTMLSelectElement) particleSelect.value = particleLimit.toString();
            const weatherCheck = domCache['option-weather-effects']; if (weatherCheck instanceof HTMLInputElement) weatherCheck.checked = weatherEffectsEnabled;
            const ratioSlider = domCache['option-pixel-ratio']; if(ratioSlider instanceof HTMLInputElement) ratioSlider.value = (renderPixelRatio * 100).toString(); updateVisualSliderValueText('pixel-ratio');

            // *** NUEVO: Visuales/Iluminación ***
            const brightnessSlider = domCache['option-brightness']; if (brightnessSlider instanceof HTMLInputElement) brightnessSlider.value = (gameBrightness * 100).toString(); updateVisualSliderValueText('brightness');
            const lightingSlider = domCache['option-lighting-intensity']; if (lightingSlider instanceof HTMLInputElement) lightingSlider.value = (lightingIntensityFactor * 100).toString(); updateVisualSliderValueText('lighting-intensity');
            // *** --- ***

        } catch(e) { console.error("Error al inicializar valores en opciones:", e); }

        optionsPanel.style.display = 'flex';
        AudioManager.playSound('ui_open', 0.4);
        // Pausar el juego si no está pausado ya (o manejarlo según prefieras)
        // if (gameState.isPlaying && !gameState.isPaused) pauseGame();
    }

    //===========================================
    // === NUEVAS Funciones Handler y Helper ===
    //===========================================

    /**
     * Helper para actualizar el texto de un slider de opciones visuales.
     * @param {'brightness' | 'lighting-intensity' | 'pixel-ratio'} type - El tipo de slider.
     */
    function updateVisualSliderValueText(type) {
        const slider = domCache[`option-${type}`];
        const valueDisplay = domCache[`option-${type}-value`];
        if (slider instanceof HTMLInputElement && valueDisplay instanceof HTMLElement) {
            valueDisplay.textContent = `${slider.value}%`;
        }
    }

function handleBrightnessChange(event) {
    const slider = event.target;
    if (!(slider instanceof HTMLInputElement) || !renderer) return;

    const valuePercent = parseInt(slider.value, 10);
    gameBrightness = valuePercent / 100;
    gameBrightness = Math.max(0.5, Math.min(1.5, gameBrightness));

    renderer.toneMappingExposure = gameBrightness;

    updateVisualSliderValueText('brightness');
    localStorage.setItem('option_brightness', gameBrightness.toString());
    console.log("Brightness (Exposure) changed to:", gameBrightness);
}


function handleLightingIntensityChange(event) {
    const slider = event.target;
    if (!(slider instanceof HTMLInputElement) || !scene) return;

    const valuePercent = parseInt(slider.value, 10);
    lightingIntensityFactor = valuePercent / 100;
    lightingIntensityFactor = Math.max(0.0, Math.min(1.5, lightingIntensityFactor));

    applyLightingIntensityFactor();

    updateVisualSliderValueText('lighting-intensity');
    localStorage.setItem('option_lightingIntensity', lightingIntensityFactor.toString());
    console.log("Lighting Intensity Factor changed to:", lightingIntensityFactor);
}


    /**
     * Aplica el `lightingIntensityFactor` actual a las luces principales de la escena.
     */
    function applyLightingIntensityFactor() {
        if (!scene) return;
        let lightsAdjusted = 0;
        scene.traverse(obj => {
            if (obj.isLight && obj.userData?.baseIntensity !== undefined) {
                const baseIntensity = obj.userData.baseIntensity;
                obj.intensity = baseIntensity * lightingIntensityFactor;
                lightsAdjusted++;
            }
        });
        // console.log(`Applied intensity factor ${lightingIntensityFactor.toFixed(2)} to ${lightsAdjusted} lights.`); // DEBUG
    }
    function closeOptionsMenu() {
        if (!gameState.isOptionsMenuOpen) return;
        const optionsPanel = domCache['options-panel'];
        if (optionsPanel instanceof HTMLElement) optionsPanel.style.display = 'none';
        console.log("Cerrando menú de opciones.");
        gameState.isOptionsMenuOpen = false;
        AudioManager.playSound('ui_close', 0.4);
        // Si abrir opciones pausó el juego, ¿reanudar? Mejor dejar que pauseGame() lo maneje.
        // if (gameState.isPaused) resumeGame();
    }

    function updateSliderValueText(volumeType) {
        const slider = domCache[`volume-${volumeType}`];
        const valueDisplay = domCache[`volume-${volumeType}-value`];
        if (slider instanceof HTMLInputElement && valueDisplay instanceof HTMLElement) {
            valueDisplay.textContent = `${slider.value}%`;
        }
    }

// --- Define estas funciones globalmente o dentro de un objeto MapManager ---

/**
 * Callback para evento mousedown/touchstart en el contenedor del mapa grande.
 * Inicia el proceso de paneo.
 * @param {MouseEvent | TouchEvent} event
 */
function onMapMouseDown(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!gameState.isLargeMapOpen) return;

    gameState.largeMapIsPanning = true;
    const pos = event.touches ? event.touches[0] : event;
    gameState.largeMapLastPanX = pos.clientX;
    gameState.largeMapLastPanY = pos.clientY;

    const container = domCache['large-map-canvas-container'];
    if (container) container.style.cursor = 'grabbing';
    // console.log("Map Pan Start"); // DEBUG
}

/**
 * Callback para evento mousemove/touchmove en el contenedor del mapa grande.
 * Actualiza el offset del mapa si se está paneando.
 * @param {MouseEvent | TouchEvent} event
 */
function onMapMouseMove(event) {
    if (!gameState.isLargeMapOpen || !gameState.largeMapIsPanning) return;
    event.preventDefault();
    event.stopPropagation();

    const pos = event.touches ? event.touches[0] : event;
    const currentX = pos.clientX;
    const currentY = pos.clientY;

    const deltaX = currentX - gameState.largeMapLastPanX;
    const deltaY = currentY - gameState.largeMapLastPanY;

    // El offset se acumula directamente en píxeles del canvas
    gameState.largeMapOffsetX += deltaX;
    gameState.largeMapOffsetY += deltaY;

    // Limitar offset para que no se vaya demasiado lejos (opcional)
    // const limit = canvas.width * (gameState.largeMapZoom + 1); // Ejemplo
    // gameState.largeMapOffsetX = Math.max(-limit, Math.min(limit, gameState.largeMapOffsetX));
    // gameState.largeMapOffsetY = Math.max(-limit, Math.min(limit, gameState.largeMapOffsetY));

    gameState.largeMapLastPanX = currentX;
    gameState.largeMapLastPanY = currentY;

    // Redibujar el mapa con el nuevo offset
requestLargeMapDraw(); // <-- USAR ESTA
    }

/**
 * Callback para evento mouseup/touchend/mouseleave/touchcancel en el contenedor del mapa grande.
 * Finaliza el proceso de paneo.
 * @param {MouseEvent | TouchEvent} event
 */
function onMapMouseUp(event) {
    if (!gameState.isLargeMapOpen || !gameState.largeMapIsPanning) return;
    // event.preventDefault(); // No siempre necesario aquí
    // event.stopPropagation();

    gameState.largeMapIsPanning = false;
    const container = domCache['large-map-canvas-container'];
    if (container) container.style.cursor = 'grab';
    // console.log("Map Pan End"); // DEBUG
}

/**
 * Callback para evento wheel en el contenedor del mapa grande.
 * Ajusta el nivel de zoom y el offset para mantener el punto bajo el cursor.
 * @param {WheelEvent} event
 */
function onMapWheel(event) {
    if (!gameState.isLargeMapOpen) return;
    event.preventDefault();
    event.stopPropagation();

    const zoomSensitivity = 0.001;
    const delta = -event.deltaY * zoomSensitivity; // Invertir deltaY para zoom intuitivo

    const mapContainer = domCache['large-map-canvas-container'];
    const mapCanvas = domCache['large-map-canvas'];
    if (!mapContainer || !mapCanvas) return;

    const rect = mapContainer.getBoundingClientRect();
    // Posición del ratón relativa al CONTENEDOR del canvas
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    // Centro del canvas
    const centerX = mapCanvas.width / 2;
    const centerY = mapCanvas.height / 2;

    // --- Calcular posición en el mundo bajo el cursor ANTES del zoom ---
    const scaleBefore = mapCanvas.width / (300 * 2 * gameState.largeMapZoom); // Ajustar radio base (300)
    // Coordenadas relativas al centro del canvas, ajustadas por el offset actual
    const mouseRelXBefore = mouseX - centerX - gameState.largeMapOffsetX;
    const mouseRelYBefore = mouseY - centerY - gameState.largeMapOffsetY;
    // Coordenadas del mundo bajo el cursor
    const worldXBefore = playerState.position.x + mouseRelXBefore / scaleBefore;
    const worldZBefore = playerState.position.z + mouseRelYBefore / scaleBefore;

    // --- Aplicar y Limitar Zoom ---
    const oldZoom = gameState.largeMapZoom;
    let newZoom = oldZoom * Math.exp(delta); // Zoom exponencial para suavidad
    newZoom = Math.max(gameState.largeMapMinZoom, Math.min(gameState.largeMapMaxZoom, newZoom));
    gameState.largeMapZoom = newZoom;

    // --- Calcular dónde estaría el punto del mundo DESPUÉS del zoom (sin ajustar offset) ---
    const scaleAfter = mapCanvas.width / (300 * 2 * gameState.largeMapZoom);
    const screenXAfter = centerX + (worldXBefore - playerState.position.x) * scaleAfter;
    const screenYAfter = centerY + (worldZBefore - playerState.position.z) * scaleAfter;

    // --- Calcular diferencia y ajustar offset ---
    // Queremos que (screenXAfter + newOffsetX) == mouseX
    const requiredOffsetX = mouseX - screenXAfter;
    const requiredOffsetY = mouseY - screenYAfter;
    gameState.largeMapOffsetX = requiredOffsetX;
    gameState.largeMapOffsetY = requiredOffsetY;

    // Redibujar
requestLargeMapDraw(); // <-- USAR ESTA
}

/**
 * Añade los listeners de interacción al contenedor del mapa grande.
 * Guarda las referencias a los listeners para poder eliminarlos después.
 */
function setupLargeMapInteraction() {
    const container = domCache['large-map-canvas-container'];
    if (!container) {
        console.error("setupLargeMapInteraction: Contenedor del mapa no encontrado.");
        return;
    }
    // Limpiar listeners previos por si acaso
    removeLargeMapInteractionListeners();

    // Guardar referencias en el propio elemento para fácil acceso al limpiar
    container._onMapMouseDown = onMapMouseDown;
    container._onMapMouseMove = onMapMouseMove;
    container._onMapMouseUp = onMapMouseUp;
    container._onMapWheel = onMapWheel;
    container._onMapTouchStart = onMapMouseDown; // Reutilizar para touch
    container._onMapTouchMove = onMapMouseMove;
    container._onMapTouchEnd = onMapMouseUp;
    container._onMapMouseLeave = onMapMouseUp; // Terminar paneo si sale
    container._onMapTouchCancel = onMapMouseUp; // Terminar paneo si se cancela

    // Añadir listeners
    container.addEventListener('mousedown', container._onMapMouseDown);
    container.addEventListener('mousemove', container._onMapMouseMove);
    container.addEventListener('mouseup', container._onMapMouseUp);
    container.addEventListener('mouseleave', container._onMapMouseLeave);
    container.addEventListener('wheel', container._onMapWheel, { passive: false }); // passive: false para preventDefault
    container.addEventListener('touchstart', container._onMapTouchStart, { passive: false });
    container.addEventListener('touchmove', container._onMapTouchMove, { passive: false });
    container.addEventListener('touchend', container._onMapTouchEnd);
    container.addEventListener('touchcancel', container._onMapTouchCancel);

    container.style.cursor = 'grab'; // Cursor inicial
    console.log("Listeners del mapa grande añadidos.");
}

/**
 * Elimina los listeners de interacción del contenedor del mapa grande.
 */
function removeLargeMapInteractionListeners() {
    const container = domCache['large-map-canvas-container'];
    if (!container) return;

    // Eliminar usando las referencias guardadas
    if (container._onMapMouseDown) container.removeEventListener('mousedown', container._onMapMouseDown);
    if (container._onMapMouseMove) container.removeEventListener('mousemove', container._onMapMouseMove);
    if (container._onMapMouseUp) container.removeEventListener('mouseup', container._onMapMouseUp);
    if (container._onMapMouseLeave) container.removeEventListener('mouseleave', container._onMapMouseLeave);
    if (container._onMapWheel) container.removeEventListener('wheel', container._onMapWheel);
    if (container._onMapTouchStart) container.removeEventListener('touchstart', container._onMapTouchStart);
    if (container._onMapTouchMove) container.removeEventListener('touchmove', container._onMapTouchMove);
    if (container._onMapTouchEnd) container.removeEventListener('touchend', container._onMapTouchEnd);
    if (container._onMapTouchCancel) container.removeEventListener('touchcancel', container._onMapTouchCancel);

    // Limpiar referencias guardadas
    container._onMapMouseDown = null; container._onMapMouseMove = null; container._onMapMouseUp = null;
    container._onMapMouseLeave = null; container._onMapWheel = null; container._onMapTouchStart = null;
    container._onMapTouchMove = null; container._onMapTouchEnd = null; container._onMapTouchCancel = null;

    container.style.cursor = 'default'; // Restaurar cursor
    console.log("Listeners del mapa grande eliminados.");
}

    // --- Mapa Grande ---
    function openLargeMap() {
        if (gameState.isLargeMapOpen || gameState.isGhost) return;
        const mapPanel = domCache['large-map-panel']; const mapCanvas = domCache['large-map-canvas'];
        const mapContainer = domCache['large-map-canvas-container'];
        if (!(mapPanel && mapCanvas && mapContainer)) { console.error("openLargeMap: Faltan elementos HTML."); return; }
        console.log("Abriendo mapa grande...");
        closeOtherModals();
        setupLargeMapInteraction();
        gameState.isLargeMapOpen = true;
        mapPanel.style.display = 'flex'; AudioManager.playSound('ui_open', 0.35);
        requestAnimationFrame(() => { // Esperar a que se muestre para obtener tamaño
            if (!gameState.isLargeMapOpen) return;
            const contW = mapContainer.clientWidth; const contH = mapContainer.clientHeight;
            if (contW <= 0 || contH <= 0) { console.error("Contenedor mapa grande sin dimensiones."); closeLargeMap(); return; }
            const cSize = Math.min(contW, contH);
            if (mapCanvas.width !== cSize || mapCanvas.height !== cSize) { mapCanvas.width = cSize; mapCanvas.height = cSize; }
            try { drawLargeMap(); } catch(drawError) { console.error("Error dibujando mapa grande:", drawError); closeLargeMap(); }
        });
        // TODO: Añadir listeners pan/zoom
        
    }

    function closeLargeMap() {
        if (!gameState.isLargeMapOpen) return;
        const mapPanel = domCache['large-map-panel'];
        if (mapPanel instanceof HTMLElement) mapPanel.style.display = 'none';
        console.log("Cerrando mapa grande.");
        gameState.isLargeMapOpen = false;
        gameState.largeMapOffsetX = 0;
        gameState.largeMapOffsetY = 0;
        gameState.largeMapZoom = 1.0;
        gameState.largeMapIsPanning = false;
        AudioManager.playSound('ui_close', 0.35);
        // TODO: Remover listeners pan/zoom
    }




/**
 * Maneja la interacción con una estación de crafteo.
 * Abre el modal de fabricación, mostrando solo las recetas que requieren esa estación.
 * @param {THREE.Object3D} stationObject - El objeto 3D de la estación con la que se interactuó.
 */
function interactWithCraftingStation(stationObject) {
    // 1. Validar Objeto y Datos
    if (!stationObject?.userData || stationObject.userData.type !== 'crafting_station' || !stationObject.userData.stationType) {
        console.error("interactWithCraftingStation: Objeto inválido o sin stationType.");
        logMessage("Error: Estación de fabricación inválida.", "error");
        return;
    }
    if (gameState.isGhost) {
         logMessage("Los fantasmas no pueden fabricar.", "info");
         return;
    }

    const stationType = stationObject.userData.stationType;
    const stationName = getStationName(stationType); // Obtener nombre legible

    console.log(`Interactuando con estación: ${stationName} (Tipo: ${stationType})`);

    // 2. Filtrar Recetas Conocidas
    const knownRecipes = playerState.knownRecipes || [];
    // *** FILTRO CORREGIDO: Solo recetas que USAN esta estación ***
    const availableRecipesForStation = knownRecipes.filter(recipeId => {
        const recipeDef = recipeDefinitions[recipeId];
        // Incluir SOLO si requiere ESTA estación específica
        return recipeDef && recipeDef.requiredStation === stationType;
    });

    console.log(`Recetas disponibles para esta estación (${availableRecipesForStation.length}):`, availableRecipesForStation);

    // 3. Llamar a la función para abrir el modal con las recetas filtradas
    openCraftingModal(stationType, availableRecipesForStation); // Pasar tipo y recetas filtradas
}

    /**
     * Solicita un redibujado del mapa grande, asegurándose de no encolar múltiples peticiones.
     */
    function requestLargeMapDraw() {
        if (!isLargeMapDrawPending) {
            isLargeMapDrawPending = true;
            requestAnimationFrame(() => {
                drawLargeMap(); // Ejecuta el dibujo
                isLargeMapDrawPending = false; // Marca como completado
            });
        }
    }


    /**
     * Dibuja el mapa grande en su canvas, considerando el zoom y el paneo.
     * Utiliza un caché de fondo para optimizar el rendimiento.
     * Muestra el terreno, carreteras, jugador, ciudades, POIs y objetivos de misión.
     * (v3.6 - Revisado y comprobado)
     */
    function drawLargeMap() {
        // --- 1. Validaciones Iniciales y Clear ---
        const ctx = domCache.largeMapCtx;
        const canvas = domCache['large-map-canvas'];
        const coordsDisplay = domCache['large-map-player-coords'];

        if (!ctx || !(canvas instanceof HTMLCanvasElement) || canvas.width <= 0 || ctx.isDummyContext) {
            if (!drawLargeMap.warnedCanvas) { console.error("drawLargeMap v3.6: Contexto o Canvas inválido."); drawLargeMap.warnedCanvas = true; }
            return;
        }
        drawLargeMap.warnedCanvas = false;
        if (!worldData || !worldData.biomeColors || typeof worldData.getBiomeName !== 'function') {
            console.error("drawLargeMap v3.6: worldData o biomeColors no listos.");
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }
        if (!playerState?.position || typeof playerState.rotationY !== 'number' || !quests?.active) {
            // console.warn("drawLargeMap v3.6: playerState o quests.active no listos.");
            ctx.fillStyle = '#050508'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            return;
        }

        // *** ¡LIMPIAR CANVAS ANTES DE DIBUJAR! ***
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- 2. Obtener Estado y Calcular Parámetros ---
        const canvasSize = canvas.width;
        const currentZoom = gameState.largeMapZoom || 1.0;
        const mapOffsetX = gameState.largeMapOffsetX || 0;
        const mapOffsetY = gameState.largeMapOffsetY || 0;
        const playerWorldX = playerState.position.x;
        const playerWorldZ = playerState.position.z;
        const playerAngle = playerState.rotationY;

        const BASE_MAP_WORLD_RADIUS = 300;
        const effectiveWorldRadius = BASE_MAP_WORLD_RADIUS / currentZoom;
        const scale = canvasSize / (effectiveWorldRadius * 2);
        const centerX = canvasSize / 2;
        const centerY = canvasSize / 2;
        const viewWorldCenterX = playerWorldX - mapOffsetX / scale;
        const viewWorldCenterZ = playerWorldZ - mapOffsetY / scale;

        if (coordsDisplay instanceof HTMLElement) {
            coordsDisplay.textContent = `X: ${playerWorldX.toFixed(0)}, Z: ${playerWorldZ.toFixed(0)} (Zoom: ${currentZoom.toFixed(1)}x)`;
        }

        // --- 3. Declaración de defaultColor y biomeColors ---
        const biomeColors = worldData.biomeColors;
        const defaultColor = new THREE.Color(biomeColors.grassland || 0xff00ff);
        if (!biomeColors.grassland) console.warn("drawLargeMap: biomeColors.grassland no definido, usando fallback magenta.");

        // --- 4. Actualizar Caché de Fondo si es Necesario ---
        const cacheWorldRadius = effectiveWorldRadius * LARGE_MAP_CACHE_SIZE_FACTOR;
        const desiredCachePixelSize = Math.max(128, Math.round(canvasSize * LARGE_MAP_CACHE_SIZE_FACTOR));
        const cacheScale = desiredCachePixelSize / (cacheWorldRadius * 2);
        const distSqFromCacheCenter = (viewWorldCenterX - lastLargeMapCacheCenter.x)**2 + (viewWorldCenterZ - lastLargeMapCacheCenter.z)**2;
        const zoomDiff = Math.abs(currentZoom - lastLargeMapCacheZoom);
        const needsCacheUpdate = !largeMapBgCache || largeMapBgCache.width !== desiredCachePixelSize || largeMapBgCache.height !== desiredCachePixelSize || distSqFromCacheCenter > LARGE_MAP_CACHE_UPDATE_THRESHOLD**2 || zoomDiff > LARGE_MAP_ZOOM_UPDATE_THRESHOLD;

        if (needsCacheUpdate) {
            if (!largeMapBgCache || largeMapBgCache.width !== desiredCachePixelSize || largeMapBgCache.height !== desiredCachePixelSize) {
                largeMapBgCache = document.createElement('canvas');
                if (!(largeMapBgCache instanceof HTMLCanvasElement)) { largeMapBgCache = null; }
                else { largeMapBgCache.width = desiredCachePixelSize; largeMapBgCache.height = desiredCachePixelSize; }
            }
            let bgCtx = null; if (largeMapBgCache) bgCtx = largeMapBgCache.getContext('2d', { alpha: false });
            if (bgCtx) {
                console.log(`[LargeMap Cache] Updating Cache... Size: ${desiredCachePixelSize}, Zoom: ${currentZoom.toFixed(2)}`);
                lastLargeMapCacheCenter.x = viewWorldCenterX; lastLargeMapCacheCenter.z = viewWorldCenterZ; lastLargeMapCacheZoom = currentZoom;
                bgCtx.fillStyle = '#08080F'; bgCtx.fillRect(0, 0, desiredCachePixelSize, desiredCachePixelSize);
                const cacheCenterXPixels = desiredCachePixelSize / 2; const cacheCenterYPixels = desiredCachePixelSize / 2;
                const sampleStepCache = Math.max(1, Math.floor(2 / currentZoom));
                // Dibujar Terreno
                for (let py = 0; py < desiredCachePixelSize; py += sampleStepCache) {
                    for (let px = 0; px < desiredCachePixelSize; px += sampleStepCache) {
                        const worldX = lastLargeMapCacheCenter.x + (px + sampleStepCache/2 - cacheCenterXPixels) / cacheScale;
                        const worldZ = lastLargeMapCacheCenter.z + (py + sampleStepCache/2 - cacheCenterYPixels) / cacheScale;
                        const { height, biomeId } = ChunkManager._getFinalTerrainHeightAndBiome(worldX, worldZ);
                        const biomeName = worldData.getBiomeName(biomeId);
                        let cellColor = defaultColor.clone();
                        if (biomeId === worldData.getBiomeId('water')) { cellColor.setHex(biomeColors.water || 0x2a5e8f); }
                        else { cellColor.setHex(biomeColors[biomeName] || biomeColors.grassland || 0xff00ff); const snowLine = BIOME_PARAMS.heightMountain * 1.05; if (height > snowLine && biomeColors.snow) { cellColor.lerp(new THREE.Color(biomeColors.snow), 0.85); } else if (height < WATER_LEVEL + 1.2 && biomeId !== worldData.getBiomeId('beach') && biomeColors.water_shallow) { cellColor.lerp(new THREE.Color(biomeColors.water_shallow), 0.7); } }
                        const roadInf = getRoadInfluence(worldX, worldZ); if (roadInf > 0 && biomeColors.road) { cellColor.lerp(new THREE.Color(biomeColors.road), roadInf * 0.85); }
                        bgCtx.fillStyle = cellColor.getStyle();
                        bgCtx.fillRect(px, py, sampleStepCache, sampleStepCache);
                    }
                }
                // Dibujar Carreteras
                bgCtx.strokeStyle = '#a96'; bgCtx.lineWidth = Math.max(1, 2.5 * currentZoom); bgCtx.lineCap = 'round';
                (worldData.mainRoads || []).forEach(road => {
                    if (!road.points || road.points.length < 2) return; bgCtx.beginPath();
                    for (let i = 0; i < road.points.length; i++) { const p = road.points[i]; const scx = cacheCenterXPixels + (p.x - lastLargeMapCacheCenter.x) * cacheScale; const scy = cacheCenterYPixels + (p.z - lastLargeMapCacheCenter.z) * cacheScale; if (i === 0) bgCtx.moveTo(scx, scy); else bgCtx.lineTo(scx, scy); }
                    bgCtx.stroke();
                });
                console.log("[LargeMap Cache] Cache updated drawing finished.");
            } else { largeMapBgCache = null; }
        }

        // --- 5. Dibujar el Caché en el Canvas Visible ---
        if (largeMapBgCache) {
            const cacheDrawOffsetX = (lastLargeMapCacheCenter.x - viewWorldCenterX) * scale;
            const cacheDrawOffsetY = (lastLargeMapCacheCenter.z - viewWorldCenterZ) * scale;
            const sourceX = (largeMapBgCache.width / 2) - (canvasSize / 2) * (cacheScale / scale);
            const sourceY = (largeMapBgCache.height / 2) - (canvasSize / 2) * (cacheScale / scale);
            const sourceWidth = canvasSize * (cacheScale / scale);
            const sourceHeight = canvasSize * (cacheScale / scale);
            const drawPosX = cacheDrawOffsetX; // Dibuja desde el offset relativo al centro
            const drawPosY = cacheDrawOffsetY;
            try {
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(largeMapBgCache, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, canvasSize, canvasSize);
            } catch (e) { console.error("Error drawImage largeMapBgCache:", e, { sourceX, sourceY, sourceWidth, sourceHeight }); ctx.fillStyle = '#CC0000'; ctx.fillRect(0, 0, canvasSize, canvasSize); }
        } else { ctx.fillStyle = '#303035'; ctx.fillRect(0, 0, canvasSize, canvasSize); }

        // --- 6. Dibujar Marcadores Dinámicos ---
        ctx.textAlign = 'center';
        const baseIconSize = 8; const baseFontSize = 10;
        // Ciudades (Usan viewWorldCenterX/Z)
        const cityIconSize = Math.max(4, baseIconSize * currentZoom);
        const cityFontSize = Math.max(6, baseFontSize * currentZoom);
        ctx.font = `bold ${cityFontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-secondary')}`;
        ctx.textBaseline = 'bottom';
        (worldData.cities || []).forEach(city => {
            const sx = centerX + (city.center.x - viewWorldCenterX) * scale;
            const sy = centerY + (city.center.z - viewWorldCenterZ) * scale;
            if (sx >= -cityIconSize && sx < canvasSize + cityIconSize && sy >= -cityIconSize && sy < canvasSize + cityIconSize) {
                ctx.fillStyle = '#DDDDDD'; ctx.fillRect(sx - cityIconSize / 2, sy - cityIconSize / 2, cityIconSize, cityIconSize);
                ctx.fillStyle = '#FFFFFF'; ctx.fillText(city.name, sx, sy - cityIconSize * 0.7);
            }
        });
        // POIs (Usan viewWorldCenterX/Z)
        const poiIconSize = Math.max(5, baseIconSize * 1.2 * currentZoom);
        const poiFontSize = Math.max(5, baseFontSize * 0.8 * currentZoom);
        ctx.font = `${poiFontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-secondary')}`;
        ctx.textBaseline = 'top';
        (worldData.specialLocations || []).forEach(loc => {
            const sx = centerX + (loc.pos.x - viewWorldCenterX) * scale;
            const sy = centerY + (loc.pos.z - viewWorldCenterZ) * scale;
            if (sx >= -poiIconSize && sx < canvasSize + poiIconSize && sy >= -poiIconSize && sy < canvasSize + poiIconSize) {
                let icon = '?'; let color = '#AAA'; let iconSizeRender = poiIconSize;
                if (loc.type === 'dungeon_entrance') { icon = '⚬'; color = '#FFA500';} else if (loc.type === 'landmark') { icon = '★'; color = '#00FFFF';} else if (loc.type === 'shrine') { icon = '✚'; color = '#00FF00';}
                ctx.fillStyle = color; ctx.font = `bold ${iconSizeRender}px sans-serif`; ctx.textBaseline = 'middle'; ctx.fillText(icon, sx, sy);
                ctx.fillStyle = '#EEEEEE'; ctx.font = `${poiFontSize}px ${getComputedStyle(document.documentElement).getPropertyValue('--font-secondary')}`; ctx.textBaseline = 'top'; ctx.fillText(loc.name, sx, sy + iconSizeRender * 0.6);
            }
        });
        // Quests (Usan viewWorldCenterX/Z)
        const trackedQuestId = playerState.trackedQuestId;
        const trackedQuest = trackedQuestId ? quests.active.find(q => q && q.id === trackedQuestId) : null;
        if (trackedQuest) {
            const questDef = questDefinitions[trackedQuest.id];
            if (questDef?.objectives) {
                 ctx.fillStyle = 'rgba(255, 220, 0, 0.9)'; ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                 ctx.lineWidth = Math.max(0.5, 1 * currentZoom); const questMarkerRadius = Math.max(3, 5 * currentZoom);
                 questDef.objectives.forEach((objDef, index) => {
                     const objState = trackedQuest.objectives?.find(o => o && ((o.id && o.id === objDef.id) || (o.type === objDef.type && o.target === objDef.target))) || trackedQuest.objectives?.[index];
                     if (objState && typeof objState.current === 'number' && objState.current < (objDef.count || 1)) {
                         let targetPos = findQuestObjectivePosition(objDef);
                         if (targetPos) {
                             const sx = centerX + (targetPos.x - viewWorldCenterX) * scale;
                             const sy = centerY + (targetPos.z - viewWorldCenterZ) * scale;
                             if (sx >= -questMarkerRadius && sx < canvasSize + questMarkerRadius && sy >= -questMarkerRadius && sy < canvasSize + questMarkerRadius) {
                                 ctx.beginPath(); ctx.arc(sx, sy, questMarkerRadius, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                             }
                         }
                     }
                 });
            }
        }

        // --- 7. Dibujar Marcador del Jugador (Posición basada en offset) ---
        const playerIconSizeMap = Math.max(5, 8 * currentZoom);
        const playerScreenX = centerX + mapOffsetX; // Posición del jugador EN EL CANVAS
        const playerScreenY = centerY + mapOffsetY;

        ctx.save();
        ctx.translate(playerScreenX, playerScreenY);
        ctx.rotate(playerAngle);
        ctx.fillStyle = gameState.isGhost ? 'rgba(162, 155, 254, 0.9)' : 'rgba(255, 255, 255, 0.95)';
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.lineWidth = Math.max(1, 1.5 * currentZoom);
        ctx.beginPath();
        ctx.moveTo(0, -playerIconSizeMap * 0.8);
        ctx.lineTo(playerIconSizeMap * 0.6, playerIconSizeMap * 0.5);
        ctx.lineTo(-playerIconSizeMap * 0.6, playerIconSizeMap * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // --- 8. Dibujar Borde del Mapa ---
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, canvasSize, canvasSize);
    } // Fin drawLargeMap v3.6
    // Inicializar flag de advertencia
    drawLargeMap.warnedCanvas = false;



// --- Asegúrate que las funciones helper estén definidas ---
// function findQuestObjectivePosition(objectiveDefinition) { ... }
// function getRarityColorVar(rarity = 'common') { ... }

function updatePlayerStats() {
        if (!playerState || !playerState.attributes || !playerState.stats) { console.error("updatePlayerStats: Datos inválidos."); return; }

        const attr = playerState.attributes;
        const baseStats = playerState.stats; // Referencia directa para modificar

        // --- 1. Calcular Stats Base desde Atributos ---
        baseStats.maxHealth = BASE_HEALTH + attr.constitution * HEALTH_PER_CON;
        baseStats.maxMana = BASE_MANA + attr.intelligence * MANA_PER_INT;
        baseStats.maxStamina = BASE_STAMINA + attr.dexterity * STAMINA_PER_DEX;
        baseStats.physDmgMin = 3 + attr.strength * PHYS_DMG_PER_STR.min;
        baseStats.physDmgMax = 6 + attr.strength * PHYS_DMG_PER_STR.max;
        baseStats.magicDmgMin = 2 + attr.intelligence * MAGIC_DMG_PER_INT.min;
        baseStats.magicDmgMax = 4 + attr.intelligence * MAGIC_DMG_PER_INT.max;
        baseStats.defense = attr.constitution * DEF_PER_CON;
        baseStats.magicResist = attr.intelligence * MRES_PER_INT;
        baseStats.hitChance = 70 + attr.dexterity * HIT_CHANCE_PER_DEX;
        baseStats.critChance = 5 + attr.dexterity * CRIT_CHANCE_PER_DEX;
        baseStats.moveSpeed = MOVE_SPEED_BASE;
        baseStats.hpRegen = 0.2 + attr.constitution * 0.05;
        baseStats.mpRegen = 0.5 + attr.intelligence * 0.08;
        baseStats.spRegen = 1.0 + attr.dexterity * 0.1;

        // --- 2. Inicializar Acumuladores de Bonus ---
        let bonusDefense = 0, bonusMagicResist = 0;
        let bonusPhysDmgMin = 0, bonusPhysDmgMax = 0;
        let bonusMagicDmgMin = 0, bonusMagicDmgMax = 0;
        let bonusCritChance = 0, bonusHitChance = 0;
        let bonusMoveSpeed = 0;
        let bonusHpRegen = 0, bonusMpRegen = 0, bonusSpRegen = 0;
        let bonusMaxHealth = 0, bonusMaxMana = 0, bonusMaxStamina = 0;
        let bonusStrength = 0, bonusDexterity = 0, bonusIntelligence = 0, bonusConstitution = 0;
        let manaCostMultiplier = 1.0; let moveSpeedMultiplier = 1.0;

        // --- 3. Aplicar Bonus de Equipo ---
        const equippedItems = getEquippedItems();
        equippedItems.forEach(item => {
            if (item?.stats) {
                const s = item.stats;
                bonusDefense += s.defense || 0; bonusMagicResist += s.magicResist || 0;
                bonusPhysDmgMin += s.physDmgMin || 0; bonusPhysDmgMax += s.physDmgMax || 0;
                bonusMagicDmgMin += s.magicDmgMin || 0; bonusMagicDmgMax += s.magicDmgMax || 0;
                bonusCritChance += s.critChance || 0; bonusHitChance += s.hitChance || 0;
                bonusMoveSpeed += s.moveSpeed || 0;
                bonusHpRegen += s.hpRegen || 0; bonusMpRegen += s.mpRegen || 0; bonusSpRegen += s.spRegen || 0;
                bonusMaxHealth += s.maxHealth || 0; bonusMaxMana += s.maxMana || 0; bonusMaxStamina += s.maxStamina || 0;
                bonusStrength += s.strength || 0; bonusDexterity += s.dexterity || 0;
                bonusIntelligence += s.intelligence || 0; bonusConstitution += s.constitution || 0;
                if (s.moveSpeedMultiplier) moveSpeedMultiplier *= s.moveSpeedMultiplier;
                 if (s.manaCostMultiplier) manaCostMultiplier *= s.manaCostMultiplier;
            }
        });

        // --- 4. Aplicar Bonus de Habilidades ---
        if(playerState.skills) {
            for (const skillId in playerState.skills) {
                const skillData = playerState.skills[skillId]; const skillDef = skillDefinitions[skillId];
                if (skillDef?.bonuses && skillData?.level) {
                    skillDef.bonuses.forEach(bonus => {
                        if (skillData.level >= bonus.level) {
                            let applyBonus = true;
                            // Simplificado: Ignorar filtros complejos por ahora
                            // if (bonus.filter) { applyBonus = false; }
                            if (applyBonus) {
                                 const bonusValue = typeof bonus.value === 'function' ? bonus.value(skillData.level) : bonus.value;
                                 switch (bonus.stat) {
                                     case 'defense': bonusDefense += bonusValue; break;
                                     case 'magicResist': bonusMagicResist += bonusValue; break;
                                     case 'physDmgMin': bonusPhysDmgMin += bonusValue; break;
                                     case 'physDmgMax': bonusPhysDmgMax += bonusValue; break;
                                     case 'magicDmgMin': bonusMagicDmgMin += bonusValue; break;
                                     case 'magicDmgMax': bonusMagicDmgMax += bonusValue; break;
                                     case 'critChance': bonusCritChance += bonusValue; break;
                                     case 'hitChance': bonusHitChance += bonusValue; break;
                                     case 'hpRegen': bonusHpRegen += bonusValue; break;
                                     case 'mpRegen': bonusMpRegen += bonusValue; break;
                                     case 'spRegen': bonusSpRegen += bonusValue; break;
                                     case 'maxHealth': bonusMaxHealth += bonusValue; break;
                                     case 'maxMana': bonusMaxMana += bonusValue; break;
                                     case 'maxStamina': bonusMaxStamina += bonusValue; break;
                                     case 'strength': bonusStrength += bonusValue; break;
                                     case 'dexterity': bonusDexterity += bonusValue; break;
                                     case 'intelligence': bonusIntelligence += bonusValue; break;
                                     case 'constitution': bonusConstitution += bonusValue; break;
                                     case 'manaCostReduction': manaCostMultiplier *= (1 - bonusValue); break; // Multiplicativo para reducción
                                     case 'moveSpeed': bonusMoveSpeed += bonusValue; break;
                                     case 'moveSpeedMultiplier': moveSpeedMultiplier *= bonusValue; break;
                                 }
                            }
                        }
                    });
                }
            }
        }

        // --- 5. Aplicar Modificadores de Efectos de Estado ---
        playerState.statusEffects.forEach(effect => {
            if (effect.statsModifiers) {
                const mods = effect.statsModifiers;
                bonusDefense += mods.defense || 0; bonusMagicResist += mods.magicResist || 0;
                bonusPhysDmgMin += mods.physDmgMin || 0; bonusPhysDmgMax += mods.physDmgMax || 0;
                bonusMagicDmgMin += mods.magicDmgMin || 0; bonusMagicDmgMax += mods.magicDmgMax || 0;
                bonusCritChance += mods.critChance || 0; bonusHitChance += mods.hitChance || 0;
                bonusMoveSpeed += mods.moveSpeed || 0;
                bonusHpRegen += mods.hpRegen || 0; bonusMpRegen += mods.mpRegen || 0; bonusSpRegen += mods.spRegen || 0;
                bonusMaxHealth += mods.maxHealth || 0; bonusMaxMana += mods.maxMana || 0; bonusMaxStamina += mods.maxStamina || 0;
                bonusStrength += mods.strength || 0; bonusDexterity += mods.dexterity || 0; bonusIntelligence += mods.intelligence || 0; bonusConstitution += mods.constitution || 0;
                if (mods.moveSpeedMultiplier) moveSpeedMultiplier *= mods.moveSpeedMultiplier;
                if (mods.manaCostMultiplier) manaCostMultiplier *= mods.manaCostMultiplier;
            }
        });

        // --- 6. Calcular Atributos Finales ---
        const finalStr = attr.strength + bonusStrength; const finalDex = attr.dexterity + bonusDexterity;
        const finalInt = attr.intelligence + bonusIntelligence; const finalCon = attr.constitution + bonusConstitution;

        // --- 7. Recalcular Stats Derivados con Atributos y Bonus Finales ---
        // Máximos primero
        baseStats.maxHealth = BASE_HEALTH + finalCon * HEALTH_PER_CON + bonusMaxHealth;
        baseStats.maxMana = BASE_MANA + finalInt * MANA_PER_INT + bonusMaxMana;
        baseStats.maxStamina = BASE_STAMINA + finalDex * STAMINA_PER_DEX + bonusMaxStamina;
        // Daño
        baseStats.physDmgMin = 3 + finalStr * PHYS_DMG_PER_STR.min + bonusPhysDmgMin;
        baseStats.physDmgMax = 6 + finalStr * PHYS_DMG_PER_STR.max + bonusPhysDmgMax;
        baseStats.magicDmgMin = 2 + finalInt * MAGIC_DMG_PER_INT.min + bonusMagicDmgMin;
        baseStats.magicDmgMax = 4 + finalInt * MAGIC_DMG_PER_INT.max + bonusMagicDmgMax;
        // Defensas
        baseStats.defense = finalCon * DEF_PER_CON + bonusDefense;
        baseStats.magicResist = finalInt * MRES_PER_INT + bonusMagicResist;
        // Probabilidades
        baseStats.hitChance = 70 + finalDex * HIT_CHANCE_PER_DEX + bonusHitChance;
        baseStats.critChance = 5 + finalDex * CRIT_CHANCE_PER_DEX + bonusCritChance;
        // Movimiento
        baseStats.moveSpeed = (MOVE_SPEED_BASE + bonusMoveSpeed) * moveSpeedMultiplier;
        // Regeneración
        baseStats.hpRegen = 0.2 + finalCon * 0.05 + bonusHpRegen;
        baseStats.mpRegen = 0.5 + finalInt * 0.08 + bonusMpRegen;
        baseStats.spRegen = 1.0 + finalDex * 0.1 + bonusSpRegen;

        // --- 8. Aplicar Límites y Redondeos Finales ---
        baseStats.maxHealth = Math.max(1, Math.floor(baseStats.maxHealth)); baseStats.maxMana = Math.max(0, Math.floor(baseStats.maxMana)); baseStats.maxStamina = Math.max(1, Math.floor(baseStats.maxStamina));
        baseStats.physDmgMin = Math.max(1, Math.floor(baseStats.physDmgMin)); baseStats.physDmgMax = Math.max(baseStats.physDmgMin, Math.floor(baseStats.physDmgMax));
        baseStats.magicDmgMin = Math.max(0, Math.floor(baseStats.magicDmgMin)); baseStats.magicDmgMax = Math.max(baseStats.magicDmgMin, Math.floor(baseStats.magicDmgMax));
        baseStats.hitChance = Math.max(5, Math.min(100, baseStats.hitChance)); baseStats.critChance = Math.max(0, Math.min(100, baseStats.critChance));
        baseStats.defense = Math.max(0, baseStats.defense); baseStats.magicResist = Math.max(0, baseStats.magicResist);
        baseStats.moveSpeed = Math.max(0.5, baseStats.moveSpeed);
        baseStats.hpRegen = Math.max(0, baseStats.hpRegen); baseStats.mpRegen = Math.max(0, baseStats.mpRegen); baseStats.spRegen = Math.max(0, baseStats.spRegen);

        // --- 9. Ajustar Stats Actuales a Nuevos Máximos (Evitar desbordamiento) ---
        baseStats.health = Math.min(baseStats.health, baseStats.maxHealth);
        baseStats.mana = Math.min(baseStats.mana, baseStats.maxMana);
        baseStats.stamina = Math.min(baseStats.stamina, baseStats.maxStamina);
        // Asegurar que no sean negativos (excepto quizás vida temporalmente antes de morir)
        baseStats.mana = Math.max(0, baseStats.mana);
        baseStats.stamina = Math.max(0, baseStats.stamina);

        // --- 10. Guardar Multiplicadores ---
        playerState.manaCostMultiplier = Math.max(0.1, manaCostMultiplier); // Mínimo 10% coste
        playerState.moveSpeedMultiplier = moveSpeedMultiplier; // Guardar por si se necesita para algo más

        // console.log("Player stats updated."); // Reduce spam
    }

    function getEquippedItems() {
        if (!playerState || typeof playerState.equipment !== 'object' || playerState.equipment === null) return [];
        // Devolver solo los valores (objetos de item) que no sean null/undefined
        return Object.values(playerState.equipment).filter(item => item != null);
    }
function handleInventorySlotMouseEnter(event) {
        const slot = event.currentTarget;
        if (!(slot instanceof HTMLElement)) return;
        const indexString = slot.dataset.index;
        if (indexString === undefined) return;
        const index = Number.parseInt(indexString, 10);

        if (index >= 0 && index < inventory.items.length) {
            const item = inventory.items[index];
            if (item) {
                if (gameState.tooltipTimeout) { clearTimeout(gameState.tooltipTimeout); gameState.tooltipTimeout = null; }
                gameState.tooltipTimeout = setTimeout(() => {
                    showItemTooltip(item, event, 'inventory');
                    gameState.tooltipTimeout = null;
                }, TOOLTIP_DELAY);
            } else { hideTooltip(); }
        } else { hideTooltip(); }
    }

/**
 * Actualiza la interfaz de usuario del panel de Equipo.
 * Muestra los iconos correctos (HTML o texto) y añade listener de clic izquierdo para desequipar.
 * (v2 - Icon Fix & Unequip Click)
 */
function updateEquipmentUI() {
    const slotMap = domCache.equipmentSlotMap; // Usa el mapa cacheado
    if (!slotMap || Object.keys(slotMap).length === 0) {
        // Solo advertir si el modal existe pero el mapa está vacío (error interno)
        if(domCache['equipment-modal']) console.error("updateEquipmentUI: equipmentSlotMap está vacío o no inicializado.");
        return; // Salir si no hay mapa de slots
    }

    // Iterar sobre cada slot definido en el mapa
    for (const slotName in slotMap) {
        const slotElement = slotMap[slotName];
        if (!(slotElement instanceof HTMLElement)) {
            console.warn(`updateEquipmentUI: Slot element para '${slotName}' no es un HTMLElement válido.`);
            continue; // Saltar a la siguiente iteración si el elemento no es válido
        }

        const equippedItem = playerState.equipment?.[slotName]; // Obtener item equipado (puede ser undefined)
        const itemDef = equippedItem ? itemDefinitions[equippedItem.id] : null; // Obtener definición si hay item

        // --- Limpieza Rigurosa del Slot ---
        // Eliminar todos los hijos existentes
        while (slotElement.firstChild) {
            slotElement.removeChild(slotElement.firstChild);
        }
        // Resetear clases base y de rareza
        const baseClassName = 'equipment-slot'; // Clase base que siempre debe estar
        const rarityClassesToRemove = ['common', 'uncommon', 'rare', 'epic', 'legendary', 'quest'].map(r => `item-rarity-${r}`);
        slotElement.className = baseClassName; // Resetear a solo la clase base
        slotElement.classList.remove(...rarityClassesToRemove); // Quitar todas las de rareza

        // Limpiar listeners anteriores para evitar duplicados
        if (slotElement.currentClickListener) slotElement.removeEventListener('click', slotElement.currentClickListener);
        if (slotElement.currentMouseEnterListener) slotElement.removeEventListener('mouseenter', slotElement.currentMouseEnterListener);
        if (slotElement.currentMouseLeaveListener) slotElement.removeEventListener('mouseleave', slotElement.currentMouseLeaveListener);
        // Limpiar referencia al listener de contextmenu si existía
        if (slotElement.currentContextMenuListener) slotElement.removeEventListener('contextmenu', slotElement.currentContextMenuListener);
        slotElement.currentClickListener = null;
        slotElement.currentMouseEnterListener = null;
        slotElement.currentMouseLeaveListener = null;
        slotElement.currentContextMenuListener = null; // Limpiar también esta referencia

        // --- Poblar Slot si hay Item Equipado ---
        if (equippedItem && itemDef) {
            const iconContainer = document.createElement('div');
            iconContainer.className = 'inventory-item'; // Reutilizar clase para estilo

            // --- Lógica de Icono Corregida ---
            if (itemDef.icon_type === 'html') {
                // Si es HTML, usar innerHTML para renderizar la etiqueta (ej. <img>)
                iconContainer.innerHTML = itemDef.icon || '❓'; // Insertar HTML
                // Ajustar estilo si es necesario (ej. tamaño imagen)
                const imgElement = iconContainer.querySelector('img');
                if (imgElement) {
                    imgElement.style.maxWidth = '90%'; // Limitar tamaño dentro del slot
                    imgElement.style.maxHeight = '90%';
                    imgElement.style.objectFit = 'contain';
                }
            } else {
                // Si es texto (emoji, FA), usar textContent
                iconContainer.textContent = itemDef.icon || '❓';
                // Asegurar tamaño de fuente adecuado si es necesario
                // iconContainer.style.fontSize = '26px'; // Ajustar si el CSS no lo maneja
            }
            slotElement.appendChild(iconContainer); // Añadir contenedor del icono

            // Añadir clase de rareza
            const rarity = itemDef.rarity || 'common';
            slotElement.classList.add(`item-rarity-${rarity}`);

            // --- Listeners para Item Equipado ---
            // Tooltip al pasar el ratón
            const mouseEnterListener = (e) => showItemTooltip(equippedItem, e, 'equipment');
            slotElement.addEventListener('mouseenter', mouseEnterListener);
            slotElement.currentMouseEnterListener = mouseEnterListener;

            // Ocultar tooltip al salir
            const mouseLeaveListener = () => hideTooltip();
            slotElement.addEventListener('mouseleave', mouseLeaveListener);
            slotElement.currentMouseLeaveListener = mouseLeaveListener;

            // --- CAMBIO: Desequipar con CLIC IZQUIERDO ---
            const clickListener = (e) => {
                e.preventDefault(); // Prevenir comportamiento por defecto del clic si es necesario
                if (!gameState.isGhost) { // No desequipar si es fantasma
                    unequipItem(slotName); // Llamar a desequipar
                }
            };
            slotElement.addEventListener('click', clickListener); // Usar 'click' en lugar de 'contextmenu'
            slotElement.currentClickListener = clickListener; // Guardar referencia al listener de clic
            // -----------------------------------------

        } else {
            // --- Slot Vacío ---
            // Añadir listeners para tooltip de slot vacío
            const mouseEnterListener = (e) => showEmptySlotTooltip(slotName, e);
            slotElement.addEventListener('mouseenter', mouseEnterListener);
            slotElement.currentMouseEnterListener = mouseEnterListener;

            const mouseLeaveListener = () => hideTooltip();
            slotElement.addEventListener('mouseleave', mouseLeaveListener);
            slotElement.currentMouseLeaveListener = mouseLeaveListener;
            // No añadir listener de clic para slots vacíos
        }
    }
}
    function updateQuestLog() {
        const questLogContainer = domCache['quest-log'];
        if (!(questLogContainer instanceof HTMLElement)) { console.error("#quest-log no encontrado."); return; }
        questLogContainer.innerHTML = '';

        const activeQuests = quests.active || []; const completedQuests = quests.completed || [];
        if (activeQuests.length === 0 && completedQuests.length === 0) { questLogContainer.innerHTML = '<div class="quest-empty">Sin misiones.</div>'; return; }

        const createQuestEntryElement = (quest, isCompleted) => { /* ... (código existente para crear elemento quest) ... */
            const questDef = questDefinitions[quest.id]; if (!questDef) return null;
            const questEntry = document.createElement('div'); questEntry.className = `quest-entry ${isCompleted ? 'completed' : ''}`; questEntry.dataset.questId = quest.id;
            const titleDiv = document.createElement('div'); titleDiv.className = 'quest-title'; const qName = questDef.name || '?'; const qLevel = questDef.level || '?';
            titleDiv.innerHTML = `${qName} <span class="quest-level">Nvl ${qLevel}</span>`;
            // Botón Track
            if(!isCompleted) {
                 const trackButton = document.createElement('button');
                 trackButton.className = 'quest-track-button';
                 const isTracking = playerState.trackedQuestId === quest.id;
                 trackButton.textContent = isTracking ? 'Siguiendo' : 'Seguir';
                 trackButton.classList.toggle('tracking', isTracking);
                 trackButton.onclick = (e) => {
                     e.stopPropagation(); // Evitar que expanda/colapse la quest
                     if(playerState.trackedQuestId === quest.id) playerState.trackedQuestId = null; // Dejar de seguir
                     else playerState.trackedQuestId = quest.id; // Seguir esta
                     updateQuestLog(); // Refrescar botones
                     updateQuestTrackerUI(); // Actualizar tracker UI
                 };
                 titleDiv.appendChild(trackButton);
            }
            questEntry.appendChild(titleDiv);
            const detailsDiv = document.createElement('div'); detailsDiv.className = 'quest-details';
            if (questDef.description) { const d = document.createElement('div'); d.className = 'quest-description'; d.textContent = questDef.description; detailsDiv.appendChild(d); }
            if (!isCompleted && questDef.objectives?.length > 0) { const oh = document.createElement('div'); oh.style.cssText='margin-top:8px;font-weight:bold;font-size:10px;color:var(--color-text)'; oh.textContent='Objetivos:'; detailsDiv.appendChild(oh); questDef.objectives.forEach((objDef, index) => { const currentObj = quest.objectives?.find(o => (o.id && o.id === objDef.id) || (o.type === objDef.type && o.target === objDef.target)) || quest.objectives?.[index]; const current = currentObj?.current || 0; const target = objDef.count || 1; const isObjDone = current >= target; const objDiv = document.createElement('div'); objDiv.className = `quest-objective ${isObjDone ? 'completed' : ''}`; const objText = objDef.description || getObjectiveText(objDef); objDiv.textContent = `${objText} (${current}/${target})`; detailsDiv.appendChild(objDiv); }); }
            else if (isCompleted) { const ct = document.createElement('div'); ct.className = 'quest-objective completed'; ct.textContent = "Completada."; ct.style.cssText = 'margin-left:0; padding-left:0; color: var(--color-success) !important; text-decoration: none; font-style: italic; &::before { display: none !important; }'; detailsDiv.appendChild(ct); }
            if (questDef.rewards) { const rd = document.createElement('div'); rd.className = 'quest-rewards'; rd.textContent = 'Recompensas: ' + formatQuestRewards(questDef.rewards); detailsDiv.appendChild(rd); }
            questEntry.appendChild(detailsDiv);
            questEntry.addEventListener('click', (e) => { if (!(e.target instanceof HTMLButtonElement)) questEntry.classList.toggle('active'); }); // No toggle si click en botón
            return questEntry;
         };

        if (activeQuests.length > 0) { const h = document.createElement('div'); h.className = 'quest-section-header'; h.textContent = 'Activas'; questLogContainer.appendChild(h); activeQuests.forEach(q => {const el=createQuestEntryElement(q, false); if(el) questLogContainer.appendChild(el);}); }
        if (completedQuests.length > 0) { const h = document.createElement('div'); h.className = 'quest-section-header'; h.textContent = 'Completadas'; questLogContainer.appendChild(h); completedQuests.forEach(qId => { const qData = {id: qId}; /* Podrías necesitar buscar datos si guardas más que ID */ const el=createQuestEntryElement(qData, true); if(el) questLogContainer.appendChild(el);}); }
    }

    function formatQuestRewards(rewards) {
        if (!rewards) return 'Ninguna'; const parts = [];
        if (rewards.xp) parts.push(`${rewards.xp} XP`); if (rewards.gold) parts.push(`${rewards.gold} Oro`);
        if (rewards.items && rewards.items.length > 0) {
            const itemCounts = {}; rewards.items.forEach(itemString => { const p = itemString.split(':'); const id = p[0]; const c = p.length > 1 ? parseInt(p[1], 10) : 1; if(!isNaN(c) && c > 0) itemCounts[id] = (itemCounts[id] || 0) + c; });
            Object.entries(itemCounts).forEach(([id, c]) => { const n=getItemName(id); parts.push(`${n}${c > 1 ? ` x${c}` : ''}`); });
        }
         if (rewards.recipes && rewards.recipes.length > 0) parts.push(`${rewards.recipes.length} Receta(s)`);
        return parts.join(', ') || 'Ninguna';
    }

    function getObjectiveText(objectiveDef) {
         switch(objectiveDef.type) {
             case 'kill': return `Elimina ${enemyDefinitions[objectiveDef.target]?.name || objectiveDef.target}`;
             case 'collect': return `Recolecta ${getItemName(objectiveDef.target)}`;
             case 'reach': return `Ve a ${objectiveDef.target}`;
             case 'interact': return `Interactúa con ${objectiveDef.target}`;
             default: return `Completa (${objectiveDef.target})`;
         }
     }

    function showItemTooltip(itemData, event, context = 'inventory') {
        const tooltip = domCache['item-tooltip'] || domCache['equipment-tooltip'] || domCache['shop-tooltip'];
        if (!(tooltip instanceof HTMLElement) || !itemData || !itemData.id) return;
        const itemDef = itemDefinitions[itemData.id];
        if (!itemDef) { tooltip.innerHTML=`<div class="tooltip-section"><span class="name-tooltip">${itemData.name||itemData.id}</span></div>`; positionTooltip(tooltip,event); tooltip.style.display='block'; gameState.activeTooltip=tooltip; return; }

        let content = ''; const rarity = itemDef.rarity || 'common'; const rarityClass = `item-name-${rarity}`;
        content += `<div class="tooltip-section"><span class="name-tooltip ${rarityClass}">${itemDef.name}</span><span class="type-tooltip">${itemDef.type} ${itemDef.slot ? `(${getSlotName(itemDef.slot)})` : ''} - Rareza: ${rarity}</span></div>`;
        if (itemDef.stats && Object.keys(itemDef.stats).length > 0) { content += `<div class="tooltip-section stats-tooltip">`; for (const [stat, value] of Object.entries(itemDef.stats)) { if (value !== 0) { const s = value > 0 ? '+' : ''; const suf = stat.includes('Chance') ? '%' : ''; content += `<span>${s}${value}${suf} ${getStatName(stat)}</span>`; } } content += `</div>`; }
        if (itemDef.description) { content += `<div class="tooltip-section"><span class="desc-tooltip">${itemDef.description}</span></div>`; }
        content += `<div class="tooltip-section">`; if (itemDef.value > 0 || itemDef.type === 'currency') { content += `<span class="value-tooltip">Valor: ${itemDef.value} Oro</span>`; } if (itemDef.stackable) { content += `<span class="desc-tooltip" style="font-size: 9px;">Apilable (Máx: ${itemDef.maxStack || 'N/A'})</span>`; } content += `</div>`;

        const isEquippable = itemDef.slot && ['weapon', 'armor', 'amulet', 'ring'].includes(itemDef.type);
        if (isEquippable && context !== 'equipment') {
            let targetSlot = itemDef.slot; if (targetSlot === 'ring') targetSlot = 'ring1'; // Comparar con ring1 por defecto
            const currentlyEquipped = playerState.equipment?.[targetSlot];
            if (currentlyEquipped && currentlyEquipped.id !== itemData.id) {
                const equippedDef = itemDefinitions[currentlyEquipped.id];
                if (equippedDef?.stats) {
                     content += `<div class="tooltip-section comparison-tooltip"><span>Comparando: ${equippedDef.name}</span><br>`; let hasComp = false;
                     const statsToCompare = ['physDmgMin','physDmgMax','magicDmgMin','magicDmgMax','defense','magicResist','strength','dexterity','intelligence','constitution','moveSpeed','critChance','hitChance','hpRegen','mpRegen','spRegen','maxHealth','maxMana','maxStamina'];
                     statsToCompare.forEach(stat => { const itemV = itemDef.stats?.[stat]||0; const eqpV = equippedDef.stats?.[stat]||0; const diff = itemV - eqpV; if(diff !== 0) { hasComp=true; const sgn=diff>0?'+':''; const sfx=stat.includes('Chance')?'%':''; const cls=diff>0?'comparison-better':'comparison-worse'; content += `<span class="${cls}">(${sgn}${diff.toFixed(stat.includes('Regen')||stat.includes('Speed')?1:0)}${sfx})</span> `; } });
                     if(!hasComp) content += '<span>(Stats iguales)</span>'; content += `</div>`;
                }
            } else if (currentlyEquipped && currentlyEquipped.id === itemData.id) content += `<div class="tooltip-section comparison-tooltip"><span>(Equipado)</span></div>`;
             else content += `<div class="tooltip-section comparison-tooltip comparison-better"><span>(Mejora)</span></div>`;
        }

        if (itemDef.requirements) {
             content += `<div class="tooltip-section">`; let reqText = ''; const reqs = itemDef.requirements;
             if(reqs.level) reqText += `Nvl ${reqs.level}, `; if(reqs.class) reqText += `Clase ${reqs.class.join('/')}, `;
             if(reqs.attributes) reqText += Object.entries(reqs.attributes).map(([a,v])=>`${v} ${getAttributeName(a)}`).join(', ');
             reqText = reqText.replace(/,\s*$/, ''); const meets = checkItemRequirements(itemDef);
             content += `<span class="desc-tooltip ${meets ? 'comparison-better' : 'comparison-worse'}">Requiere: ${reqText}</span>`; content += `</div>`;
        }

        tooltip.innerHTML = content; positionTooltip(tooltip, event); tooltip.style.display = 'block'; gameState.activeTooltip = tooltip;
    }


/**
 * Desequipa un item de un slot específico y lo mueve al inventario.
 * Se asegura de que el item tenga una propiedad 'count' al añadirlo al inventario.
 * Maneja el caso de inventario lleno.
 * (v2 - Ensure Count)
 *
 * @param {string} slotName - El nombre del slot de equipamiento (ej: 'weapon', 'head').
 */
function unequipItem(slotName) {
    // 1. Validar Slot y Item Equipado
    if (!playerState.equipment || !playerState.equipment[slotName]) {
        console.log(`unequipItem: No hay item equipado en el slot '${slotName}'.`);
        return; // No hay nada que desequipar
    }

    const itemToUnequip = playerState.equipment[slotName];
    const itemDef = itemDefinitions[itemToUnequip.id];

    if (!itemDef) {
        console.error(`unequipItem: Definición no encontrada para item ID: ${itemToUnequip.id} en slot ${slotName}. Forzando desequipado.`);
        playerState.equipment[slotName] = null; // Quitar el item inválido del equipo
        updateEquipmentUI();
        updatePlayerStats();
        updatePlayerUI();
        return;
    }

    // 2. Comprobar Espacio en Inventario
    if (inventory.items.length >= inventory.maxItems) {
        logMessage(`Inventario lleno. No se puede desequipar ${itemDef.name}.`, "error");
        showNotification("Inventario Lleno", "error");
        AudioManager.playSound('ui_error', 0.4);
        return; // Salir si no hay espacio
    }

    // 3. --- ASEGURAR PROPIEDAD 'COUNT' ---
    // Antes de moverlo al inventario, nos aseguramos de que tenga 'count'.
    // Si el item era stackable y tenía un count > 1 (raro para equipo), lo mantenemos.
    // Si no es stackable o no tenía count, le ponemos count = 1.
    if (!itemDef.stackable || itemToUnequip.count === undefined || itemToUnequip.count <= 0) {
        itemToUnequip.count = 1; // Establecer count a 1 para items no apilables o sin count previo
    }
    // -----------------------------------

    // 4. Mover Item al Inventario
    inventory.items.push(itemToUnequip); // Añadir la instancia del item (ahora con .count)

    // 5. Limpiar Slot de Equipo
    playerState.equipment[slotName] = null;

    // 6. Feedback y Actualizar UI/Stats
    AudioManager.playSound('unequip', 0.55);
    logMessage(`Has desequipado ${itemDef.name}.`, "system");

    updatePlayerAppearance(); // Actualizar modelo 3D (si aplica)
    updatePlayerStats();      // Recalcular stats sin el item
    updateInventoryUI();      // Mostrar item en inventario
    updateEquipmentUI();      // Mostrar slot vacío
    updatePlayerUI();         // Actualizar barras/stats generales
    updateCharacterSheet();   // Actualizar hoja si está abierta
    updateActionButtons();    // Actualizar botones generales (equipar/usar/soltar)
    // Si el item desequipado estaba en la hotbar, actualizarla también
    updateActionSlotsUI();

    console.log(`Item ${itemDef.name} movido de slot '${slotName}' a inventario con count: ${itemToUnequip.count}`);
}
 
    
function showFloatingText(className, text, position3D) {
    // 1. Validaciones básicas (igual que antes)
    if (!text || !position3D || !camera || !renderer) { return; }
    const screenPos = projectToScreen(position3D);
    if (!screenPos) { return; }

    // 2. Crear el elemento (igual que antes)
    const textElement = document.createElement('span');
    textElement.className = `floating-text ${className}`;
    textElement.textContent = text;

    // *** INICIO NUEVO: Offset Aleatorio ***
    // Añadir un ligero desplazamiento horizontal aleatorio
    const randomOffsetX = (Math.random() - 0.5) * 25; // +/- 12.5px
    // Aplicar el offset al cálculo de 'left'
    textElement.style.left = `${Math.round(screenPos.x + randomOffsetX)}px`;
    // *** FIN NUEVO: Offset Aleatorio ***

    textElement.style.top = `${Math.round(screenPos.y)}px`;
    textElement.style.transform = 'translateX(-50%)'; // Centrar después del offset
    textElement.style.pointerEvents = 'none';
    textElement.style.zIndex = '20';

    // 3. Aplicar color (igual que antes)
    let finalColor = '#FFFFFF';
    try {
        const colorType = className.replace('-text', '');
        const cssVarName = `--color-${colorType}`;
        const cssColor = getComputedStyle(document.documentElement).getPropertyValue(cssVarName).trim();
        if (cssColor) { finalColor = cssColor; }
        else { const fallbacks = {/* ... */}; finalColor = fallbacks[colorType] || '#FFFFFF'; }
    } catch (e) { /* ... */ }
    textElement.style.color = finalColor;

    // 4. Añadir al DOM (igual que antes)
    document.body.appendChild(textElement);

    // 5. Eliminar después de la animación (IMPORTANTE: ajustar duración)
    // Asegúrate que esta duración coincida con la animación MÁS LARGA (crítico)
    const longestAnimationDuration = 2000; // ms (ajusta a la duración de float-up-fade-critical)
    setTimeout(() => {
        if (textElement.parentNode) { textElement.remove(); }
    }, longestAnimationDuration);
}
function pauseGame() {
    if (!gameState.isPlaying || gameState.isPaused || gameState.isLoading) {
        return;
    }
    if (gameState.isInDialog || gameState.isShopOpen || gameState.isCharacterSheetOpen || gameState.isOptionsMenuOpen) { // Añadido isOptionsMenuOpen
         logMessage("Cierra los paneles abiertos antes de pausar.", "info");
         AudioManager.playSound('ui_error', 0.4);
         return;
    }

    gameState.isPaused = true;
    console.log("Juego Pausado.");
    stopGameLoop();

    const pauseOverlay = domCache['pause-indicator-overlay'];
    if (pauseOverlay instanceof HTMLElement) {
        pauseOverlay.innerHTML = '';

        const pauseTitle = document.createElement('div');
        pauseTitle.id = 'pause-text';
        pauseTitle.textContent = 'PAUSA';
        pauseOverlay.appendChild(pauseTitle);

        const menuContainer = document.createElement('div');
        menuContainer.style.marginTop = '30px';
        menuContainer.style.display = 'flex';
        menuContainer.style.flexDirection = 'column';
        menuContainer.style.alignItems = 'center';
        pauseOverlay.appendChild(menuContainer);

        const continueBtn = document.createElement('button');
        continueBtn.className = 'menu-button';
        continueBtn.innerHTML = '<i class="fas fa-play"></i> Continuar';
        continueBtn.onclick = resumeGame;
        menuContainer.appendChild(continueBtn);

        const optionsBtn = document.createElement('button');
        optionsBtn.className = 'menu-button';
        optionsBtn.innerHTML = '<i class="fas fa-cog"></i> Opciones';
        optionsBtn.onclick = openOptionsMenu; // Llama a abrir el menú de opciones
        menuContainer.appendChild(optionsBtn);

        const saveBtn = document.createElement('button');
        saveBtn.className = 'menu-button';
        saveBtn.innerHTML = '<i class="fas fa-save"></i> Guardar';
        saveBtn.onclick = () => {
            saveGame();
            logMessage("Partida guardada manualmente.", "system");
            showNotification("Partida Guardada", "success", 2000);
        };
        menuContainer.appendChild(saveBtn);

      const exitBtn = document.createElement('button'); // Your existing code to create the button
        exitBtn.className = 'menu-button';
        exitBtn.style.marginTop = '20px';
        exitBtn.style.borderColor = 'var(--color-danger)';
        exitBtn.innerHTML = '<i class="fas fa-sign-out-alt"></i> Salir al Menú';

        // --- *** MODIFIED onClick Handler *** ---
        exitBtn.onclick = () => {
            if (confirm("¿Estás seguro de que quieres salir al menú principal? El progreso no guardado se perderá.")) {
                console.log("Saliendo al menú principal y reseteando...");

                // --- 1. Stop Game Logic ---
                gameState.isPlaying = false;
                gameState.isPaused = false;
                stopGameLoop(); // Stop the game loop

                // --- 2. Clean Up 3D Scene (Crucial) ---
                // Remove player model
                if (playerModel && playerModel.parent) scene.remove(playerModel);
                playerModel = null;
                playerMeshes = {}; // Clear mesh references
                // Remove NPCs, Enemies, Items, Projectiles, AOEs, etc.
                world.npcs.forEach(o => { if(o?.parent) scene.remove(o); }); world.npcs = [];
                world.enemies.forEach(o => { if(o?.parent) scene.remove(o); }); world.enemies = [];
                world.items.forEach(o => { if(o?.parent) scene.remove(o); }); world.items = [];
                world.activeProjectiles.forEach(o => { if(o?.parent) scene.remove(o); }); world.activeProjectiles = [];
                world.activeAOEs.forEach(o => { if(o?.mesh?.parent) scene.remove(o.mesh); }); world.activeAOEs = [];
                // Remove all interactables except maybe persistent world ones? Simplest is to clear and repopulate later.
                world.interactables = []; // Reset interactables
                // Remove dungeon elements if any
                if (world.dungeon?.geometryGroup?.parent) scene.remove(world.dungeon.geometryGroup);
                if (world.dungeon?.ambientLight?.parent) scene.remove(world.dungeon.ambientLight);
                world.dungeon = {};
                // Remove overworld elements if backed up
                if(world.overworldObjectsToRemove) world.overworldObjectsToRemove.forEach(o => {if(o?.parent) scene.remove(o);}); world.overworldObjectsToRemove=[];
                // Reset Chunk Manager (Important!)
                ChunkManager.activeChunks.forEach((_, key) => ChunkManager.unloadChunkByKey(key)); // Unload all active
                ChunkManager.playerChunkCoords = { x: -Infinity, z: -Infinity }; // Reset player chunk pos
                ChunkManager.loadingQueue.clear();
                ChunkManager.unloadQueue.clear();
                ChunkManager.currentLoadingChunkKey = null;
                // Remove particles
                world.particles = [];

                // --- 3. Reset Game State Variables ---
                // Reset playerState partially (keep name? or full reset?)
                setupInitialPlayerState(); // This should reset stats, inventory, quests, etc.
                // Reset gameState flags
                Object.keys(gameState).forEach(key => {
                     if(typeof gameState[key] === 'boolean') gameState[key] = false;
                     else if(typeof gameState[key] === 'number') gameState[key] = 0;
                     else if(key !== 'currentLocation') gameState[key] = null; // Reset others except location
                });
                gameState.isLoading = false; // Not loading anymore
                gameState.currentLocation = 'world'; // Default back to world

                // --- 4. Reset UI Elements ---
                // Hide game UI, show start screen
                const sidebar = domCache["sidebar"];
                const uiContainer = domCache["ui-container"];
                if (sidebar instanceof HTMLElement) sidebar.style.display = "none";
                if (uiContainer instanceof HTMLElement) uiContainer.style.display = "none";
                if (pauseOverlay instanceof HTMLElement) pauseOverlay.style.display = 'none'; // Hide pause menu
                // Close any potentially open modals (extra safety)
                closeOtherModals();
                // Reset Character Creation selections (if needed)
                 const nameInput = domCache['character-name']; if(nameInput) nameInput.value = 'Héroe';
                 domCache.raceOptions?.forEach(o => o.classList.remove('selected')); domCache.raceOptions?.[0]?.classList.add('selected'); // Select first race
                 domCache.classOptions?.forEach(o => o.classList.remove('selected')); domCache.classOptions?.[0]?.classList.add('selected'); // Select first class
                 domCache.genderRadios?.forEach(r => r.checked = (r.value === 'male')); // Select male default
                 if(domCache['char-preview-model']) domCache['char-preview-model'].innerHTML = ''; // Clear preview model div


                // --- 5. Finalize (Shows Start Screen, updates Continue button) ---
                finalizeInitialization();
                AudioManager.stopMusic();
                console.log("Estado del juego reseteado para el menú principal.");
            }
        };
        // --- End MODIFIED onClick Handler ---

        menuContainer.appendChild(exitBtn); // Add the button to the menu

        pauseOverlay.style.display = 'flex'; // Show the pause overlay

    } else {
        logMessage("Juego Pausado. Presiona 'Esc' para reanudar.", "system");
    }

    if (typeof AudioManager !== 'undefined' && AudioManager.setVolume) {
        AudioManager.setVolume('music', AudioManager.musicVolume * 0.15);
        AudioManager.setVolume('weather', AudioManager.weatherVolume * 0.2);
    }
}


    function resumeGame() {
        if (!gameState.isPlaying || !gameState.isPaused) return;
        gameState.isPaused = false; console.log("Juego Reanudado.");
        const pauseOverlay = domCache['pause-indicator-overlay']; if (pauseOverlay instanceof HTMLElement) { pauseOverlay.style.display = 'none'; pauseOverlay.innerHTML = ''; }
        if (AudioManager) { AudioManager.setVolume('music', AudioManager.musicVolume); AudioManager.setVolume('weather', AudioManager.weatherVolume); }
        startGameLoop();
    }

    function checkInteractions() {
        if (!gameState.isPlaying || gameState.isPaused || gameState.isInDialog || gameState.isShopOpen || gameState.isCharacterSheetOpen || gameState.isGhost) { if (gameState.targetEntity) { gameState.targetEntity = null; updateTargetUI(); } return; }

        let closestInteractableInFront = null; let minDistanceSq = INTERACT_DISTANCE_SQ;
        const playerForward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerModel.quaternion);
        const interactionOrigin = playerState.position.clone().add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.8, 0)).addScaledVector(playerForward, 0.2);

        for (const obj of world.interactables) {
            if (!obj?.visible || !obj.userData?.interactable || !obj.position) continue;
            if (obj.userData.type === 'chest' && obj.userData.isOpen) continue;
            if (obj.userData.type === 'resource' && obj.userData.depleted) continue;

            const distanceToObjSq = interactionOrigin.distanceToSquared(obj.position);
            if (distanceToObjSq < minDistanceSq) {
                const directionToObject = new THREE.Vector3().subVectors(obj.position, interactionOrigin).normalize();
                const dotProduct = playerForward.dot(directionToObject);
                if (dotProduct > 0.65) {
                    const targetCenter = obj.position.clone().add(new THREE.Vector3(0, obj.userData.heightOffset || 0.5, 0)); // Target center for LOS
                    if (checkLineOfSight(interactionOrigin, targetCenter)) {
                        closestInteractableInFront = obj; minDistanceSq = distanceToObjSq;
                    }
                }
            }
        }
        if (closestInteractableInFront !== gameState.targetEntity) { gameState.targetEntity = closestInteractableInFront; updateTargetUI(); }
    }

    function showEmptySlotTooltip(slotName, event) {
        const tooltipElement = domCache['equipment-tooltip'] || domCache['item-tooltip'];
        if (!(tooltipElement instanceof HTMLElement)) return;
        const slotDisplayName = getSlotName(slotName);
        const content = `<div class="tooltip-section"><span class="name-tooltip" style="color: #999;">Slot Vacío</span><span class="type-tooltip" style="text-transform: capitalize;">${slotDisplayName}</span><span class="desc-tooltip" style="margin-top: 5px;">Equipa un objeto de tipo '${itemTypeForSlot(slotName)}'.</span></div>`;
        tooltipElement.innerHTML = content; positionTooltip(tooltipElement, event); tooltipElement.style.display = 'block'; gameState.activeTooltip = tooltipElement;
    }

function itemTypeForSlot(slotName) {
        switch(slotName) {
            case 'head': return 'Casco/Sombrero';
            case 'chest': return 'Armadura (Pecho)';
            case 'legs': return 'Armadura (Piernas)';
            case 'feet': return 'Botas';
            case 'weapon': return 'Arma';
            case 'shield': return 'Escudo';
            case 'amulet': return 'Amuleto';
            case 'ring': case 'ring1': case 'ring2': return 'Anillo';
            case 'gloves': return 'Guantes';
            case 'belt': return 'Cinturón';
            case 'back': return 'Capa/Mochila';
            default: return 'Equipamiento';
        }
    }

    function updateTargetUI() {
        const targetInfoPanel = domCache['target-info']; const targetNameElement = domCache['target-name'];
        const targetHealthContainer = domCache['target-health-bar-container']; const targetHealthBarElement = domCache['target-health-bar'];

        if (!(targetInfoPanel instanceof HTMLElement) || !(targetNameElement instanceof HTMLElement) || !(targetHealthContainer instanceof HTMLElement) || !(targetHealthBarElement instanceof HTMLElement)) {
            // Evitar spam si faltan elementos permanentemente
            if (!updateTargetUI.warned) { console.warn("updateTargetUI: Elementos UI objetivo no encontrados."); updateTargetUI.warned = true; }
            return;
        }
        updateTargetUI.warned = false; // Resetear advertencia si los elementos se encontraron

        const target = gameState.targetEntity;

        if (target?.userData) { // Usar optional chaining
            if (targetInfoPanel.style.display === 'none') targetInfoPanel.style.display = 'block';
            const targetName = target.userData.name || target.userData.type || '[Desconocido]';
            if (targetNameElement.textContent !== targetName) targetNameElement.textContent = targetName;

            const targetStats = target.userData.stats || target.userData; // Buscar stats o usar userData directo
            const hasHealth = typeof targetStats.health === 'number' && typeof targetStats.maxHealth === 'number' && targetStats.maxHealth > 0 && !targetStats.isDead;

            if (hasHealth) {
                if (targetHealthContainer.style.display === 'none') targetHealthContainer.style.display = 'block';
                const currentHealth = Math.max(0, targetStats.health);
                const maxHealth = targetStats.maxHealth;
                const healthPercent = Math.min(100, (currentHealth / maxHealth) * 100);
                const newWidth = `${healthPercent.toFixed(1)}%`;
                if (targetHealthBarElement.style.width !== newWidth) targetHealthBarElement.style.width = newWidth;

                let barColorVar = healthPercent > 65 ? '--color-success' : (healthPercent > 30 ? '--color-warning' : '--color-danger');
                try {
                    const colorValue = getComputedStyle(document.documentElement).getPropertyValue(barColorVar).trim();
                    if (targetHealthBarElement.style.backgroundColor !== colorValue) targetHealthBarElement.style.backgroundColor = colorValue;
                } catch(e) { /* Usar fallback si variable CSS falla */ }
                // TODO: Mostrar iconos de efectos de estado del objetivo aquí?

            } else { // Sin salud o muerto
                if (targetHealthContainer.style.display !== 'none') targetHealthContainer.style.display = 'none';
                if (targetHealthBarElement.style.width !== '0%') targetHealthBarElement.style.width = '0%';
            }

        } else { // Sin objetivo
            if (targetInfoPanel.style.display !== 'none') targetInfoPanel.style.display = 'none';
        }
    }
    updateTargetUI.warned = false; // Inicializar flag de advertencia

    function addItemToInventory(itemIdToAdd, quantity = 1) {
        if (typeof itemIdToAdd !== 'string' || !itemIdToAdd) { console.error("addItemToInventory: ID inválido:", itemIdToAdd); return false; }
        if (typeof quantity !== 'number' || !Number.isInteger(quantity) || quantity <= 0) { quantity = 1; }

        // Manejo especial para oro
        if (itemIdToAdd === 'gold_coin') {
            playerState.gold += quantity; updatePlayerUI();
            showFloatingText('xp-text', `+${quantity} Oro`, playerState.position.clone().add(new THREE.Vector3(0,1,0))); // Usar color XP para oro?
            return true;
        }

        const itemDef = itemDefinitions[itemIdToAdd];
        if (!itemDef) { console.error(`addItemToInventory: Definición no encontrada: ${itemIdToAdd}`); logMessage(`Error interno: Objeto desconocido (${itemIdToAdd})`, "error"); return false; }

        let remainingQuantity = quantity;

        if (itemDef.stackable) {
            const maxStack = itemDef.maxStack || 99;
            for (let i = 0; i < inventory.items.length && remainingQuantity > 0; i++) {
                const existingItem = inventory.items[i];
                if (existingItem.id === itemIdToAdd && existingItem.count < maxStack) {
                    const canAdd = maxStack - existingItem.count;
                    const amountToAdd = Math.min(remainingQuantity, canAdd);
                    existingItem.count += amountToAdd; remainingQuantity -= amountToAdd;
                }
            }
            while (remainingQuantity > 0) {
                if (inventory.items.length >= inventory.maxItems) { logMessage(`Inventario lleno. No se añadieron ${remainingQuantity} ${itemDef.name}.`, "warning"); showNotification("Inventario Lleno", "error"); updateInventoryUI(); return false; }
                const amountForNewStack = Math.min(remainingQuantity, maxStack);
                inventory.items.push({ ...itemDef, count: amountForNewStack }); // Añadir copia con count
                remainingQuantity -= amountForNewStack;
            }
        } else { // No apilable
            for (let i = 0; i < remainingQuantity; i++) {
                if (inventory.items.length >= inventory.maxItems) { const numNotAdded = remainingQuantity - i; logMessage(`Inventario lleno. No se añadieron ${numNotAdded} ${itemDef.name}.`, "warning"); showNotification("Inventario Lleno", "error"); updateInventoryUI(); return false; }
                inventory.items.push({ ...itemDef, count: 1 }); // Añadir copia individual
            }
            remainingQuantity = 0;
        }

        if (remainingQuantity <= 0) { updateInventoryUI(); return true; }
        else { console.error(`addItemToInventory: Inconsistencia - quedaron ${remainingQuantity} ${itemIdToAdd} sin añadir.`); updateInventoryUI(); return false; }
    }

    function openDialog(npcObject) {
        if (!npcObject?.userData?.npcType) { console.error("openDialog: Objeto inválido."); return; }
        if (gameState.isInDialog) { console.warn("Ya hay diálogo activo."); closeDialog(); }
        if (gameState.isGhost && npcObject.userData.npcType !== 'priest') { logMessage("Solo puedes hablar con sacerdotes.", "info"); return; }

        closeOtherModals(); // Cerrar otros paneles

        const dialogPanel = domCache['dialog-panel']; const npcIconElement = domCache['dialog-npc-icon'];
        const npcNameElement = domCache['dialog-npc-name']; const dialogTextElement = domCache['dialog-text'];
        const dialogOptionsContainer = domCache['dialog-options'];
        if (!dialogPanel || !npcIconElement || !npcNameElement || !dialogTextElement || !dialogOptionsContainer) { console.error("openDialog: Faltan elementos UI diálogo."); logMessage("Error interfaz diálogo.", "error"); return; }

        const npcType = npcObject.userData.npcType; const npcDefinition = npcDefinitions[npcType];
        const npcDisplayName = npcDefinition?.name || npcObject.userData.name || "Desconocido";
        const npcDisplayIcon = npcDefinition?.icon || 'fa-user';
        npcIconElement.className = `fas ${npcDisplayIcon}`; npcNameElement.textContent = npcDisplayName;

        if (!npcDefinition?.dialogues) { // Fallback si no hay diálogos definidos
            startDialogStep({ text: "(No tiene nada que decir)", options: [{ text: "Adiós.", action: "close" }] });
            dialogPanel.style.display = 'block'; gameState.isInDialog = true; gameState.currentDialogNPC = npcObject;
            gameState.currentDialogData = null; AudioManager.playSound('ui_open', 0.4); return;
        }

        // Determinar nodo inicial con condiciones
        let startingNodeKey = 'greeting'; let foundStartingNode = false;
        for (const key in npcDefinition.dialogues) { const node = npcDefinition.dialogues[key]; if (node.condition?.(npcObject, playerState)) { startingNodeKey = key; foundStartingNode = true; break; } }
        if (!foundStartingNode && !npcDefinition.dialogues['greeting']) { console.error(`Nodo 'greeting' o condicional no encontrado para ${npcType}`); startDialogStep({ text: "(Silencio)", options: [{ text: "Adiós.", action: "close" }] }); /* ... mostrar panel ... */ return; }

        const startingDialogData = npcDefinition.dialogues[startingNodeKey];
        if (!startingDialogData) { console.error(`Nodo inicial '${startingNodeKey}' no existe para ${npcType}`); closeDialog(); return; }

        gameState.isInDialog = true; gameState.currentDialogNPC = npcObject; gameState.currentDialogData = npcDefinition.dialogues;
        gameState.currentDialogueStep = 0; gameState.currentOfferedQuestId = null; gameState.isTyping = false; gameState.isProcessingOption = false;
        if(gameState.typingInterval) clearInterval(gameState.typingInterval); gameState.typingInterval = null;

        startDialogStep(startingDialogData); // Mostrar primer paso
        dialogPanel.style.display = 'block'; AudioManager.playSound('ui_open', 0.4);
    }

    function startDialogStep(dialogNode) {
        if (!dialogNode || typeof dialogNode.text !== 'string') { console.error("startDialogStep: Nodo inválido.", dialogNode); closeDialog(); return; }
        const dialogTextElement = domCache['dialog-text']; const dialogOptionsContainer = domCache['dialog-options'];
        if (!(dialogTextElement instanceof HTMLElement) || !(dialogOptionsContainer instanceof HTMLElement)) { console.error("startDialogStep: Elementos UI no encontrados."); closeDialog(); return; }

        dialogTextElement.innerHTML = ''; dialogOptionsContainer.innerHTML = ''; // Limpiar
        if (gameState.typingInterval) { clearInterval(gameState.typingInterval); gameState.typingInterval = null; }

        const fullText = dialogNode.text; let charIndex = 0; gameState.isTyping = true;
        gameState.typingInterval = setInterval(() => {
            if (charIndex < fullText.length) {
                dialogTextElement.innerHTML += fullText[charIndex];
                dialogTextElement.scrollTop = dialogTextElement.scrollHeight; charIndex++;
            } else {
                clearInterval(gameState.typingInterval); gameState.typingInterval = null; gameState.isTyping = false;
                displayDialogOptions(dialogNode.options); // Mostrar opciones al terminar
                if(dialogTextElement.onclick) dialogTextElement.onclick = null; // Limpiar listener de salto
            }
        }, DIALOG_TYPING_SPEED);

        // Listener para saltar tipeo
        dialogTextElement.onclick = () => {
            if (gameState.isTyping && gameState.typingInterval) {
                clearInterval(gameState.typingInterval); gameState.typingInterval = null; gameState.isTyping = false;
                dialogTextElement.innerHTML = fullText; displayDialogOptions(dialogNode.options);
                dialogTextElement.onclick = null;
            }
        };
    }

    /**
     * Muestra las opciones de diálogo disponibles para el nodo actual.
     * Filtra opciones según condiciones y añade una opción "Adiós" si es necesario.
     * @param {Array | undefined} optionsArray - Array de opciones del nodo de diálogo actual.
     */
    function displayDialogOptions(optionsArray) {
        const dialogOptionsContainer = domCache['dialog-options'];
        if (!(dialogOptionsContainer instanceof HTMLElement)) {
            console.error("displayDialogOptions: Contenedor de opciones no encontrado.");
            return;
        }
        dialogOptionsContainer.innerHTML = ''; // Limpiar opciones anteriores

        const availableOptions = [];
        const rawOptions = optionsArray || []; // Usar array vacío si no hay opciones definidas

        // 1. Filtrar opciones según condiciones
        rawOptions.forEach((option, index) => {
            let shouldDisplay = true;
            if (option.condition && typeof option.condition === 'function') {
                try {
                    shouldDisplay = option.condition(gameState.currentDialogNPC, playerState);
                } catch (e) {
                    console.error(`Error en condición opción [${index}] (${option.text}):`, e);
                    shouldDisplay = false; // No mostrar si la condición falla
                }
            }
            if (shouldDisplay) {
                availableOptions.push(option); // Añadir opción si cumple la condición
            }
        });

        // 2. Crear botones para opciones disponibles
        availableOptions.forEach((option) => {
            const optionElement = document.createElement('button');
            optionElement.className = 'dialog-option';
            optionElement.textContent = option.text || `Opción...`; // Texto fallback
            optionElement.addEventListener('click', () => {
                if (gameState.isProcessingOption) return; // Evitar doble click
                gameState.isProcessingOption = true;
                dialogOptionsContainer.innerHTML = ''; // Limpiar botones inmediatamente
                AudioManager.playSound('ui_confirm', 0.35);
                // Pequeño delay antes de procesar para feedback visual
                setTimeout(() => {
                    handleDialogAction(option); // Procesar la acción
                    gameState.isProcessingOption = false; // Desbloquear después de procesar
                }, 50);
            });
            dialogOptionsContainer.appendChild(optionElement);
        });

        // 3. *** Añadir Opción "Adiós" si es necesario ***
        // Añadirla si:
        //   a) No se mostró NINGUNA otra opción (availableOptions está vacío)
        //   b) O si la ÚNICA opción mostrada NO tiene una acción que cierre el diálogo por sí misma
        //      (Ej: 'acceptQuest' o 'customAction' que no llamen a closeDialog internamente)
        const nonClosingActions = ['acceptQuest', 'customAction']; // Acciones que NO cierran el diálogo por defecto
        const lastOptionAction = availableOptions.length === 1 ? availableOptions[0].action : null;

        // Verifica si NO hay opciones, O si la única opción NO es una acción de cierre explícito o de navegación
        const needsCloseOption = availableOptions.length === 0 ||
                                (availableOptions.length > 0 && !availableOptions.some(opt => opt.action === 'close' || opt.action === 'nextDialog' || opt.action === 'openShop'));


        if (needsCloseOption) {
            // Evitar añadir "Adiós" si ya existe una opción con action: "close" (aunque su condition haya fallado)
            const alreadyHasCloseAction = rawOptions.some(opt => opt.action === 'close');

            if (!alreadyHasCloseAction || availableOptions.length === 0) { // Añadir si no hay otras o si ninguna cierra
                const closeOptionElement = document.createElement('button');
                closeOptionElement.className = 'dialog-option';
                closeOptionElement.textContent = "Adiós.";
                closeOptionElement.addEventListener('click', () => {
                    // No necesitamos el bloqueo isProcessingOption aquí, closeDialog lo maneja
                    closeDialog();
                });
                dialogOptionsContainer.appendChild(closeOptionElement);
            }
        }
    }
    
    
    
/**
 * Procesa la acción seleccionada por el jugador en un diálogo.
 * Navega a otros diálogos, abre tiendas, acepta/completa misiones, etc.
 * NO cierra el diálogo automáticamente para la mayoría de acciones.
 * @param {object} selectedOption - La opción de diálogo seleccionada.
 */
function handleDialogAction(selectedOption) {
    const action = selectedOption.action;
    const npc = gameState.currentDialogNPC;
    console.log(`Dialog action: ${action}`, selectedOption); // DEBUG

    switch (action) {
        case 'close':
            closeDialog(); // Cerrar explícitamente
            break;
        case 'nextDialog':
            // Navegar a otro nodo, SIN CERRAR
            if (selectedOption.nextDialog && gameState.currentDialogData?.[selectedOption.nextDialog]) {
                startDialogStep(gameState.currentDialogData[selectedOption.nextDialog]);
            } else {
                console.error(`Nodo siguiente "${selectedOption.nextDialog}" no encontrado.`);
                // Si no se encuentra el siguiente nodo, AHORA sí cerramos como fallback
                closeDialog();
            }
            break;
        case 'openShop':
            // Abrir tienda implica cerrar el diálogo actual ANTES
            if (npc?.userData) { // Comprobar si hay NPC
                 closeDialog(); // Cerrar diálogo primero
                 openShop(npc); // Luego intentar abrir tienda
            } else {
                 console.error("No NPC associated with dialog to open shop.");
                 closeDialog(); // Cerrar si no hay NPC
            }
            break;
        case 'acceptQuest':
            // Aceptar quest, SIN CERRAR DIÁLOGO (mostrará mensaje/opción Adiós)
            if (selectedOption.questId) {
                acceptQuest(selectedOption.questId, npc);
                // NO LLAMAR a closeDialog() aquí.
                // El nodo de diálogo debería idealmente tener una opción "Adiós"
                // o la función displayDialogOptions añadirá una.
            } else {
                console.error("Falta questId para 'acceptQuest'.");
                closeDialog(); // Cerrar si hay error
            }
            break;
        case 'completeQuest':
            // Completar quest, SIN CERRAR DIÁLOGO si hay un diálogo posterior definido
            if (selectedOption.questId) {
                completeQuest(selectedOption.questId, npc); // completeQuest maneja si se cierra o se va a otro nodo
            } else {
                console.error("Falta questId para 'completeQuest'.");
                closeDialog(); // Cerrar si hay error
            }
            break;
        case 'revivePlayer':
            // Revivir implica cerrar el diálogo
            if (gameState.isGhost && npc?.userData?.npcType === 'priest') {
                 closeDialog();
                 revivePlayer();
            } else {
                 closeDialog(); // Cerrar aunque no reviva
            }
            break;
        case 'customAction':
            // Acción custom, SIN CERRAR DIÁLOGO por defecto. La función custom debe decidir si cerrar.
            if (selectedOption.functionName && typeof window[selectedOption.functionName] === 'function') {
                try {
                    window[selectedOption.functionName](npc, selectedOption.params);
                    // NO llamar a closeDialog() aquí. La función llamada (healPlayerForGold) lo hará si es necesario.
                } catch(e) {
                    console.error(`Error en customAction '${selectedOption.functionName}':`, e);
                    closeDialog(); // Cerrar en caso de error
                }
            } else {
                console.error(`Función customAction '${selectedOption.functionName}' no encontrada.`);
                closeDialog(); // Cerrar si no se encuentra la función
            }
            break;
        default:
            console.warn(`Acción diálogo no reconocida: ${action}`);
            closeDialog(); // Cerrar por defecto para acciones desconocidas
            break;
    }
}    
    
    
function closeDialog() {
        const dialogPanel = domCache['dialog-panel'];
        // Solo proceder si el diálogo está activo lógicamente
        if (!gameState.isInDialog) return;

        if (!(dialogPanel instanceof HTMLElement)) {
            if (domCache.hasOwnProperty('dialog-panel') && domCache['dialog-panel'] !== null) {
                 console.warn("closeDialog: Panel de diálogo (#dialog-panel) no encontrado en caché al intentar cerrar.");
            }
            // Resetear estado lógico de todos modos
        } else {
            dialogPanel.style.display = 'none'; // Ocultar panel
            // Limpiar contenido interno por seguridad
            const dialogTextElem = domCache['dialog-text'];
            const dialogOptionsElem = domCache['dialog-options'];
            if (dialogTextElem instanceof HTMLElement) dialogTextElem.innerHTML = '';
            if (dialogOptionsElem instanceof HTMLElement) dialogOptionsElem.innerHTML = '';
        }

        // Limpiar intervalo de tipeo si existe
        if (gameState.typingInterval) { clearInterval(gameState.typingInterval); gameState.typingInterval = null; }

        // Resetear estado global
        gameState.isInDialog = false;
        gameState.currentDialogNPC = null;
        gameState.currentDialogData = null;
        gameState.currentDialogueStep = 0;
        gameState.isTyping = false;
        gameState.currentOfferedQuestId = null;
        gameState.isProcessingOption = false; // Asegurar que se desbloquee

        AudioManager?.playSound('ui_close', 0.4);
        // console.log("Diálogo cerrado."); // Reduce spam
    }

    /**
     * Verifica si el jugador tiene actualmente una misión activa con el ID especificado.
     * @param {string} questId - El ID de la misión a verificar.
     * @returns {boolean} - True si la misión está activa, false en caso contrario.
     */
    function hasQuest(questId) {
        if (!quests?.active) return false; // Check if active quests array exists
        return quests.active.some(activeQuest => activeQuest && activeQuest.id === questId); // Check if quest object itself is valid
    }

    /**
     * Verifica si el jugador ha completado todos los objetivos de una misión activa específica.
     * @param {string} questId - El ID de la misión activa a verificar.
     * @returns {boolean} - True si la misión está activa y todos sus objetivos están completos, false en caso contrario.
     */
    function canCompleteQuest(questId) {
        if (!quests?.active) return false;
        const activeQuest = quests.active.find(q => q && q.id === questId);
        if (!activeQuest) return false; // No activa

        const questDef = questDefinitions[questId];
        if (!questDef?.objectives || questDef.objectives.length === 0) {
            // Si no hay objetivos definidos, se considera completable si está activa? O no?
            // Por seguridad, diremos que no se puede completar si no hay objetivos definidos.
            console.warn(`canCompleteQuest: Quest ${questId} activa pero sin objetivos definidos.`);
            return false;
        }

        // Verificar si CADA objetivo definido está completo
        return questDef.objectives.every((objDef, index) => {
            const currentObjectiveState = activeQuest.objectives?.find(o => o && ((o.id && o.id === objDef.id) || (o.type === objDef.type && o.target === objDef.target))) || activeQuest.objectives?.[index];
            if (!currentObjectiveState) {
                console.warn(`canCompleteQuest: Estado no encontrado para objetivo ${index} de ${questId}.`);
                return false; // Falta estado del objetivo
            }
            const currentCount = currentObjectiveState.current || 0;
            const targetCount = objDef.count || 1;
            return currentCount >= targetCount;
        });
    }

    /**
     * Verifica si el jugador ha completado previamente una misión con el ID especificado.
     * @param {string} questId - El ID de la misión a verificar.
     * @returns {boolean} - True si la misión está en la lista de completadas, false en caso contrario.
     */
    function isQuestCompleted(questId) {
        if (!quests?.completed) return false;
        // Asumiendo que quests.completed es un array de IDs
        return quests.completed.includes(questId);
    }

    function acceptQuest(questId, giver = null) {
        if (hasQuest(questId) || isQuestCompleted(questId)) { logMessage("Ya tienes o completaste esta misión.", "warning"); return; }
        const questDef = questDefinitions[questId];
        if (!questDef) { logMessage("Error: Misión desconocida.", "error"); return; }

        // Comprobar requisitos de nivel/clase de la misión
        if (questDef.requirements?.level && playerState.level < questDef.requirements.level) { logMessage(`Nivel ${questDef.requirements.level} requerido para esta misión.`, "warning"); AudioManager.playSound('ui_error', 0.4); return; }
        if (questDef.classRequirement && !questDef.classRequirement.includes(playerState.class)) { logMessage(`Esta misión no es para tu clase (${playerState.class}).`, "warning"); AudioManager.playSound('ui_error', 0.4); return; }

        const newActiveQuest = {
            id: questId,
            objectives: (questDef.objectives || []).map(objDef => ({
                ...(objDef.id && { id: objDef.id }), // Incluir ID si existe
                type: objDef.type, target: objDef.target, count: objDef.count || 1,
                description: objDef.description, current: 0 // Inicializar progreso a 0
            }))
        };
        quests.active.push(newActiveQuest);
        logMessage(`Nueva misión aceptada: ${questDef.name}`, "quest");
        showNotification(`Misión aceptada: ${questDef.name}`, "quest");
        AudioManager.playSound('quest_accept', 0.6);
        updateQuestLog(); updateQuestTrackerUI(); updateNPCMarkers(); // Actualizar UIs relevantes
    }

    function completeQuest(questId, giver = null) {
        const questIndex = quests.active.findIndex(q => q && q.id === questId);
        if (questIndex === -1) { logMessage("No tienes esa misión activa.", "warning"); return; }
        const questDef = questDefinitions[questId]; if (!questDef) { logMessage("Error: Misión desconocida.", "error"); return; }

        if (!canCompleteQuest(questId)) { logMessage("Aún no completaste los objetivos.", "warning"); AudioManager.playSound('ui_error', 0.4); closeDialog(); return; }

        const completedQuestData = quests.active[questIndex];

        // --- Otorgar Recompensas ---
        if (questDef.rewards) {
            const rewards = questDef.rewards; let rewardTextParts = [];
            if (rewards.xp) { gainExperience(rewards.xp); rewardTextParts.push(`${rewards.xp} XP`); }
            if (rewards.gold) { addItemToInventory('gold_coin', rewards.gold); rewardTextParts.push(`${rewards.gold} Oro`); }
            if (rewards.items) {
                rewards.items.forEach(itemString => { const p=itemString.split(':'); const id=p[0]; const c=p.length>1?parseInt(p[1],10):1; if(!isNaN(c)&&c>0){const added=addItemToInventory(id, c); const n=getItemName(id); rewardTextParts.push(`${n}${c>1?` x${c}`:''}${!added?'(Inv. Lleno)':''}`);} });
            }
            if (rewards.recipes && questDef.onCompleteGrantRecipes) {
                 let recipesLearnedCount = 0;
                 rewards.recipes.forEach(recipeId => { if (!playerState.knownRecipes.includes(recipeId)) { playerState.knownRecipes.push(recipeId); recipesLearnedCount++; } });
                 if (recipesLearnedCount > 0) { rewardTextParts.push(`${recipesLearnedCount} Receta(s)`); logMessage(`Aprendiste ${recipesLearnedCount} nueva(s) receta(s).`, "success"); if(domCache['crafting-modal']?.style.display!=='none') updateCraftingUI(); }
            }
            if (rewardTextParts.length > 0) logMessage("Recompensas: " + rewardTextParts.join(', '), "loot");
        }

        // --- Actualizar Estado Misiones ---
        quests.active.splice(questIndex, 1); // Eliminar de activas
        if (!quests.completed.includes(questId)) quests.completed.push(questId); // Añadir a completadas (solo ID)
        if (playerState.trackedQuestId === questId) playerState.trackedQuestId = null; // Dejar de trackear

        logMessage(`Misión completada: ${questDef.name}`, "quest");
        showNotification(`Misión completada: ${questDef.name}`, "success");
        AudioManager.playSound('quest_complete', 0.7);

        // Actualizar UIs
        updateQuestLog(); updateQuestTrackerUI(); updatePlayerUI(); updateNPCMarkers();

        // --- Diálogo Siguiente? ---
        const npcData = giver ? npcDefinitions[giver.userData.npcType] : null;
        const postCompleteDialogKey = questDef.completeDialog || 'greeting_completed';
        if (gameState.isInDialog && npcData?.dialogues?.[postCompleteDialogKey]) {
             startDialogStep(npcData.dialogues[postCompleteDialogKey]);
        } else { closeDialog(); }
    }

    function updateQuestObjectives(type, targetId, amount = 1) {
        if (!quests?.active) return; let objectiveUpdated = false;
        quests.active.forEach(activeQuest => {
            if(!activeQuest) return; // Skip null entries if any
            const questDef = questDefinitions[activeQuest.id];
            if (!questDef?.objectives) return;

            questDef.objectives.forEach((objDef, index) => {
                const currentObjectiveState = activeQuest.objectives?.find(o => o && ((o.id && o.id === objDef.id) || (o.type === objDef.type && o.target === objDef.target))) || activeQuest.objectives?.[index];
                if (!currentObjectiveState) return;
                const targetCount = objDef.count || 1;

                if (objDef.type === type && objDef.target === targetId && currentObjectiveState.current < targetCount) {
                    const prevCount = currentObjectiveState.current;
                    currentObjectiveState.current = Math.min(targetCount, prevCount + amount);
                    if (currentObjectiveState.current > prevCount) {
                        objectiveUpdated = true;
                        logMessage(`Progreso [${questDef.name}]: ${objDef.description || getObjectiveText(objDef)} (${currentObjectiveState.current}/${targetCount}).`, "quest");
                        AudioManager.playSound('quest_objective', 0.55);
                        if (canCompleteQuest(activeQuest.id)) {
                            logMessage(`¡Objetivos de "${questDef.name}" completados!`, "success");
                            showNotification(`Objetivos Completados: ${questDef.name}`, "quest");
                            updateNPCMarkers(); // Actualizar '!' si se puede entregar
                        }
                    }
                }
            });
        });

        if (objectiveUpdated) {
            if(domCache['quests-modal']?.style.display !== 'none') updateQuestLog();
            if(playerState.trackedQuestId && quests.active.some(q=>q.id === playerState.trackedQuestId)) updateQuestTrackerUI();
        }
    }

    function saveGame() {
        // Prevent saving if not playing/paused, or still loading
        if ((!gameState.isPlaying && !gameState.isPaused) || gameState.isLoading || gameState.isGhost) {
            logMessage("No se puede guardar ahora.", "warning");
            return;
        }
        console.log("Iniciando guardado (vFix Structure)...");
        try {
            // --- Prepare Player State (without skills/recipes here) ---
            const playerStateToSave = {
                name: playerState.name,
                race: playerState.race,
                gender: playerState.gender,
                class: playerState.class,
                level: playerState.level,
                xp: playerState.xp,
                xpToNextLevel: playerState.xpToNextLevel,
                gold: playerState.gold,
                attributePoints: playerState.attributePoints,
                skillPoints: playerState.skillPoints,
                attributes: { ...playerState.attributes },
                stats: {
                    health: playerState.stats.health,
                    mana: playerState.stats.mana,
                    stamina: playerState.stats.stamina
                },
                position: {
                    x: playerState.position.x,
                    y: playerState.position.y,
                    z: playerState.position.z
                },
                rotationY: playerState.rotationY,
                equipment: Object.entries(playerState.equipment).reduce((acc, [slot, item]) => {
                    acc[slot] = item ? { id: item.id } : null;
                    return acc;
                }, {}),
                statusEffects: [], // Not saving temporary effects
                // *** REMOVED skills and assignedSkillPoints from here ***
                trackedQuestId: playerState.trackedQuestId,
                actionSlots: playerState.actionSlots || new Array(4).fill(null),
                lastWorldPosition: playerState.lastWorldPosition ? {x: playerState.lastWorldPosition.x, y: playerState.lastWorldPosition.y, z: playerState.lastWorldPosition.z} : null,
                lastWorldRotationY: playerState.lastWorldRotationY,
                currentLocation: gameState.currentLocation,
                 // *** REMOVED knownRecipes from here ***
            };

            // --- Prepare Skills Data for Root Level ---
            const skillsToSave = {};
            for (const skillId in playerState.skills) {
                const skillData = playerState.skills[skillId];
                if (skillData) {
                    skillsToSave[skillId] = {
                        level: skillData.level || 1,
                        xp: skillData.xp || 0,
                        xpToNext: skillData.xpToNext || calculateSkillXPForLevel(skillId, (skillData.level || 1) + 1)
                    };
                }
            }

            // --- Prepare TOP-LEVEL Save Data ---
            const saveData = {
                version: VERSION,
                saveTimestamp: Date.now(),
                gameTime: gameState.gameTime,
                timeOfDay: gameState.timeOfDay,
                worldSeed: worldSeed,

                playerState: playerStateToSave, // Player state *without* skills/recipes

                // *** ADD skills, assignedSkillPoints, and knownRecipes at the ROOT level ***
                skills: skillsToSave,
                assignedSkillPoints: playerState.assignedSkillPoints || {}, // Use the separate tracker
                knownRecipes: [...(playerState.knownRecipes || [])],
                // *********************************************************************

                inventory: inventory.items.map(item => (item ? { id: item.id, count: item.count || 1 } : null)).filter(i => i),
                spells: spells.known.map(spell => (spell ? {
                    id: spell.id,
                    ...(spell.cooldownRemaining > 50 && { cooldownRemaining: Math.round(spell.cooldownRemaining) })
                 } : null)).filter(s => s),
                quests: {
                    active: quests.active.map(q => q ? {
                        id: q.id,
                        objectives: q.objectives?.map(o => o ? {
                            type: o.type, target: o.target, id: o.id, current: o.current || 0
                        } : null).filter(o=>o) || []
                    } : null).filter(q => q),
                    completed: [...quests.completed]
                },
                worldState: {
                    openedChests: Array.from(world.worldStateData.openedChests || []),
                    depletedNodes: { ...(world.worldStateData.depletedNodes || {}) },
                    leverStates: { ...(world.worldStateData.leverStates || {}) },
                }
            };

            // --- Perform Save ---
            const jsonData = JSON.stringify(saveData);
            localStorage.setItem('eldravar_save', jsonData);
            gameState.lastSaveTime = gameState.gameTime;

            // --- Feedback ---
            logMessage("Partida guardada.", "success");
            showNotification("Partida Guardada", "success", 2500);
            AudioManager.playSound('ui_confirm', 0.5);
            const continueButton = domCache["continue-button"];
            if (continueButton instanceof HTMLElement) {
                continueButton.disabled = false;
                continueButton.classList.remove('disabled');
            }
            console.log("Guardado completado.", (jsonData.length / 1024).toFixed(2), "KB");

        } catch (error) {
            console.error("¡Error Fatal al guardar!", error);
            logMessage("Error crítico al guardar.", "error");
            showNotification("¡Error al Guardar!", "error");
            AudioManager.playSound('ui_error', 0.6);
        }
    }

    
    async function loadGame() {
        const functionName = "loadGame (vAsync DEBUG)";
        console.log(`--- ${functionName}: Initiating Load ---`);
        const savedDataString = localStorage.getItem('eldravar_save');
        const startScreen = domCache["start-screen"];
        const loadingScreen = domCache["loading-screen"];
        const charCreation = domCache["character-creation"];
        const continueButton = domCache["continue-button"];

        const displayStartScreen = () => { /* ... (helper function as before) ... */ if (startScreen instanceof HTMLElement) startScreen.style.display = "flex"; if (loadingScreen instanceof HTMLElement) loadingScreen.style.display = "none"; if (charCreation instanceof HTMLElement) charCreation.style.display = "none"; if (continueButton instanceof HTMLElement) { const hasSave = !!localStorage.getItem('eldravar_save'); continueButton.disabled = !hasSave; continueButton.classList.toggle('disabled', !hasSave); } };

        if (!savedDataString) { console.log(`[${functionName}] No save data found.`); logMessage("No hay partida guardada.", 'warning'); showNotification("No hay partida guardada", "warning"); AudioManager.playSound('ui_error', 0.4); displayStartScreen(); return; }

        let saveData;
        try {
            console.log(`[${functionName}] Parsing saved data string...`);
            saveData = JSON.parse(savedDataString);
            console.log(`[${functionName}] Parsing successful.`);
        } catch (error) { console.error(`[${functionName}] Error parsing saved data:`, error); logMessage("Error: Datos guardados corruptos.", 'error'); showNotification("Error: Datos corruptos", "error"); localStorage.removeItem('eldravar_save'); displayStartScreen(); return; }
        if (!saveData || typeof saveData !== 'object') { console.log(`[${functionName}] Invalid save data format.`); logMessage("Error: Formato guardado inválido.", 'error'); displayStartScreen(); return; }

        // Validation (Basic Keys)
        const essentialKeys = ['version', 'playerState', 'inventory', 'quests', 'worldState', 'gameTime', 'timeOfDay', 'spells', 'skills', 'knownRecipes'];
        const missingKeys = essentialKeys.filter(key => { const parts = key.split('.'); let current = saveData; for(const part of parts){ if(current === undefined || current === null || !current.hasOwnProperty(part)) return true; current = current[part]; } return false; });
        if (missingKeys.length > 0) { console.log(`[${functionName}] Missing essential keys: ${missingKeys.join(', ')}`); logMessage(`Error carga: Faltan datos (${missingKeys.join(', ')}).`, 'error'); showNotification("Error carga: Datos incompletos", "error"); displayStartScreen(); return; }
        console.log(`[${functionName}] Essential keys validation passed.`);

        // Version Check
        if (saveData.version !== VERSION) { /* ... (version mismatch logic - same as before) ... */ const confirmLoad = confirm(`Guardado v${saveData.version}, Juego v${VERSION}.\nCargar puede causar errores.\n¿Continuar?`); if (!confirmLoad) { logMessage("Carga cancelada por versión.", "warning"); displayStartScreen(); return; } logMessage("Cargando partida de versión diferente.", "warning"); }

        // --- Start Loading Process ---
        console.log(`[${functionName}] Hiding start screen, showing loading screen.`);
        if (startScreen instanceof HTMLElement) startScreen.style.display = "none";
        showLoadingScreen();
        updateLoadingProgress(5, "Cargando datos guardados...");

        try {
            // --- 1. Apply World Seed ---
            console.log(`[${functionName}] Checking world seed...`);
            if (saveData.worldSeed && typeof SimplexNoise === 'function') {
                // ... (re-init noise generators - same as before) ...
                console.log(`[${functionName}] Applied world seed: ${saveData.worldSeed}`);
                worldSeed = saveData.worldSeed;
                simplex = new SimplexNoise(worldSeed); simplexHeight = new SimplexNoise(worldSeed + 1); simplexBiomes = new SimplexNoise(worldSeed + 2); simplexObjects = new SimplexNoise(worldSeed + 3); simplexRivers = new SimplexNoise(worldSeed + 6); simplexDetails = new SimplexNoise(worldSeed + 7); biomeNoise = simplexBiomes; tempNoise = new SimplexNoise(worldSeed + 4); moistureNoise = new SimplexNoise(worldSeed + 5);
            } else {
                console.log(`[${functionName}] Using default world seed.`);
            }

            // --- 2. Apply Core Game State ---
            console.log(`[${functionName}] Applying core game state...`);
            gameState.gameTime = saveData.gameTime || 0;
            gameState.timeOfDay = saveData.timeOfDay || 0.25;
            gameState.isLoading = true; gameState.isPlaying = false; gameState.isPaused = false; gameState.isGameOver = false;
            gameState.currentLocation = saveData.playerState?.currentLocation || 'world';
            console.log(`[${functionName}] Core game state applied. Location: ${gameState.currentLocation}`);

            // --- 3. Apply World State ---
            console.log(`[${functionName}] Applying world state...`);
            world.worldStateData.openedChests = new Set(saveData.worldState?.openedChests || []);
            world.worldStateData.depletedNodes = saveData.worldState?.depletedNodes || {};
            world.worldStateData.leverStates = saveData.worldState?.leverStates || {};
            console.log(`[${functionName}] World state applied. Chests: ${world.worldStateData.openedChests.size}, Nodes: ${Object.keys(world.worldStateData.depletedNodes).length}`);

            updateLoadingProgress(15, "Restaurando estado del mundo...");

            // --- 4. Apply Player State ---
            console.log(`[${functionName}] Applying player state...`);
            const loadedPlayerState = saveData.playerState;
            // ... (apply name, class, level, xp, gold, points, attributes - same as before) ...
            playerState.name = loadedPlayerState.name || "Héroe"; playerState.race = loadedPlayerState.race || 'human'; playerState.gender = loadedPlayerState.gender || 'male'; playerState.class = loadedPlayerState.class || "warrior"; playerState.level = loadedPlayerState.level || 1; playerState.xp = loadedPlayerState.xp || 0; playerState.xpToNextLevel = loadedPlayerState.xpToNextLevel || calculateXPForLevel(playerState.level + 1); playerState.gold = loadedPlayerState.gold || 0; playerState.attributePoints = loadedPlayerState.attributePoints || 0; playerState.skillPoints = loadedPlayerState.skillPoints || 0; playerState.attributes = loadedPlayerState.attributes || { strength: 10, dexterity: 10, intelligence: 10, constitution: 10 };
            playerState.stats = { ...(playerState.stats || {}), ...(loadedPlayerState.stats || {}) };
            // Restore Position
            if (loadedPlayerState.position) { playerState.position = new THREE.Vector3(loadedPlayerState.position.x, loadedPlayerState.position.y, loadedPlayerState.position.z); } else { playerState.position.copy(RESPAWN_POINT); }
            playerState.rotationY = loadedPlayerState.rotationY || Math.PI; playerState.velocity.set(0, 0, 0); playerState.onGround = false;
            // Restore last world pos
            playerState.lastWorldPosition = loadedPlayerState.lastWorldPosition ? new THREE.Vector3(loadedPlayerState.lastWorldPosition.x, loadedPlayerState.lastWorldPosition.y, loadedPlayerState.lastWorldPosition.z) : null;
            playerState.lastWorldRotationY = loadedPlayerState.lastWorldRotationY;
            // Reconstruct Equipment
            playerState.equipment = {}; for (const slot in loadedPlayerState.equipment) { const itemInfo = loadedPlayerState.equipment[slot]; if(itemInfo?.id && itemDefinitions[itemInfo.id]){ playerState.equipment[slot] = { ...itemDefinitions[itemInfo.id], id: itemInfo.id, count: 1 }; } else { playerState.equipment[slot] = null; } }
            // Restore Skills & Assigned Points
            playerState.skills = {}; playerState.assignedSkillPoints = loadedPlayerState.assignedSkillPoints || {};
            for (const skillId in loadedPlayerState.skills) { /* ... (apply saved skill data) ... */ const savedSkill = loadedPlayerState.skills[skillId]; if (savedSkill && skillDefinitions[skillId]) { playerState.skills[skillId] = { level: savedSkill.level || 1, xp: savedSkill.xp || 0, xpToNext: savedSkill.xpToNext || calculateSkillXPForLevel(skillId, (savedSkill.level || 1) + 1), }; } }
            Object.keys(skillDefinitions).forEach(skillId => { /* ... (ensure all skills exist, apply assigned points logic) ... */ if (!playerState.skills[skillId]) { playerState.skills[skillId] = { level: 1, xp: 0, xpToNext: calculateSkillXPForLevel(skillId, 2) }; } if (playerState.assignedSkillPoints[skillId] === undefined) { playerState.assignedSkillPoints[skillId] = 0; } playerState.skills[skillId].level = Math.max(playerState.skills[skillId].level, playerState.assignedSkillPoints[skillId]); playerState.skills[skillId].level = Math.min(100, playerState.skills[skillId].level); });
            // Restore Other Player Data
            playerState.knownRecipes = Array.isArray(loadedPlayerState.knownRecipes) ? [...loadedPlayerState.knownRecipes] : [];
            playerState.trackedQuestId = loadedPlayerState.trackedQuestId || null;
            playerState.actionSlots = Array.isArray(loadedPlayerState.actionSlots) ? [...loadedPlayerState.actionSlots] : new Array(4).fill(null);
            playerState.actionSlots = playerState.actionSlots.map(slot => (slot && slot.type && slot.id) ? slot : null).slice(0, 4);
             while(playerState.actionSlots.length < 4) playerState.actionSlots.push(null); // Ensure 4 slots


            console.log(`[${functionName}] Player state applied. Name: ${playerState.name}, Level: ${playerState.level}`);

            // --- 5. Apply Inventory ---
            console.log(`[${functionName}] Applying inventory...`);
            inventory.items = (saveData.inventory || []).map(savedItem => { const def = itemDefinitions[savedItem.id]; if (!def) { console.warn(`Def not found for inv item ${savedItem.id}`); return null; } const newItem = { ...def, id: savedItem.id, count: savedItem.count || 1 }; if (newItem.count === undefined || newItem.count <= 0) newItem.count = 1; return newItem; }).filter(item => item !== null);
            inventory.selectedItemIndex = null;
            console.log(`[${functionName}] Inventory applied. Count: ${inventory.items.length}`);

            // --- 6. Apply Spells ---
            console.log(`[${functionName}] Applying spells...`);
            spells.known = (saveData.spells || []).map(savedSpell => { const def = spellDefinitions[savedSpell.id]; if (!def) { console.warn(`Def not found for spell ${savedSpell.id}`); return null; } return { ...def, id: savedSpell.id, cooldownRemaining: savedSpell.cooldownRemaining || 0 }; }).filter(spell => spell !== null);
            spells.selectedSpellIndex = null;
            console.log(`[${functionName}] Spells applied. Count: ${spells.known.length}`);

            // --- 7. Apply Quests ---
            console.log(`[${functionName}] Applying quests...`);
            quests.completed = Array.isArray(saveData.quests?.completed) ? [...saveData.quests.completed] : [];
            quests.active = (saveData.quests?.active || []).map(savedQuest => { const qDef = questDefinitions[savedQuest.id]; if(!qDef) { console.warn(`Def not found for active quest ${savedQuest.id}`); return null; } const objectives = (qDef.objectives || []).map((objDef, index) => { const savedState = savedQuest.objectives?.find(o => o && ((o.id && o.id === objDef.id) || (o.type === objDef.type && o.target === objDef.target))) || savedQuest.objectives?.[index]; return { ...objDef, current: savedState?.current || 0 }; }); return { id: savedQuest.id, objectives }; }).filter(q => q);
            console.log(`[${functionName}] Quests applied. Active: ${quests.active.length}, Completed: ${quests.completed.length}`);

            updateLoadingProgress(45, "Consultando el destino...");

            // --- 8. Recalculate Player Stats ---
            console.log(`[${functionName}] Recalculating final player stats...`);
            updatePlayerStats();
            // Adjust current stats based on loaded values
            const finalLoadedHealth = loadedPlayerState.stats?.health ?? playerState.stats.maxHealth;
            const finalLoadedMana = loadedPlayerState.stats?.mana ?? playerState.stats.maxMana;
            const finalLoadedStamina = loadedPlayerState.stats?.stamina ?? playerState.stats.maxStamina;
            playerState.stats.health = Math.min(finalLoadedHealth, playerState.stats.maxHealth);
            playerState.stats.mana = Math.min(finalLoadedMana, playerState.stats.maxMana);
            playerState.stats.stamina = Math.min(finalLoadedStamina, playerState.stats.maxStamina);
            console.log(`[${functionName}] Final stats adjusted. Health: ${playerState.stats.health}/${playerState.stats.maxHealth}`);

            // Determine Ghost State
            gameState.isGhost = playerState.stats.health <= 0;
            playerState.statusEffects = gameState.isGhost ? [{ id: 'ghost', name: 'Fantasma', icon: 'fa-ghost', duration: Infinity, class: 'status-ghost', description: 'Busca un sacerdote.' }] : []; // Reset effects on load (except ghost)
            updateStatusEffectsUI();
            console.log(`[${functionName}] Ghost state determined: ${gameState.isGhost}`);

            updateLoadingProgress(55, "Reconstruyendo al héroe...");

            // --- 9. Setup Scene Content (Creates player model, NPCs etc) ---
            console.log(`[${functionName}] Calling setupSceneContent...`);
            await setupSceneContent(); // Uses loaded playerState.race/gender now
            console.log(`[${functionName}] setupSceneContent FINISHED.`);

            // --- 10. Position Player Model and Adjust Camera ---
            console.log(`[${functionName}] Positioning player model and camera...`);
            if (!playerModel) { throw new Error("Player model was not created by setupSceneContent during load."); }
            const finalTerrainHeight = ChunkManager.getTerrainHeightAt(playerState.position.x, playerState.position.z);
            playerState.position.y = finalTerrainHeight + PLAYER_HALF_HEIGHT; // Adjust Y AFTER terrain might be ready
            playerModel.position.copy(playerState.position);
            playerModel.rotation.y = playerState.rotationY;
            updatePlayerAppearance(); // Apply visual equipment
            if(gameState.isGhost) { /* Apply ghost visual effect */ const healthBar = domCache['health-bar']; if(healthBar) healthBar.classList.add('ghost-mode'); }
            console.log(`[${functionName}] Player model position final: Y=${playerModel.position.y.toFixed(2)}`);

            if (camera && orbitControls) { /* ... (set camera position/target - same as before) ... */ orbitControls.target.copy(playerState.position).add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.9, 0)); const initialOffset = cameraOffset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), playerState.rotationY); camera.position.copy(playerState.position).add(initialOffset); camera.lookAt(orbitControls.target); updateCameraPosition(0.016); orbitControls.update(); }
            console.log(`[${functionName}] Camera positioned.`);

            updateLoadingProgress(70, "Despertando el mundo...");

            // --- 11. Load Initial Chunks Around Player ---
            console.log(`[${functionName}] Calling preloadInitialChunks...`);
            await preloadInitialChunks(updateLoadingProgress, 70, 25);
            console.log(`[${functionName}] preloadInitialChunks FINISHED.`);

            // --- 12. Schedule Resource Respawns ---
            console.log(`[${functionName}] Scheduling resource respawns...`);
            scheduleResourceRespawnsFromLoad();
            console.log(`[${functionName}] Resource respawns scheduled.`);

            // --- 13. Final UI Updates and State Setting ---
            console.log(`[${functionName}] Final UI updates...`);
            updateLoadingProgress(98, "Pulido final...");
            // Call UI updates AFTER scene/chunks are more likely set up
            updatePlayerUI(); updateInventoryUI(); updateEquipmentUI(); updateQuestLog();
            updateSpellsUI(); updateSkillsUI(); updateCraftingUI();
            updateMinimap(); updateActionSlotsUI(); updateQuestTrackerUI();
            updateTargetUI(); updateNPCMarkers();
            console.log(`[${functionName}] UI update calls finished.`);

            gameState.isPlaying = true;
            gameState.isLoading = false;
            gameState.lastSaveTime = gameState.gameTime; // Update last save time
            closeOtherModals();
            updateLoadingProgress(100, "¡Aventura lista!");

            // --- 14. Hide Loading, Show Game UI, Start Loop ---
            console.log(`[${functionName}] Scheduling game start timeout...`);
            setTimeout(() => {
                console.log(`[${functionName}] Timeout executing. Hiding loading, showing UI...`);
                hideLoadingScreen();
                showGameUI();
                if (gameState.isGhost) {
                    console.log(`[${functionName}] Starting GHOST loop.`);
                    startGhostLoop();
                } else {
                    console.log(`[${functionName}] Starting NORMAL game loop.`);
                    startGameLoop();
                }
                logMessage("Partida cargada correctamente.", 'system');
                showNotification("Partida cargada", "info");
                AudioManager.updateMusic();
                console.log(`[${functionName}] Load game process fully completed.`);
            }, 250);

        } catch (error) {
            console.error(`[${functionName}] ¡ERROR CRÍTICO DURANTE LA CARGA!:`, error);
            hideLoadingScreen();
            displayStartScreen();
            logMessage("Error crítico al cargar. Se recomienda empezar nueva partida.", 'error');
            showNotification("Error crítico al cargar", "error");
            // Reset player state to avoid corrupting a new game attempt
            setupInitialPlayerState(); // Revert to default state
            AudioManager.stopMusic();
        }
    }
    
    
    function scheduleResourceRespawnsFromLoad() {
         const now = Date.now();
         console.log("Scheduling resource respawns from loaded data...");
         Object.entries(world.worldStateData.depletedNodes || {}).forEach(([nodeId, depletionTimestamp]) => {
              const defIdMatch = nodeId.match(/^([a-zA-Z0-9_]+)_/); const defId = defIdMatch ? defIdMatch[1] : null;
              const nodeDef = defId ? resourceDefinitions[defId] : null; const respawnDelay = nodeDef?.respawnTime || RESOURCE_RESPAWN_TIME;
              const remainingTime = Math.max(0, respawnDelay - (now - depletionTimestamp));
              const nodeObject = world.interactables.find(n => n.userData?.id === nodeId); // Buscar nodo 3D si existe
              if (nodeObject?.userData?.respawnTimeoutId) clearTimeout(nodeObject.userData.respawnTimeoutId);

              const timeoutId = setTimeout(() => {
                   if (world.worldStateData.depletedNodes[nodeId]) { delete world.worldStateData.depletedNodes[nodeId]; console.log(`Node ${nodeId} state 'depleted' removed.`); }
                   const nodeToRegen = world.interactables.find(n => n.userData?.id === nodeId);
                   if (nodeToRegen?.parent && nodeToRegen.userData?.depleted) regenerateResource(nodeToRegen); // Regenerar si aún existe y está agotado
                   if (nodeToRegen) nodeToRegen.userData.respawnTimeoutId = null; // Limpiar ref timeout
              }, remainingTime + 50); // +50ms margen
              if (nodeObject) nodeObject.userData.respawnTimeoutId = timeoutId; // Guardar ref si objeto existe
         });
          console.log("Resource respawn scheduling from load complete.");
    }

    function calculateXPForLevel(level) {
         if (level <= 1) return BASE_XP_REQ;
         return Math.floor(BASE_XP_REQ * Math.pow(XP_MULTIPLIER, level - 1));
    }

    function calculateSkillXPForLevel(skillId, level) {
          if (level <= 1) return BASE_SKILL_XP_REQ;
          const multiplier = skillDefinitions[skillId]?.xpMultiplier || SKILL_XP_MULTIPLIER;
          const baseReq = skillDefinitions[skillId]?.baseXpReq || BASE_SKILL_XP_REQ;
          return Math.floor(baseReq * Math.pow(multiplier, level - 1));
     }
     
         // ============================================
    // === UI Panel Control Functions (MOVED HERE) ===
    // ============================================
    // These functions need to be defined BEFORE setupUI uses them.

/**
 * openShop (v2.3 - CORREGIDO Iconos HTML/Texto + Check Mercader Flexible)
 *
 * Abre el panel de la tienda mejorado para interactuar con un NPC comerciante.
 * Popula listas, limpia selección, configura panel de detalles y botones de acción.
 * Valida la existencia de todos los elementos DOM necesarios.
 * Valida si el NPC es mercader comprobando si tiene shopItems en su definición.
 * Muestra correctamente los iconos de items (HTML o Texto) con margen.
 *
 * @param {THREE.Object3D} npcObject - El objeto 3D del NPC comerciante.
 */
function openShop(npcObject) {
    // 1. --- Validaciones Iniciales (NPC, Estado Juego) ---
    const npcType = npcObject?.userData?.npcType;
    const npcDefinition = npcType ? npcDefinitions[npcType] : null;
    // Validar si es mercader comprobando si tiene un array 'shopItems' definido
    const isMerchant = npcDefinition && Array.isArray(npcDefinition.shopItems);

    if (!npcObject || !npcDefinition || !isMerchant) {
        console.error("openShop: Intento de abrir tienda con un objeto inválido o no comerciante (sin 'shopItems' array). NPC Type:", npcType);
        logMessage("Este personaje no comercia.", "warning");
        if (gameState.isInDialog) closeDialog(); // Cerrar diálogo si estaba abierto
        return;
    }

    if (gameState.isShopOpen) {
        console.warn("openShop: La tienda ya está abierta.");
        return; // Ya está abierta, no hacer nada
    }
    if (gameState.isGhost) {
        logMessage("Los fantasmas no pueden comerciar.", "info");
        if (gameState.isInDialog) closeDialog();
        return;
    }
    const shopItemIds = npcDefinition.shopItems; // Ya sabemos que es un array

    // 2. --- Cerrar Otros Paneles/Modales ---
    if (gameState.isInDialog) closeDialog(); // Cerrar diálogo si estaba abierto
    closeOtherModals(); // Cerrar cualquier otro panel modal abierto

    // 3. --- Obtener y Validar TODOS los Elementos DOM Esenciales ---
    const shopPanel = domCache['shop-panel'];
    const shopTitle = domCache['shop-title'];
    const shopPlayerGold = domCache['shop-player-gold'];
    const shopItemListContainer = domCache['shop-item-list'];
    const shopPlayerSellListContainer = domCache['shop-player-sell-list'];
    const closeShopButton = domCache['close-shop'];
    const buyButton = domCache['shop-buy-button'];
    const sellButton = domCache['shop-sell-button'];
    const detailsPlaceholder = domCache['shop-details-placeholder'];
    const detailsContent = domCache['shop-details-content'];
    const detailsName = domCache['shop-details-name'];
    const detailsDesc = domCache['shop-details-desc'];
    const detailsStats = domCache['shop-details-stats'];
    const detailsPrice = domCache['shop-details-price'];
    const shopTooltip = domCache['shop-tooltip']; // Necesario para los listeners

    // Lista de IDs que DEBEN existir
    const requiredShopElementKeys = [
        'shop-panel', 'shop-title', 'shop-player-gold', 'shop-item-list',
        'shop-player-sell-list', 'close-shop', 'shop-buy-button', 'shop-sell-button',
        'shop-details-placeholder', 'shop-details-content', 'shop-details-name',
        'shop-details-desc', 'shop-details-stats', 'shop-details-price', 'shop-tooltip'
    ];
    let missingShopElement = false;
    for (const key of requiredShopElementKeys) {
        if (!domCache[key] || !(domCache[key] instanceof HTMLElement)) {
            console.error(`openShop: Elemento esencial "${key}" NO encontrado o no es HTMLElement.`);
            missingShopElement = true;
        }
    }
    // Validar también los elementos del selector de cantidad que se usan en updateShopDetailsAndActions
    const requiredQtySelectors = ['shop-quantity-selector', 'shop-quantity-input', 'shop-qty-decrease', 'shop-qty-increase', 'shop-qty-max', 'shop-total-price', 'shop-buy-qty-text', 'shop-sell-qty-text'];
    for (const key of requiredQtySelectors) {
         if (!domCache[key] || !(domCache[key] instanceof HTMLElement)) {
             // Podrían no ser esenciales si nunca se venden/compran apilables, pero es mejor verificar
             console.warn(`openShop: Elemento de selector de cantidad "${key}" NO encontrado o no es HTMLElement. La compra/venta de stacks podría fallar.`);
             // No marcamos como error fatal por ahora, pero podría causar problemas luego.
             // missingShopElement = true;
         }
    }

    if (missingShopElement) {
        logMessage("Error interno: Interfaz de tienda dañada.", "error");
        return; // Salir si falta algo esencial
    }
    // --- Si todos los elementos existen, continuar ---

    console.log(`Abriendo tienda de: ${npcDefinition.name || npcType}`);

    // 4. --- Resetear Selección y Estado Interno de Tienda ---
    gameState.shopSelectedItemToBuyId = null;
    gameState.shopSelectedItemToSellIndex = null;

    // 5. --- Actualizar UI Básica (Título, Oro, Botón Cerrar) ---
    shopTitle.textContent = npcDefinition.name ? `Mercancías de ${npcDefinition.name}` : 'Tienda';
    shopPlayerGold.textContent = playerState.gold.toString(); // Actualizar oro inicial
    // Limpiar y añadir listener al botón de cerrar
    if (closeShopButton.currentClickListener) closeShopButton.removeEventListener('click', closeShopButton.currentClickListener);
    closeShopButton.currentClickListener = closeShop;
    closeShopButton.addEventListener('click', closeShopButton.currentClickListener);

    // 6. --- Poblar Lista de Items del Comerciante (Compra) ---
    shopItemListContainer.innerHTML = ''; // Limpiar lista
    if (shopItemIds.length > 0) {
        shopItemIds.forEach(itemId => {
            const itemDef = itemDefinitions[itemId];
            if (!itemDef) {
                console.warn(`Item ${itemId} en tienda de ${npcType} no encontrado en itemDefinitions.`);
                return; // Saltar este item
            }
            const shopItemElement = document.createElement('div');
            shopItemElement.className = 'shop-item';
            shopItemElement.dataset.itemId = itemId; // Guardar ID para selección
            const canAfford = playerState.gold >= itemDef.value;
            shopItemElement.classList.toggle('cannot-afford', !canAfford);
            const rarityClass = `item-name-${itemDef.rarity || 'common'}`;

            // --- *** ICONO CORREGIDO *** ---
            let iconHtml = '';
            const iconStyle = "margin-right: 5px; vertical-align: middle; display: inline-block; width: 20px; height: 20px; text-align: center; line-height: 20px; object-fit: contain;"; // Estilo base para ambos tipos
            if (itemDef.icon_type === 'html') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = itemDef.icon || '❓'; // Parsear HTML
                const iconElement = tempDiv.firstChild;
                if (iconElement instanceof HTMLElement) {
                    // Aplicar estilo al elemento parseado (asume que es img u otro)
                    iconElement.style.cssText += iconStyle; // Añadir estilos
                    // Limitar tamaño explícitamente si es imagen
                    if (iconElement.tagName === 'IMG') {
                         iconElement.style.maxWidth = '20px';
                         iconElement.style.maxHeight = '20px';
                    }
                    iconHtml = iconElement.outerHTML;
                } else {
                    // Fallback si el HTML no parsea a un elemento
                    iconHtml = `<span style="${iconStyle}">${itemDef.icon || '❓'}</span>`;
                }
            } else {
                // Si es texto (FontAwesome, emoji), envolver en span con estilo
                iconHtml = `<span style="${iconStyle}">${itemDef.icon || '❓'}</span>`;
            }
            // --- *** FIN ICONO CORREGIDO *** ---

            // Construir innerHTML del item
            shopItemElement.innerHTML = `
                <span class="shop-item-name">
                    ${iconHtml}
                    <span class="${rarityClass}">${itemDef.name}</span>
                </span>
                <span class="shop-item-price">
                    <i class="fas fa-coins"></i> ${itemDef.value}
                </span>
            `;

            // Añadir Listeners
            if (shopItemElement.currentClickListener) shopItemElement.removeEventListener('click', shopItemElement.currentClickListener);
            shopItemElement.currentClickListener = () => handleShopSelection(shopItemElement, 'buy');
            shopItemElement.addEventListener('click', shopItemElement.currentClickListener);

            if (shopItemElement.currentMouseEnterListener) shopItemElement.removeEventListener('mouseenter', shopItemElement.currentMouseEnterListener);
            shopItemElement.currentMouseEnterListener = (e) => showItemTooltip(itemDef, e, 'shop');
            shopItemElement.addEventListener('mouseenter', shopItemElement.currentMouseEnterListener);

            if (shopItemElement.currentMouseLeaveListener) shopItemElement.removeEventListener('mouseleave', shopItemElement.currentMouseLeaveListener);
            shopItemElement.currentMouseLeaveListener = hideTooltip;
            shopItemElement.addEventListener('mouseleave', shopItemElement.currentMouseLeaveListener);

            shopItemListContainer.appendChild(shopItemElement); // Añadir elemento a la lista
        });
    } else {
        shopItemListContainer.innerHTML = '<div class="shop-empty">Este comerciante no tiene nada para vender ahora mismo.</div>';
    }

    // 7. --- Poblar Lista de Items del Jugador (Venta) ---
    shopPlayerSellListContainer.innerHTML = ''; // Limpiar lista
    // Filtrar items vendibles (valor > 0 y no quest item)
    const sellableItems = inventory.items.filter(item => item && itemDefinitions[item.id]?.value > 0 && !itemDefinitions[item.id]?.questItem);
    if (sellableItems.length > 0) {
        sellableItems.forEach((item, originalInventoryIndex) => { // Usar índice original
            const itemDef = itemDefinitions[item.id];
            // Recalcular índice real en el array inventory.items (por si hay nulls)
            const actualInventoryIndex = inventory.items.findIndex(invItem => invItem === item);
            if (actualInventoryIndex === -1) {
                console.warn(`Error encontrando índice para item de venta: ${item.id}`);
                return; // Saltar si no se encuentra (debería ser raro)
            }

            const sellPrice = Math.max(1, Math.floor(itemDef.value * 0.25)); // Precio de venta (25%)
            const sellItemElement = document.createElement('div');
            sellItemElement.className = 'shop-item';
            sellItemElement.dataset.inventoryIndex = actualInventoryIndex.toString(); // Usar índice REAL
            const rarityClass = `item-name-${itemDef.rarity || 'common'}`;

            // --- *** ICONO CORREGIDO (Venta) *** ---
            let sellIconHtml = '';
            const sellIconStyle = "margin-right: 5px; vertical-align: middle; display: inline-block; width: 20px; height: 20px; text-align: center; line-height: 20px; object-fit: contain;";
            if (itemDef.icon_type === 'html') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = itemDef.icon || '❓';
                const iconElement = tempDiv.firstChild;
                if (iconElement instanceof HTMLElement) {
                    iconElement.style.cssText += sellIconStyle;
                     if (iconElement.tagName === 'IMG') { iconElement.style.maxWidth = '20px'; iconElement.style.maxHeight = '20px'; }
                    sellIconHtml = iconElement.outerHTML;
                } else { sellIconHtml = `<span style="${sellIconStyle}">${itemDef.icon || '❓'}</span>`; }
            } else { sellIconHtml = `<span style="${sellIconStyle}">${itemDef.icon || '❓'}</span>`; }
            // --- *** FIN ICONO CORREGIDO (Venta) *** ---

            sellItemElement.innerHTML = `
                <span class="shop-item-name">
                    ${sellIconHtml}
                    <span class="${rarityClass}">${itemDef.name}</span>
                    ${item.count > 1 ? `<span class="item-count-shop">x${item.count}</span>` : ''}
                </span>
                <span class="shop-item-price">
                    <i class="fas fa-coins"></i> ${sellPrice} c/u
                </span>
            `;

            // Listeners
            if (sellItemElement.currentClickListener) sellItemElement.removeEventListener('click', sellItemElement.currentClickListener);
            sellItemElement.currentClickListener = () => handleShopSelection(sellItemElement, 'sell');
            sellItemElement.addEventListener('click', sellItemElement.currentClickListener);

            if (sellItemElement.currentMouseEnterListener) sellItemElement.removeEventListener('mouseenter', sellItemElement.currentMouseEnterListener);
            sellItemElement.currentMouseEnterListener = (e) => showItemTooltip(item, e, 'shop'); // Pasar la instancia del item para tooltip
            sellItemElement.addEventListener('mouseenter', sellItemElement.currentMouseEnterListener);

            if (sellItemElement.currentMouseLeaveListener) sellItemElement.removeEventListener('mouseleave', sellItemElement.currentMouseLeaveListener);
            sellItemElement.currentMouseLeaveListener = hideTooltip;
            sellItemElement.addEventListener('mouseleave', sellItemElement.currentMouseLeaveListener);

            shopPlayerSellListContainer.appendChild(sellItemElement);
        });
    } else {
        shopPlayerSellListContainer.innerHTML = '<div class="shop-empty">No tienes objetos para vender.</div>';
    }

    // 8. --- Limpiar Detalles y Deshabilitar Botones de Acción Inicialmente ---
    updateShopDetailsAndActions(); // Esta función configura los detalles y habilita/deshabilita botones

    // 9. --- Añadir Listeners a Botones Comprar/Vender (Limpiando anteriores) ---
    if (buyButton.currentClickListener) buyButton.removeEventListener('click', buyButton.currentClickListener);
    buyButton.currentClickListener = buySelectedItemFromShop;
    buyButton.addEventListener('click', buyButton.currentClickListener);

    if (sellButton.currentClickListener) sellButton.removeEventListener('click', sellButton.currentClickListener);
    sellButton.currentClickListener = sellSelectedItemFromShop;
    sellButton.addEventListener('click', sellButton.currentClickListener);

    // 10. --- Actualizar Estado y Mostrar Panel ---
    gameState.isShopOpen = true;
    gameState.currentShopNPC = npcObject; // Guardar referencia al NPC por si se necesita
    shopPanel.style.display = 'flex'; // Mostrar el panel
    AudioManager.playSound('ui_open', 0.45);

} // --- Fin de openShop (v2.3 CORREGIDA Iconos) ---
    function closeShop() {
        // console.log("Closing shop..."); // DEBUG
        const shopPanel = domCache['shop-panel'];
        if (!shopPanel || !gameState.isShopOpen) return;
        shopPanel.style.display = 'none';
        gameState.isShopOpen = false;
        gameState.shopSelectedItemToBuyId = null;
        gameState.shopSelectedItemToSellIndex = null;
        // Resetear detalles y botones
        const detailsPlaceholder = domCache['shop-details-placeholder'];
        const detailsContent = domCache['shop-details-content'];
        const quantitySelector = domCache['shop-quantity-selector'];
        const buyButton = domCache['shop-buy-button'];
        const sellButton = domCache['shop-sell-button'];
        if(detailsContent) detailsContent.style.display = 'none';
        if(detailsPlaceholder) detailsPlaceholder.style.display = 'block';
        if(quantitySelector) quantitySelector.style.display = 'none';
        if(buyButton) buyButton.disabled = true;
        if(sellButton) sellButton.disabled = true;
        const buyQtyText = domCache['shop-buy-qty-text'];
        const sellQtyText = domCache['shop-sell-qty-text'];
        if(buyQtyText) buyQtyText.textContent = '';
        if(sellQtyText) sellQtyText.textContent = '';

        // Deseleccionar items en listas
        clearShopSelections();
        hideTooltip(); // Ocultar tooltips
        AudioManager.playSound('ui_close', 0.4);
    }
    
    
    function updateShopDetailsAndActions() {
    // --- 1. Obtener Referencias a TODOS los Elementos Necesarios ---
    //    (Usando los IDs directos cacheados por assignDOMElements)
    const placeholder = domCache['shop-details-placeholder'];
    const contentDiv = domCache['shop-details-content'];
    const nameDiv = domCache['shop-details-name'];
    const descDiv = domCache['shop-details-desc'];
    const statsDiv = domCache['shop-details-stats'];
    const priceDiv = domCache['shop-details-price'];
    const buyButton = domCache['shop-buy-button'];
    const sellButton = domCache['shop-sell-button'];
    // Nuevos elementos de cantidad
    const quantitySelector = domCache['shop-quantity-selector'];
    const qtyInput = domCache['shop-quantity-input'];
    const qtyDecreaseBtn = domCache['shop-qty-decrease'];
    const qtyIncreaseBtn = domCache['shop-qty-increase'];
    const qtyMaxBtn = domCache['shop-qty-max'];
    const totalPriceSpan = domCache['shop-total-price'];
    const buyQtyText = domCache['shop-buy-qty-text'];
    const sellQtyText = domCache['shop-sell-qty-text'];

    // --- 2. Validación Rigurosa de TODOS los Elementos ---
    const allElementsValid =
        placeholder instanceof HTMLElement &&
        contentDiv instanceof HTMLElement &&
        nameDiv instanceof HTMLElement &&
        descDiv instanceof HTMLElement &&
        statsDiv instanceof HTMLElement &&
        priceDiv instanceof HTMLElement &&
        buyButton instanceof HTMLButtonElement &&
        sellButton instanceof HTMLButtonElement &&
        quantitySelector instanceof HTMLElement &&
        qtyInput instanceof HTMLInputElement &&
        qtyDecreaseBtn instanceof HTMLButtonElement &&
        qtyIncreaseBtn instanceof HTMLButtonElement &&
        qtyMaxBtn instanceof HTMLButtonElement &&
        totalPriceSpan instanceof HTMLElement &&
        buyQtyText instanceof HTMLElement && // Verificar spans aunque sean opcionales en display
        sellQtyText instanceof HTMLElement;

    if (!allElementsValid) {
        console.error("updateShopDetailsAndActions: Faltan elementos DOM esenciales (incluyendo selector de cantidad). Verifica HTML y IDs en assignDOMElements.");
        // Deshabilitar botones principales como fallback
        if (buyButton instanceof HTMLButtonElement) buyButton.disabled = true;
        if (sellButton instanceof HTMLButtonElement) sellButton.disabled = true;
        // Ocultar selector por si acaso
        if (quantitySelector instanceof HTMLElement) quantitySelector.style.display = 'none';
        return;
    }

    // --- 3. Limpiar Listeners de Cantidad Anteriores ---
    //    (Evita que se acumulen listeners si se selecciona otro item)
    const clearQtyListeners = () => {
        if (qtyDecreaseBtn.currentClickListener) qtyDecreaseBtn.removeEventListener('click', qtyDecreaseBtn.currentClickListener);
        if (qtyIncreaseBtn.currentClickListener) qtyIncreaseBtn.removeEventListener('click', qtyIncreaseBtn.currentClickListener);
        if (qtyMaxBtn.currentClickListener) qtyMaxBtn.removeEventListener('click', qtyMaxBtn.currentClickListener);
        if (qtyInput.currentInputListener) qtyInput.removeEventListener('input', qtyInput.currentInputListener);
        if (qtyInput.currentChangeListener) qtyInput.removeEventListener('change', qtyInput.currentChangeListener);
        // Resetear referencias guardadas
        qtyDecreaseBtn.currentClickListener = null;
        qtyIncreaseBtn.currentClickListener = null;
        qtyMaxBtn.currentClickListener = null;
        qtyInput.currentInputListener = null;
        qtyInput.currentChangeListener = null;
    };
    clearQtyListeners(); // Ejecutar limpieza

    // --- 4. Determinar Item Seleccionado, Definición y Contexto ---
    let itemToShow = null;
    let itemDef = null;
    let context = 'none'; // 'buy' o 'sell'
    let unitPrice = 0; // Precio por unidad
    let maxPossibleQty = 1; // Max que se puede comprar/vender

    if (gameState.shopSelectedItemToBuyId) {
        itemDef = itemDefinitions[gameState.shopSelectedItemToBuyId];
        if (itemDef) {
            itemToShow = itemDef; // Para comprar, 'itemToShow' es la definición
            context = 'buy';
            unitPrice = itemDef.value;
        }
    } else if (gameState.shopSelectedItemToSellIndex !== null && gameState.shopSelectedItemToSellIndex < inventory.items.length) {
        itemToShow = inventory.items[gameState.shopSelectedItemToSellIndex]; // Para vender, es la instancia del inventario
        if (itemToShow) {
            itemDef = itemDefinitions[itemToShow.id]; // Necesitamos la definición también
            if (itemDef) { // Asegurarse de que la definición existe
                context = 'sell';
                unitPrice = Math.max(1, Math.floor(itemDef.value * 0.25));
            } else {
                 itemToShow = null; // Invalidar si no hay definición
            }
        }
    }

    // --- 5. Actualizar UI Basado en si hay Selección Válida ---
    if (itemToShow && itemDef) {
        // --- 5.a. Mostrar Contenido de Detalles, Ocultar Placeholder ---
        placeholder.style.display = 'none';
        contentDiv.style.display = 'block';

        // --- 5.b. Actualizar Nombre (sin cantidad), Desc, Stats ---
        const rarity = itemDef.rarity || 'common';
        nameDiv.className = `item-name-${rarity}`;
        nameDiv.textContent = itemDef.name; // Nombre base
        descDiv.textContent = itemDef.description || '';
        statsDiv.innerHTML = '';
        if (itemDef.stats) {
            for (const [stat, value] of Object.entries(itemDef.stats)) {
                if (value !== 0) {
                    const sign = value > 0 ? '+' : '';
                    const suffix = stat.includes('Chance') ? '%' : '';
                    statsDiv.innerHTML += `<span>${sign}${value}${suffix} ${getStatName(stat)}</span>`;
                }
            }
        }

        // --- 5.c. Configurar Selector de Cantidad ---
        const isStackable = itemDef.stackable || false;
        const currentInvCount = (context === 'sell' && itemToShow) ? (itemToShow.count || 1) : 1;

        // Mostrar selector SI es apilable O SI se está vendiendo (para vender stacks)
        if (isStackable || context === 'sell') {
            quantitySelector.style.display = 'flex'; // Mostrar el contenedor

            // Calcular Máximo Posible
            if (context === 'buy') {
                priceDiv.innerHTML = `Precio Unitario: <i class="fas fa-coins"></i> ${unitPrice}`;
                priceDiv.style.color = 'var(--color-primary)';
                const affordableQty = unitPrice > 0 ? Math.floor(playerState.gold / unitPrice) : Infinity;
                // Calcular espacio disponible es complejo, simplificamos con maxStack o un límite alto
                const stackSpaceQty = itemDef.maxStack || 99; // Asumir 99 si no definido
                maxPossibleQty = Math.max(1, Math.min(affordableQty, stackSpaceQty));
            } else { // context === 'sell'
                priceDiv.innerHTML = `Precio Unitario Venta: <i class="fas fa-coins"></i> ${unitPrice}`;
                priceDiv.style.color = 'var(--color-warning)';
                maxPossibleQty = currentInvCount; // Máximo a vender es lo que hay en el stack
            }

            // --- Helper Interno para Actualizar Cantidad ---
            const updateQuantityAndTotal = (forceValue = null) => {
                let currentValue = forceValue !== null ? forceValue : parseInt(qtyInput.value, 10);
                // Validaciones
                if (isNaN(currentValue) || currentValue < 1) currentValue = 1;
                currentValue = Math.min(currentValue, maxPossibleQty); // Aplicar límite máximo

                // Actualizar Input
                qtyInput.value = currentValue.toString();
                qtyInput.max = maxPossibleQty.toString();

                // Calcular y Mostrar Precio Total
                const total = currentValue * unitPrice;
                totalPriceSpan.innerHTML = `Total: ${total} <i class="fas fa-coins"></i>`;

                // Habilitar/Deshabilitar Botones +/-/MAX
                qtyDecreaseBtn.disabled = currentValue <= 1;
                qtyIncreaseBtn.disabled = currentValue >= maxPossibleQty;
                qtyMaxBtn.disabled = currentValue >= maxPossibleQty;

                // Actualizar Texto en Botones Principales
                buyQtyText.textContent = (context === 'buy' && currentValue > 1) ? `(${currentValue})` : '';
                sellQtyText.textContent = (context === 'sell' && currentValue > 1) ? `(${currentValue})` : '';

                // Revalidar Botón Principal de Compra (basado en TOTAL)
                if (context === 'buy') {
                    buyButton.disabled = playerState.gold < total || currentValue === 0; // Asegurar que no se compre 0
                }
                // El botón de Venta ya está habilitado si llegamos aquí con context='sell'
            }; // Fin de updateQuantityAndTotal

            // --- Añadir Listeners a Controles de Cantidad ---
            qtyDecreaseBtn.currentClickListener = () => updateQuantityAndTotal(parseInt(qtyInput.value, 10) - 1);
            qtyDecreaseBtn.addEventListener('click', qtyDecreaseBtn.currentClickListener);

            qtyIncreaseBtn.currentClickListener = () => updateQuantityAndTotal(parseInt(qtyInput.value, 10) + 1);
            qtyIncreaseBtn.addEventListener('click', qtyIncreaseBtn.currentClickListener);

            qtyMaxBtn.currentClickListener = () => updateQuantityAndTotal(maxPossibleQty);
            qtyMaxBtn.addEventListener('click', qtyMaxBtn.currentClickListener);

            qtyInput.currentInputListener = () => updateQuantityAndTotal(); // Validar en vivo
            qtyInput.addEventListener('input', qtyInput.currentInputListener);
            qtyInput.currentChangeListener = () => updateQuantityAndTotal(); // Validar al finalizar
            qtyInput.addEventListener('change', qtyInput.currentChangeListener);

            // --- Inicializar Cantidad ---
            updateQuantityAndTotal(1); // Iniciar con cantidad 1

        } else {
            // --- Si NO se muestra el selector (item no apilable al comprar) ---
            quantitySelector.style.display = 'none'; // Ocultar contenedor
            qtyInput.value = '1'; // Resetear input a 1
            buyQtyText.textContent = ''; // Limpiar texto botones
            sellQtyText.textContent = '';

            // Mostrar precio unitario como precio principal
            priceDiv.innerHTML = `Precio Compra: <i class="fas fa-coins"></i> ${unitPrice}`;
            priceDiv.style.color = 'var(--color-primary)';
        }

        // --- 5.d. Habilitar/Deshabilitar Botones Principales (Final) ---
        if (context === 'buy') {
            // Si el selector está oculto, la validación es con unitPrice
            if (quantitySelector.style.display === 'none') {
                buyButton.disabled = playerState.gold < unitPrice;
            }
            // Si el selector está visible, updateQuantityAndTotal ya maneja la habilitación/deshabilitación
            sellButton.disabled = true;
        } else { // context === 'sell'
            buyButton.disabled = true;
            // Vender siempre está habilitado si hay un item de venta seleccionado (cantidad > 0)
            sellButton.disabled = maxPossibleQty <= 0; // Deshabilitar solo si no queda nada que vender
        }

    } else {
        // --- 6. No hay Selección Válida ---
        placeholder.style.display = 'block'; // Mostrar placeholder
        contentDiv.style.display = 'none'; // Ocultar contenido real
        quantitySelector.style.display = 'none'; // Ocultar selector de cantidad
        clearQtyListeners(); // Asegurar limpieza de listeners
        nameDiv.textContent = ''; descDiv.textContent = ''; statsDiv.innerHTML = ''; priceDiv.textContent = '';
        buyQtyText.textContent = ''; sellQtyText.textContent = ''; // Limpiar texto botones
        buyButton.disabled = true; sellButton.disabled = true; // Deshabilitar botones principales
    }
} // Fin de updateShopDetailsAndActions

function populateShopLists(npcObject) {
    // --- 1. Obtener Definición del NPC y Contenedores DOM ---
    const npcDefinition = npcDefinitions[npcObject?.userData?.npcType];
    const buyListContainer = domCache['shop-item-list'];
    const sellListContainer = domCache['shop-player-sell-list'];

    // Validar que los contenedores y la definición existan
    if (!(buyListContainer instanceof HTMLElement) || !(sellListContainer instanceof HTMLElement)) {
        console.error("populateShopLists: Contenedores de lista de tienda no encontrados en domCache.");
        return;
    }
     if (!npcDefinition) {
         console.error("populateShopLists: Definición de NPC no encontrada.");
         buyListContainer.innerHTML = '<div class="shop-empty">Error: Comerciante inválido.</div>';
         sellListContainer.innerHTML = '<div class="shop-empty"></div>';
         return;
     }

    const shopItemIds = npcDefinition.shopItems || []; // Items que vende el NPC

    // --- 2. Limpiar Contenido Anterior de las Listas ---
    buyListContainer.innerHTML = '';
    sellListContainer.innerHTML = '';

    // --- 3. Poblar Lista de Compra (Items del Comerciante) ---
    if (shopItemIds.length > 0) {
        shopItemIds.forEach(itemId => {
            const itemDef = itemDefinitions[itemId];
            if (!itemDef) {
                console.warn(`populateShopLists (Buy): ItemDef no encontrado para ID: ${itemId}`);
                return; // Saltar item si no existe definición
            }

            const shopItemElement = document.createElement('div');
            shopItemElement.className = 'shop-item';
            shopItemElement.dataset.itemId = itemId; // Guardar ID para selección

            const canAfford = playerState.gold >= itemDef.value;
            shopItemElement.classList.toggle('cannot-afford', !canAfford);
            const rarityClass = `item-name-${itemDef.rarity || 'common'}`;

            // --- Renderizado de Icono (Comprar) ---
            let iconHtml = '';
            // Estilos consistentes para iconos
            const iconStyle = "margin-right: 5px; vertical-align: middle; display: inline-block; width: 20px; height: 20px; text-align: center; line-height: 20px; object-fit: contain;";
            if (itemDef.icon_type === 'html') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = itemDef.icon || '❓'; // Parsear HTML
                const iconElement = tempDiv.firstChild;
                if (iconElement instanceof HTMLElement) {
                    iconElement.style.cssText += iconStyle; // Añadir estilos base
                    // Limitar tamaño explícitamente si es imagen
                    if (iconElement.tagName === 'IMG') {
                         iconElement.style.maxWidth = '20px'; iconElement.style.maxHeight = '20px';
                    }
                    iconHtml = iconElement.outerHTML;
                } else { // Fallback si el HTML no es válido
                    iconHtml = `<span style="${iconStyle}">${itemDef.icon || '❓'}</span>`;
                }
            } else { // Texto/Emoji/FA
                iconHtml = `<span style="${iconStyle}">${itemDef.icon || '❓'}</span>`;
            }
            // --- Fin Renderizado Icono (Comprar) ---

            // Construir innerHTML
            shopItemElement.innerHTML = `
                <span class="shop-item-name">
                    ${iconHtml}
                    <span class="${rarityClass}">${itemDef.name}</span>
                </span>
                <span class="shop-item-price">
                    <i class="fas fa-coins"></i> ${itemDef.value}
                </span>
            `;

            // Limpiar y Añadir Listeners (Comprar)
            if (shopItemElement.currentClickListener) shopItemElement.removeEventListener('click', shopItemElement.currentClickListener);
            shopItemElement.currentClickListener = () => handleShopSelection(shopItemElement, 'buy');
            shopItemElement.addEventListener('click', shopItemElement.currentClickListener);

            if (shopItemElement.currentMouseEnterListener) shopItemElement.removeEventListener('mouseenter', shopItemElement.currentMouseEnterListener);
            shopItemElement.currentMouseEnterListener = (e) => showItemTooltip(itemDef, e, 'shop');
            shopItemElement.addEventListener('mouseenter', shopItemElement.currentMouseEnterListener);

            if (shopItemElement.currentMouseLeaveListener) shopItemElement.removeEventListener('mouseleave', shopItemElement.currentMouseLeaveListener);
            shopItemElement.currentMouseLeaveListener = hideTooltip;
            shopItemElement.addEventListener('mouseleave', shopItemElement.currentMouseLeaveListener);

            buyListContainer.appendChild(shopItemElement); // Añadir a la lista
        });
    } else {
        buyListContainer.innerHTML = '<div class="shop-empty">Este comerciante no tiene objetos para vender.</div>';
    }

    // --- 4. Poblar Lista de Venta (Items del Jugador) ---
    // Filtrar items vendibles (valor > 0, no quest)
    const sellableItems = inventory.items.filter(item => item && itemDefinitions[item.id]?.value > 0 && !itemDefinitions[item.id]?.questItem);
    if (sellableItems.length > 0) {
        sellableItems.forEach(itemInstance => { // Iterar sobre las instancias vendibles
            const itemDef = itemDefinitions[itemInstance.id];
            // Encontrar el índice REAL de esta instancia en el inventario principal
            const actualInventoryIndex = inventory.items.findIndex(invItem => invItem === itemInstance);
            if (actualInventoryIndex === -1) {
                 console.warn(`populateShopLists (Sell): No se encontró el índice para ${itemInstance.id}`);
                 return; // Saltar si no se encuentra el índice (no debería pasar)
            }

            const sellPrice = Math.max(1, Math.floor(itemDef.value * 0.25)); // Precio de venta (25%)
            const sellItemElement = document.createElement('div');
            sellItemElement.className = 'shop-item';
            sellItemElement.dataset.inventoryIndex = actualInventoryIndex.toString(); // Usar índice REAL
            const rarityClass = `item-name-${itemDef.rarity || 'common'}`;

            // --- Renderizado de Icono (Vender) ---
            let sellIconHtml = '';
            const sellIconStyle = "margin-right: 5px; vertical-align: middle; display: inline-block; width: 20px; height: 20px; text-align: center; line-height: 20px; object-fit: contain;";
            if (itemDef.icon_type === 'html') {
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = itemDef.icon || '❓';
                const iconElement = tempDiv.firstChild;
                if (iconElement instanceof HTMLElement) {
                    iconElement.style.cssText += sellIconStyle;
                     if (iconElement.tagName === 'IMG') { iconElement.style.maxWidth = '20px'; iconElement.style.maxHeight = '20px'; }
                    sellIconHtml = iconElement.outerHTML;
                } else { sellIconHtml = `<span style="${sellIconStyle}">${itemDef.icon || '❓'}</span>`; }
            } else { sellIconHtml = `<span style="${sellIconStyle}">${itemDef.icon || '❓'}</span>`; }
            // --- Fin Renderizado Icono (Vender) ---

            // Construir innerHTML (incluir contador si count > 1)
            sellItemElement.innerHTML = `
                <span class="shop-item-name">
                    ${sellIconHtml}
                    <span class="${rarityClass}">${itemDef.name}</span>
                    ${itemInstance.count > 1 ? `<span class="item-count-shop">x${itemInstance.count}</span>` : ''}
                </span>
                <span class="shop-item-price">
                    <i class="fas fa-coins"></i> ${sellPrice} c/u
                </span>
            `;

            // Limpiar y Añadir Listeners (Vender)
            if (sellItemElement.currentClickListener) sellItemElement.removeEventListener('click', sellItemElement.currentClickListener);
            sellItemElement.currentClickListener = () => handleShopSelection(sellItemElement, 'sell');
            sellItemElement.addEventListener('click', sellItemElement.currentClickListener);

            if (sellItemElement.currentMouseEnterListener) sellItemElement.removeEventListener('mouseenter', sellItemElement.currentMouseEnterListener);
            // Pasar la instancia del item (con su count actual) al tooltip
            sellItemElement.currentMouseEnterListener = (e) => showItemTooltip(itemInstance, e, 'shop');
            sellItemElement.addEventListener('mouseenter', sellItemElement.currentMouseEnterListener);

            if (sellItemElement.currentMouseLeaveListener) sellItemElement.removeEventListener('mouseleave', sellItemElement.currentMouseLeaveListener);
            sellItemElement.currentMouseLeaveListener = hideTooltip;
            sellItemElement.addEventListener('mouseleave', sellItemElement.currentMouseLeaveListener);

            sellListContainer.appendChild(sellItemElement); // Añadir a la lista
        });
    } else {
        sellListContainer.innerHTML = '<div class="shop-empty">No tienes objetos para vender.</div>';
    }
} // --- Fin de populateShopLists ---
/**
 * Wrapper para comprar, ahora lee la cantidad del input.
 * (v14 - Lee Qty Input)
 */
function buySelectedItemFromShop() {
    if (!gameState.shopSelectedItemToBuyId) return;
    const itemIdToBuy = gameState.shopSelectedItemToBuyId;
    const currentNPC = gameState.currentShopNPC;
    if (!currentNPC) { closeShop(); return; }

    // ---> LEER CANTIDAD DEL INPUT <---
    const qtyInput = domCache['shop-quantity-input']; // Acceso directo por ID
    let quantityToBuy = 1; // Valor por defecto
    if (qtyInput instanceof HTMLInputElement) {
        const parsedQty = parseInt(qtyInput.value, 10);
        // Usar la cantidad parseada si es un número válido y positivo
        if (!isNaN(parsedQty) && parsedQty > 0) {
            quantityToBuy = parsedQty;
        } else {
            console.warn("Cantidad inválida en input al comprar, usando 1.");
            quantityToBuy = 1; // Fallback a 1 si no es válido
        }
    } else {
        console.error("buySelectedItemFromShop: Input de cantidad no encontrado.");
        // Podría detener la compra o asumir 1, asumamos 1 por ahora.
        quantityToBuy = 1;
    }
    // --------------------------------

    console.log(`Intentando comprar ${quantityToBuy} de ${itemIdToBuy}`); // DEBUG

    // Llamar a la lógica con la cantidad
    const purchaseSuccessful = buySelectedItemLogic(itemIdToBuy, currentNPC, quantityToBuy);

    if (purchaseSuccessful) {
        // Actualizaciones y refresco de UI
        updateShopGoldDisplay(); // Actualiza oro en el panel de tienda
        updatePlayerUI();      // Actualiza oro en la sidebar y otras stats
        gameState.shopSelectedItemToBuyId = null; // Limpiar selección
        gameState.shopSelectedItemToSellIndex = null;
        populateShopLists(currentNPC);      // Refrescar contenido de listas
        updateShopDetailsAndActions();    // Resetear panel de detalles y botones
    }
    // Si falló, la función Logic ya mostró el mensaje
}
/**
 * Wrapper para vender, ahora lee la cantidad del input.
 * (v14 - Lee Qty Input)
 */
function sellSelectedItemFromShop() {
    if (gameState.shopSelectedItemToSellIndex === null) return;
    const itemIndexToSell = gameState.shopSelectedItemToSellIndex;
    const currentNPC = gameState.currentShopNPC;
    if (!currentNPC) { closeShop(); return; }
    if (itemIndexToSell < 0 || itemIndexToSell >= inventory.items.length) { return; }

    // ---> LEER CANTIDAD DEL INPUT <---
    const qtyInput = domCache['shop-quantity-input']; // Acceso directo por ID
    let quantityToSell = 1; // Valor por defecto
    if (qtyInput instanceof HTMLInputElement) {
        const parsedQty = parseInt(qtyInput.value, 10);
        const maxSellable = inventory.items[itemIndexToSell]?.count || 0; // Cantidad máxima real
        if (!isNaN(parsedQty) && parsedQty > 0) {
            // Asegurarse de no intentar vender más de lo que hay
            quantityToSell = Math.min(parsedQty, maxSellable);
            if (quantityToSell === 0 && maxSellable > 0) quantityToSell = 1; // Asegurar vender al menos 1 si es posible
        } else {
            console.warn("Cantidad inválida en input al vender, usando 1.");
            quantityToSell = 1;
        }
    } else {
        console.error("sellSelectedItemFromShop: Input de cantidad no encontrado.");
        quantityToSell = 1;
    }
    // Si por alguna razón la cantidad a vender es 0 (ej. stack vacío), no continuar
    if (quantityToSell <= 0) {
        console.warn("sellSelectedItemFromShop: Cantidad a vender es cero o inválida.");
        return;
    }
    // ---------------------------------

    console.log(`Intentando vender ${quantityToSell} del item en índice ${itemIndexToSell}`); // DEBUG

    // Llamar a la lógica con la cantidad
    const saleSuccessful = sellSelectedItemLogic(itemIndexToSell, currentNPC, quantityToSell);

   if (saleSuccessful) {
        // --- Actualizaciones INMEDIATAS después de modificar inventory.items ---

        // 1. Actualizar Oro (En panel tienda y sidebar)
        updateShopGoldDisplay();
        updatePlayerUI();

        // 2. Limpiar Selección de Tienda (MUY IMPORTANTE)
        //    Esto asegura que updateShopDetailsAndActions muestre el placeholder
        gameState.shopSelectedItemToBuyId = null;
        gameState.shopSelectedItemToSellIndex = null;

        // 3. Actualizar UI del Inventario Principal (Sidebar)
        //    Esta función redibuja los slots basados en el array inventory.items ACTUALIZADO.
        updateInventoryUI();

        // 4. Refrescar Listas de la Tienda
        //    Esto redibuja la lista de venta basada en el array inventory.items ACTUALIZADO.
        populateShopLists(currentNPC);

        // 5. Resetear Panel de Detalles de la Tienda
        //    Como la selección se limpió, mostrará el placeholder.
        updateShopDetailsAndActions();

    }
    // Si la venta falló, no se hace nada más aquí.
}
/**
 * Lógica real para comprar una cantidad específica de un item.
 * @param {string} itemId - ID del item a comprar.
 * @param {THREE.Object3D} npcObject - El NPC comerciante.
 * @param {number} quantity - La cantidad a comprar.
 * @returns {boolean} True si la compra se completó, False si falló.
 */
function buySelectedItemLogic(itemId, npcObject, quantity = 1) { // Añadido parámetro quantity
    const itemDef = itemDefinitions[itemId];
    if (!itemDef || quantity <= 0) return false;

    const totalCost = itemDef.value * quantity; // Calcular costo total

    if (playerState.gold < totalCost) { // Comparar con costo total
        logMessage("No tienes suficiente oro para comprar esta cantidad.", "warning");
        AudioManager.playSound('ui_error', 0.4);
        return false;
    }

    // Comprobar espacio ES MÁS COMPLEJO ahora con cantidad.
    // Necesitamos simular la adición para ver si cabe.
    let remainingToAdd = quantity;
    let slotsNeeded = 0;
    let tempInventoryCounts = {}; // Simular stacks existentes
    inventory.items.forEach(item => {
        if (item.id === itemId) tempInventoryCounts[item.id] = (tempInventoryCounts[item.id] || 0) + item.count;
    });

    if (itemDef.stackable) {
        const maxStack = itemDef.maxStack || 99;
        // Espacio en stacks existentes
        inventory.items.forEach(existingItem => {
            if (remainingToAdd > 0 && existingItem.id === itemId && existingItem.count < maxStack) {
                const spaceInStack = maxStack - existingItem.count;
                const amountToAddToStack = Math.min(remainingToAdd, spaceInStack);
                remainingToAdd -= amountToAddToStack;
            }
        });
        // Calcular nuevos stacks necesarios
        if (remainingToAdd > 0) {
            slotsNeeded = Math.ceil(remainingToAdd / maxStack);
        }
    } else {
        slotsNeeded = remainingToAdd; // Cada uno necesita un slot
    }

    const freeSlots = inventory.maxItems - inventory.items.length;
    if (freeSlots < slotsNeeded) {
        logMessage(`Inventario lleno. No puedes comprar ${quantity} ${itemDef.name}.`, "warning");
        AudioManager.playSound('ui_error', 0.4);
        return false;
    }

    // --- Procesar compra ---
    playerState.gold -= totalCost;
    const added = addItemToInventory(itemId, quantity); // addItemToInventory maneja la lógica de añadir

    if (added) {
        logMessage(`Has comprado ${quantity} ${itemDef.name} por ${totalCost} oro.`, "loot");
        AudioManager.playSound('buy_item', 0.6);
        return true; // Éxito
    } else {
        // Si addItemToInventory falla (debería haber sido prevenido por el check de espacio, pero por seguridad)
        logMessage("Error inesperado al añadir objetos al inventario después de comprar.", "error");
        playerState.gold += totalCost; // Devolver oro
        AudioManager.playSound('ui_error', 0.4);
        return false; // Falló
    }
}

    function getStatName(statKey) {
         const names = {
            strength: "Fuerza", dexterity: "Destreza", intelligence: "Inteligencia", constitution: "Constitución",
            maxHealth: "Salud Máx", maxMana: "Maná Máx", maxStamina: "Resistencia Máx",
            physDmgMin: "Daño Físico Mín", physDmgMax: "Daño Físico Máx",
            magicDmgMin: "Daño Mágico Mín", magicDmgMax: "Daño Mágico Máx",
            defense: "Defensa", magicResist: "Res. Mágica",
            hitChance: "Prob. Golpe", critChance: "Prob. Crítico",
            moveSpeed: "Vel. Movimiento", hpRegen: "Regen. Salud", mpRegen: "Regen. Maná", spRegen: "Regen. Resistencia",
            manaCostReduction: "Reducción Coste Maná"
        };
        return names[statKey] || statKey;
    }
    
    /**
 * Maneja la selección de un item en CUALQUIERA de las listas de la tienda. (v11 Fix - Use Direct IDs)
 * Actualiza el estado de selección, resalta el item y actualiza los detalles/botones.
 * @param {HTMLElement} selectedElement - El elemento .shop-item que fue clickeado.
 * @param {'buy' | 'sell'} listType - Indica si se seleccionó en la lista de 'buy' o 'sell'.
 */
function handleShopSelection(selectedElement, listType) {
    // ---> USA LOS IDs DIRECTOS CACHEADOS POR getElementById <---
    const buyListContainer = domCache['shop-item-list'];
    const sellListContainer = domCache['shop-player-sell-list'];

    // Validar que los contenedores existen (AHORA buscando por ID directo)
    if (!(buyListContainer instanceof HTMLElement) || !(sellListContainer instanceof HTMLElement)) {
        // Si esto falla ahora, significa que los IDs #shop-item-list o #shop-player-sell-list no se encontraron en assignDOMElements en absoluto.
        console.error("handleShopSelection: Contenedores de lista de tienda (#shop-item-list o #shop-player-sell-list) no encontrados en caché por ID directo.");
        return;
    }

    // --- El resto de la lógica permanece IGUAL ---

    // 1. Resetear selección previa en AMBAS listas
    gameState.shopSelectedItemToBuyId = null;
    gameState.shopSelectedItemToSellIndex = null;
    buyListContainer.querySelectorAll('.shop-item.selected').forEach(el => el.classList.remove('selected'));
    sellListContainer.querySelectorAll('.shop-item.selected').forEach(el => el.classList.remove('selected'));

    // 2. Marcar como seleccionado y actualizar estado
    if (listType === 'buy') {
        selectedElement.classList.add('selected');
        gameState.shopSelectedItemToBuyId = selectedElement.dataset.itemId || null;
    } else if (listType === 'sell') {
        selectedElement.classList.add('selected');
        const index = parseInt(selectedElement.dataset.inventoryIndex || '-1', 10);
        gameState.shopSelectedItemToSellIndex = (index !== -1) ? index : null;
    }

    // 3. Actualizar panel de detalles y botones (Esta función DEBE usar las claves prefijadas correctas como se corrigió antes)
    updateShopDetailsAndActions(); // Esta ya debería usar las claves 'modal-shop-panel-...' para los detalles internos.
    AudioManager.playSound('ui_confirm', 0.3);
}


/**
 * Actualiza específicamente el indicador de oro DENTRO del panel de la tienda.
 */
function updateShopGoldDisplay() {
    const shopGoldElement = domCache['shop-player-gold']; // Usa el ID directo

    if (shopGoldElement instanceof HTMLElement) {
        // Actualizar solo si el valor ha cambiado
        const goldString = playerState.gold.toString();
        if (shopGoldElement.textContent !== goldString) {
            shopGoldElement.textContent = goldString;
        }
    } else if (!domCache.hasOwnProperty('shop-player-gold') || domCache['shop-player-gold'] === null){
        // Advertir solo si no se encontró en el cacheo inicial
        console.warn("updateShopGoldDisplay: Elemento #shop-player-gold no encontrado en caché.");
    }
}

    function deselectInventoryItem() {
         if (inventory.selectedItemIndex !== null) {
            const currentSlot = document.querySelector(`.inventory-slot[data-index="${inventory.selectedItemIndex}"]`);
            if (currentSlot instanceof HTMLElement) currentSlot.classList.remove('selected');
            inventory.selectedItemIndex = null;
            updateActionButtons();
         }
    }
    
         function deselectSpell() {
         if (spells.selectedSpellIndex !== null) {
            const prevItem = document.querySelector(`.spell-item[data-index="${spells.selectedSpellIndex}"]`);
            if (prevItem) prevItem.classList.remove('selected');
            spells.selectedSpellIndex = null;
            updateActionButtons();
         }
     }
     
     /**
* * Lógica real para vender una cantidad específica de un item del inventario.
 * @param {number} inventoryIndex - Índice del item en inventory.items.
 * @param {THREE.Object3D} npcObject - El NPC comerciante.
 * @param {number} quantity - La cantidad a vender.
 * @returns {boolean} True si la venta se completó, False si falló.
 */
function sellSelectedItemLogic(inventoryIndex, npcObject, quantity = 1) { // Añadido parámetro quantity
    if (inventoryIndex < 0 || inventoryIndex >= inventory.items.length || quantity <= 0) return false;

    const itemInstance = inventory.items[inventoryIndex];
    if (!itemInstance || !itemInstance.id) return false;

    const itemDef = itemDefinitions[itemInstance.id];
    if (!itemDef || itemDef.value <= 0 || itemDef.questItem) {
        if (itemDef) logMessage(`No puedes vender "${itemDef.name}".`, "warning");
        AudioManager.playSound('ui_error', 0.4);
        return false;
    }

    const quantityToSell = Math.min(quantity, itemInstance.count || 1); // No vender más de lo que hay
    if (quantityToSell <= 0) return false; // No vender 0

    const sellPricePerUnit = Math.max(1, Math.floor(itemDef.value * 0.25));
    const totalGain = sellPricePerUnit * quantityToSell;

    // Procesar venta
    playerState.gold += totalGain;

    // Actualizar Inventario
    let itemRemovedCompletely = false;
     // Re-verificar que el item aún existe en ese índice antes de modificar
    if (inventory.items[inventoryIndex] && inventory.items[inventoryIndex].id === itemInstance.id) {
        if (inventory.items[inventoryIndex].count > quantityToSell) {
            inventory.items[inventoryIndex].count -= quantityToSell;
        } else {
            // Se venden todos o es el último
            inventory.items.splice(inventoryIndex, 1);
            itemRemovedCompletely = true;
        }
    } else {
        console.error("sellSelectedItemLogic: El item cambió o desapareció antes de completar la venta.");
        playerState.gold -= totalGain; // Revertir oro
        return false;
    }


    logMessage(`Has vendido ${quantityToSell} ${itemDef.name} por ${totalGain} oro.`, "loot");
    AudioManager.playSound('sell_item', 0.6);

    return true; // Éxito
}


/**
 * Programa la regeneración de un nodo de recurso basado en su timestamp de agotamiento.
 * @param {THREE.Object3D} resourceNode El nodo a regenerar.
 * @param {number} depletionTimestamp El timestamp (Date.now()) cuando fue agotado.
 * @param {number} respawnDelay El tiempo en ms que tarda en regenerarse.
 */
function scheduleNodeRespawn(resourceNode, depletionTimestamp, respawnDelay) {
    if (!resourceNode || !resourceNode.userData || !depletionTimestamp) return;

     // Limpiar timeout anterior si existe (por si se llama múltiples veces)
     if (resourceNode.userData.respawnTimeoutId) {
        clearTimeout(resourceNode.userData.respawnTimeoutId);
        resourceNode.userData.respawnTimeoutId = null;
     }

     const now = Date.now();
     const timeElapsed = now - depletionTimestamp;
     const remainingTime = Math.max(0, respawnDelay - timeElapsed); // Calcular tiempo restante

     if (remainingTime <= 50) { // Si queda muy poco tiempo o ya pasó, regenerar casi inmediatamente
          // console.log(`Nodo ${resourceNode.userData.id} regenerando inmediatamente.`);
          setTimeout(() => {
             // Doble check por si fue regenerado por otro medio mientras esperaba
             if(resourceNode.parent && resourceNode.userData.depleted) {
                 regenerateResource(resourceNode);
             }
              resourceNode.userData.respawnTimeoutId = null;
          }, 50); // Pequeño delay para evitar problemas de sincronización
     } else {
          // Programar la regeneración para el futuro
          // console.log(`Nodo ${resourceNode.userData.id} regenerará en ${remainingTime} ms.`);
          resourceNode.userData.respawnTimeoutId = setTimeout(() => {
               if(resourceNode.parent && resourceNode.userData.depleted) {
                   regenerateResource(resourceNode);
               }
               resourceNode.userData.respawnTimeoutId = null;
          }, remainingTime);
     }
}

function toggleCharacterSheet() {
        const charSheetPanel = domCache['character-sheet-panel'];
        if (!(charSheetPanel instanceof HTMLElement)) { console.error("Panel Hoja Personaje no encontrado."); return; }

        if (gameState.isCharacterSheetOpen) {
            // Cerrar
            charSheetPanel.style.display = 'none';
            gameState.isCharacterSheetOpen = false;
            AudioManager.playSound('ui_close', 0.4);
            console.log("Hoja de Personaje cerrada.");
        } else {
            // Abrir
            if (gameState.isGhost) { logMessage("No puedes ver tu hoja como fantasma.", "info"); AudioManager.playSound('ui_error', 0.4); return; }
            closeOtherModals(); // Cerrar otros paneles
            updateCharacterSheet(); // Actualizar datos ANTES de mostrar
            charSheetPanel.style.display = 'block'; // O 'flex' si usa flexbox
            gameState.isCharacterSheetOpen = true;
            AudioManager.playSound('ui_open', 0.4);
            console.log("Hoja de Personaje abierta.");
        }
    }

function updateCharacterSheet() {
    if (!playerState || !playerState.attributes || !playerState.stats || !domCache) { return; }
    const charSheetPanel = domCache['character-sheet-panel'];
    if (!(charSheetPanel instanceof HTMLElement) || charSheetPanel.style.display === 'none') { return; }

    const charInfoDiv = domCache['char-sheet-info']; // Contenedor general
    const nameLevelSpan = domCache['char-sheet-name-level'];
    const classSpan = domCache['char-sheet-class'];

    if (nameLevelSpan instanceof HTMLElement) {
        const nameLevelText = `${playerState.name || 'Héroe'} (Nivel ${playerState.level})`;
        if (nameLevelSpan.textContent !== nameLevelText) {
            nameLevelSpan.textContent = nameLevelText;
        }
    }
    if (classSpan instanceof HTMLElement) {
        const className = classNameMap[playerState.class] || playerState.class.charAt(0).toUpperCase() + playerState.class.slice(1); // Usar mapa o capitalizar ID
        if (classSpan.textContent !== className) {
            classSpan.textContent = className;
        }
    }

        const charAttributesContainer = domCache['char-attributes'];
        const attributePointsInfo = domCache['attribute-points-info'];
        if (!(charAttributesContainer instanceof HTMLElement) || !(attributePointsInfo instanceof HTMLElement)) { console.error("updateCharacterSheet: Contenedores UI no encontrados."); return; }

        // --- Atributos ---
        charAttributesContainer.innerHTML = ''; const columnsDiv = document.createElement('div'); columnsDiv.className = 'char-sheet-columns';
        const canAllocatePoints = playerState.attributePoints > 0 && !gameState.isGhost;
        for (const attrKey of ['strength', 'dexterity', 'intelligence', 'constitution']) {
            const attrValue = playerState.attributes[attrKey] ?? '?';
            const labelSpan = document.createElement('span'); labelSpan.className = 'stat-label'; labelSpan.textContent = getAttributeName(attrKey) + ':';
            const valueContainerSpan = document.createElement('span'); valueContainerSpan.className = 'stat-value';
            const valueTextSpan = document.createElement('span'); valueTextSpan.textContent = attrValue.toString(); valueContainerSpan.appendChild(valueTextSpan);
            if (canAllocatePoints) {
                const addButton = document.createElement('button'); addButton.className = 'attribute-alloc-button'; addButton.textContent = '+';
                addButton.title = `Aumentar ${getAttributeName(attrKey)} (Restantes: ${playerState.attributePoints})`; addButton.dataset.attrKey = attrKey;
                addButton.onclick = (event) => { event.stopPropagation(); allocateAttributePoint(event.currentTarget.dataset.attrKey); };
                valueContainerSpan.appendChild(addButton);
            }
            columnsDiv.appendChild(labelSpan); columnsDiv.appendChild(valueContainerSpan);
        }
        charAttributesContainer.appendChild(columnsDiv);
        attributePointsInfo.textContent = canAllocatePoints ? `(Puntos: ${playerState.attributePoints})` : '';
        attributePointsInfo.style.display = canAllocatePoints ? 'inline' : 'none';

        // --- Estadísticas Derivadas ---
        const derivedStatsMap = {
            'char-health': () => `${Math.floor(playerState.stats.health)}/${Math.floor(playerState.stats.maxHealth)}`, 'char-mana': () => `${Math.floor(playerState.stats.mana)}/${Math.floor(playerState.stats.maxMana)}`, 'char-stamina': () => `${Math.floor(playerState.stats.stamina)}/${Math.floor(playerState.stats.maxStamina)}`,
            'char-phys-dmg': () => `${playerState.stats.physDmgMin}-${playerState.stats.physDmgMax}`, 'char-magic-dmg': () => `${playerState.stats.magicDmgMin}-${playerState.stats.magicDmgMax}`,
            'char-defense': () => playerState.stats.defense.toFixed(1), 'char-magic-resist': () => playerState.stats.magicResist.toFixed(1),
            'char-hit-chance': () => `${playerState.stats.hitChance.toFixed(1)}%`, 'char-crit-chance': () => `${playerState.stats.critChance.toFixed(1)}%`,
            'char-move-speed': () => playerState.stats.moveSpeed.toFixed(1), 'char-hp-regen': () => `${playerState.stats.hpRegen.toFixed(1)}/s`,
            'char-mp-regen': () => `${playerState.stats.mpRegen.toFixed(1)}/s`, 'char-sp-regen': () => `${playerState.stats.spRegen.toFixed(1)}/s`,
        };
        for (const [elementId, getValueFunction] of Object.entries(derivedStatsMap)) {
            const element = domCache[elementId];
            if (element instanceof HTMLElement) { const newValueText = getValueFunction(); if (element.textContent !== newValueText) { element.textContent = newValueText; } }
            else if (!updateCharacterSheet.warnedIds?.has(elementId)){ console.warn(`updateCharacterSheet: Elemento ${elementId} no encontrado.`); if(!updateCharacterSheet.warnedIds) updateCharacterSheet.warnedIds=new Set(); updateCharacterSheet.warnedIds.add(elementId); }
        }
    }
    updateCharacterSheet.warnedIds = new Set(); // Track warnings

    function allocateAttributePoint(attrKey) {
        if (playerState.attributePoints <= 0 || !attrKey || !playerState.attributes.hasOwnProperty(attrKey)) { AudioManager.playSound('ui_error', 0.4); return; }
        playerState.attributes[attrKey]++; playerState.attributePoints--;
        AudioManager.playSound('level_up', 0.4);
        updatePlayerStats(); // Recalcular stats inmediatamente
        updateCharacterSheet(); // Actualizar UI hoja pj
        updatePlayerUI(); // Actualizar barras principales por si maximos cambiaron
    }

    function switchTab(tabId) {
        if (!tabId || typeof tabId !== 'string') return;
        const tabsContainer = domCache['tabs-container']; const tabButtons = domCache.tabButtons;
        const targetButton = tabsContainer?.querySelector(`.tab-button[data-tab="${tabId}"]`);
        const targetContent = document.getElementById(`${tabId}-tab`);
        if (!tabsContainer || !tabButtons || tabButtons.length === 0 || !(targetButton instanceof HTMLElement) || !(targetContent instanceof HTMLElement)) { console.warn(`switchTab: Elementos no encontrados para tab ${tabId}`); return; }

        let changed = false;
        tabButtons.forEach(button => { if (button instanceof HTMLElement && button.classList.contains('active')) { button.classList.remove('active'); if(button !== targetButton) changed = true; } });
        const allTabContents = tabsContainer.querySelectorAll('.tab-content');
        allTabContents.forEach(content => { if (content instanceof HTMLElement && content.classList.contains('active')) { content.classList.remove('active'); if(content !== targetContent) changed = true; } });

        if (!targetButton.classList.contains('active')) { targetButton.classList.add('active'); changed = true; }
        if (!targetContent.classList.contains('active')) { targetContent.classList.add('active'); changed = true; targetContent.scrollTop = 0; }

        if (changed) AudioManager.playSound('ui_confirm', 0.3);

        // Refrescar contenido de la pestaña activada
        if (targetContent.classList.contains('active')) {
             switch(tabId) { case 'inventory': updateInventoryUI(); break; case 'spells': updateSpellsUI(); break; /* Añadir otros si se crean pestañas */ }
        }
    }

    function logMessage(message, type = 'system') {
        const messageLogElement = domCache['message-log'];
        if (!(messageLogElement instanceof HTMLElement)) { console.log(`[Log-${type.toUpperCase()}] ${message}`); return; }
        const messageElement = document.createElement('div'); messageElement.className = `log-message ${type}`;
        messageElement.appendChild(document.createTextNode(message)); // Usar textNode
        messageLogElement.insertBefore(messageElement, messageLogElement.firstChild);
        const maxMessages = 120;
        while (messageLogElement.children.length > maxMessages && messageLogElement.lastChild) { messageLogElement.removeChild(messageLogElement.lastChild); }
    }

    function showNotification(message, type = 'info', duration = NOTIFICATION_DURATION) {
        const container = domCache['notification-container']; if (!container) return;
        const notification = document.createElement('div'); notification.className = `notification ${type}`;
        notification.textContent = message;
        const effectiveDuration = Math.max(1000, duration); // Duración mínima 1s
        notification.style.setProperty('--notification-duration', `${(effectiveDuration / 1000) - 0.3}s`); // Ajustar para animación fadeOut
        container.appendChild(notification);
        setTimeout(() => { if(notification.parentNode) notification.remove(); }, effectiveDuration); // Usar duración efectiva
    }

    function updateActionButtons() {
        const equipButton = domCache['equip-button']; const useButton = domCache['use-button']; const dropButton = domCache['drop-button'];
        if (!(equipButton && useButton && dropButton)) return;

        let selectedItem = null; let selectedItemDef = null;
        if (inventory.selectedItemIndex !== null && inventory.selectedItemIndex < inventory.items.length) { selectedItem = inventory.items[inventory.selectedItemIndex]; if(selectedItem) selectedItemDef = itemDefinitions[selectedItem.id]; }
        let selectedSpell = null; let selectedSpellDef = null;
        if (spells.selectedSpellIndex !== null && spells.selectedSpellIndex < spells.known.length) { selectedSpell = spells.known[spells.selectedSpellIndex]; if(selectedSpell) selectedSpellDef = spellDefinitions[selectedSpell.id]; }

        // Equipar
        let canEquip = selectedItemDef?.slot && ['weapon', 'armor', 'amulet', 'ring'].includes(selectedItemDef.type) && !gameState.isGhost && checkItemRequirements(selectedItemDef);
        equipButton.disabled = !canEquip;

        // Usar/Lanzar
        let canUse = false; let useButtonText = "Usar";
        if (!gameState.isGhost) {
            if (selectedItemDef?.type === 'consumable' && typeof selectedItemDef.use === 'function') { canUse = true; }
            else if (selectedSpellDef) {
                 useButtonText = "Lanzar";
                 const manaCost = Math.floor((selectedSpellDef.manaCost || 0) * (playerState.manaCostMultiplier || 1));
                 canUse = (selectedSpell.cooldownRemaining || 0) <= 0 && playerState.stats.mana >= manaCost;
            }
        }
        useButton.disabled = !canUse; useButton.textContent = useButtonText;

        // Soltar
        let canDrop = selectedItem && !gameState.isGhost && !selectedItemDef?.questItem; // No soltar items quest
        dropButton.disabled = !canDrop;
    }

function generateChestLoot(chestLevel = 1) {
        const generatedLoot = [];
        const baseItemCount = 1 + Math.floor(chestLevel / 5); // 1 item base + 1 cada 5 niveles
        const qualityBonus = chestLevel * 0.04; // 4% de bonus a calidad/rareza por nivel

        // --- Pools de Botín ---
        const lootPools = { common: [], uncommon: [], rare: [], epic: [] };
        for (const itemId in itemDefinitions) {
            const itemDef = itemDefinitions[itemId];
            // Excluir quest items, currency (oro se añade al final), y items sin valor/rareza
            if (!itemDef.questItem && itemDef.rarity && itemDef.type !== 'currency' && itemDef.value > 0) {
                 if (lootPools[itemDef.rarity]) {
                     // Añadir item al pool con peso y cantidad (más simple)
                     lootPools[itemDef.rarity].push({
                         id: itemId,
                         // Peso: Comunes más pesados, raros menos
                         weight: (itemDef.rarity === 'common' ? 15 : (itemDef.rarity === 'uncommon' ? 8 : (itemDef.rarity === 'rare' ? 3 : 1))),
                         minQty: 1, // Mínimo 1
                         maxQty: itemDef.stackable ? Math.max(1, Math.floor((itemDef.maxStack || 20) * 0.3)) : 1 // Máx ~30% del stack
                     });
                 }
            }
        }

        // --- Rolls por Rareza (Ajustado por Nivel/Calidad) ---
        const rolls = {
            common: Math.floor(Math.random() * 2) + baseItemCount,           // 1-2 + base
            uncommon: Math.floor(Math.random() * (1.8 + qualityBonus)),       // 0-1 o 0-2 con bonus
            rare: Math.floor(Math.random() * (0.5 + qualityBonus * 1.8)),   // Baja chance base, aumenta con nivel
            epic: Math.random() < (0.01 + qualityBonus * 0.15) ? 1 : 0,     // Muy baja chance base
        };

        // --- Selección Ponderada ---
        const selectWeightedItem = (pool) => { /* ... (código existente sin cambios) ... */
            if (!pool || pool.length === 0) return null;
            const totalWeight = pool.reduce((sum, item) => sum + item.weight, 0);
            if (totalWeight <= 0) return pool[Math.floor(Math.random() * pool.length)];
            let roll = Math.random() * totalWeight;
            for (const itemEntry of pool) { roll -= itemEntry.weight; if (roll <= 0) return itemEntry; }
            return pool[pool.length - 1]; // Fallback
        };


        // --- Generar Botín ---
        for (const rarity in rolls) {
            const count = rolls[rarity]; const pool = lootPools[rarity];
            if (count > 0 && pool?.length > 0) {
                for (let i = 0; i < count; i++) {
                    const selectedEntry = selectWeightedItem(pool);
                    if (selectedEntry) {
                         let qty = Math.floor(Math.random() * (selectedEntry.maxQty - selectedEntry.minQty + 1)) + selectedEntry.minQty;
                         qty = Math.max(1, Math.min(itemDefinitions[selectedEntry.id]?.maxStack || qty, qty));
                         // Apilar si ya existe en el loot generado
                         const existingLootItem = generatedLoot.find(l => l.id === selectedEntry.id);
                         if (existingLootItem && itemDefinitions[selectedEntry.id]?.stackable) {
                              const maxStack = itemDefinitions[selectedEntry.id]?.maxStack || Infinity;
                              const canAdd = maxStack - existingLootItem.count;
                              const amountToAdd = Math.min(qty, canAdd);
                              if(amountToAdd > 0) existingLootItem.count += amountToAdd;
                         } else { // Añadir nuevo
                              generatedLoot.push({ id: selectedEntry.id, count: qty });
                         }
                    }
                }
            }
        }

        // Añadir Oro
        const goldAmount = Math.floor((Math.random() * 15 + 8) * (1 + chestLevel * 0.25)); // Más oro base y escalado
         const goldEntry = generatedLoot.find(l => l.id === 'gold_coin');
         if (goldEntry) { goldEntry.count += goldAmount; }
         else { generatedLoot.push({ id: 'gold_coin', count: goldAmount }); }

        console.log(`Loot (Nvl ${chestLevel}):`, generatedLoot.map(l=>`${l.id}x${l.count}`)); // Log más conciso
        return generatedLoot;
    }

    function openChest(chestObject) {
        if (!chestObject?.userData || chestObject.userData.type !== 'chest' || !chestObject.userData.id) return;
        const chestId = chestObject.userData.id; const chestData = chestObject.userData;
        if (gameState.isGhost) { logMessage("Fantasmas no abren cofres.", "info"); return; }
        if (chestData.isOpen) { logMessage("Cofre ya abierto.", "info"); return; }
        if (chestData.isOpening) return; // Evitar doble click rápido
        if (chestObject.position.distanceToSquared(playerState.position) > INTERACT_DISTANCE_SQ * 1.1) { logMessage("Demasiado lejos.", "warning"); return; }

        // Estimar slots necesarios (mejorado)
        const lootItems = chestData.loot || []; let estimatedSlotsNeeded = 0; const tempInv = [...inventory.items];
        lootItems.forEach(loot => {
             const def = itemDefinitions[loot.id]; if(!def) return;
             if(!def.stackable) { estimatedSlotsNeeded++; return; }
             let remaining = loot.count;
             for(const invItem of tempInv) { if(invItem.id === loot.id && invItem.count < (def.maxStack || 99)) { const space = (def.maxStack||99) - invItem.count; const add = Math.min(remaining, space); invItem.count += add; remaining -= add; if(remaining <= 0) break; } }
             if(remaining > 0) estimatedSlotsNeeded += Math.ceil(remaining / (def.maxStack || 99));
        });
        const freeSlots = inventory.maxItems - inventory.items.length;
        if (freeSlots < estimatedSlotsNeeded) { logMessage("Inventario lleno.", "error"); showNotification("Inventario Lleno", "error"); AudioManager.playSound('ui_error', 0.4); return; }

        chestData.isOpening = true; logMessage("Abriendo cofre...", "system");
        AudioManager.playSound('chest_open', 0.6);
        const lidPivot = chestObject.getObjectByName("lidPivot");
        if (lidPivot) { // Animar tapa
             const targetRotationX = -Math.PI / 1.6; const duration = 500; const start = performance.now();
             function animate() { const now = performance.now(); const p = Math.min(1, (now - start) / duration); lidPivot.rotation.x = THREE.MathUtils.lerp(0, targetRotationX, p); if (p < 1) requestAnimationFrame(animate); else chestData.isOpening = false; }
             requestAnimationFrame(animate);
        } else { chestData.isOpening = false; }

        // Otorgar botín
        let lootMessageParts = []; let inventoryWasFull = false;
        lootItems.forEach(lootItem => {
            const itemDef = itemDefinitions[lootItem.id];
            if (itemDef) {
                const added = addItemToInventory(lootItem.id, lootItem.count);
                if (added) { lootMessageParts.push(`${getItemName(lootItem.id)}${lootItem.count > 1 ? ` x${lootItem.count}` : ''}`); }
                else { inventoryWasFull = true; spawnItem(lootItem, chestObject.position.clone().add(new THREE.Vector3(0, 0.5, 0))); if (!lootMessageParts.includes("(Objetos cayeron)")) lootMessageParts.push("(Objetos cayeron)"); }
            }
        });

        // Finalizar
        chestData.isOpen = true; chestData.loot = []; world.worldStateData.openedChests.add(chestId);
        let finalMsg = "Encontraste: " + lootMessageParts.filter(p => !p.includes("cayeron")).join(', ');
        if (inventoryWasFull) finalMsg += (finalMsg.endsWith(": ") ? "" : ". ") + "Inventario lleno, algunos objetos cayeron.";
        if (lootMessageParts.length > 0) { logMessage(finalMsg, "loot"); showNotification("Cofre abierto", "success"); }
        else if (!inventoryWasFull) { logMessage("Cofre vacío.", "info"); showNotification("Cofre vacío", "info"); }
        updateInventoryUI(); // Actualizar siempre
    }

    function harvestResource(resourceNode) {
        if (!resourceNode?.userData || resourceNode.userData.type !== 'resource' || !resourceNode.userData.id || !resourceNode.userData.resourceDefId) { console.warn("harvestResource: Nodo inválido."); return; }
        const nodeId = resourceNode.userData.id; const resourceDefId = resourceNode.userData.resourceDefId; const resourceDef = resourceDefinitions[resourceDefId];
        if (!resourceDef) { console.error(`Definición recurso ${resourceDefId} no encontrada.`); logMessage("Objeto desconocido.", "error"); return; }
        if (gameState.isGhost) { logMessage("Fantasmas no recolectan.", "info"); return; }
        if (resourceNode.userData.depleted) { logMessage(`${resourceDef.name || 'Fuente'} agotada.`, "info"); displayRespawnTimeNotification(nodeId); return; }
        if (resourceNode.userData.isHarvesting || resourceNode.userData.harvestTimeoutId) return;
        if (resourceNode.position.distanceToSquared(playerState.position) > INTERACT_DISTANCE_SQ * 1.1) { logMessage("Demasiado lejos.", "warning"); return; }

        // Check Requisitos
        const { requiredSkill, requiredLevel = 0, requiredToolId, toolRequiredEquipped = false } = resourceDef;
        const playerSkillLevel = playerState.skills[requiredSkill]?.level || 0;
        if (requiredSkill && playerSkillLevel < requiredLevel) { const skillName = skillDefinitions[requiredSkill]?.name || requiredSkill; logMessage(`Req: ${skillName} Nvl ${requiredLevel} (Tienes ${playerSkillLevel})`, "warning"); AudioManager.playSound('ui_error', 0.4); return; }
        let hasTool = !requiredToolId; const toolName = getItemName(requiredToolId);
        if (requiredToolId) { const equippedWpn = playerState.equipment?.weapon; if (equippedWpn?.id === requiredToolId) hasTool = true; else { const toolInInv = inventory.items.find(i => i.id === requiredToolId); if (toolInInv) { if (toolRequiredEquipped) { logMessage(`Equipa ${toolName}.`, "warning"); AudioManager.playSound('ui_error', 0.4); return; } else hasTool = true; } else { logMessage(`Necesitas ${toolName}.`, "warning"); AudioManager.playSound('ui_error', 0.4); return; } } }
        if (!hasTool) return; // Doble check por si acaso

        // Iniciar Recolección
        resourceNode.userData.isHarvesting = true; resourceNode.userData.interruptionFlag = false;
        const timeReductionFactor = Math.min(0.75, playerSkillLevel * 0.02); const harvestTime = Math.max(500, (resourceDef.baseHarvestTime || 1500) * (1 - timeReductionFactor));
        logMessage(`Recolectando ${resourceDef.name}... (${(harvestTime / 1000).toFixed(1)}s)`, "system");
        startHarvestVisualEffect(resourceNode, harvestTime);
        let soundInstance = resourceDef.harvestSound ? AudioManager.playSound(resourceDef.harvestSound, 0.3, true, 'sfx') : null;

        resourceNode.userData.harvestTimeoutId = setTimeout(() => {
            if (soundInstance) AudioManager.stopSound(soundInstance); stopHarvestVisualEffect(resourceNode);
            if (resourceNode.userData.interruptionFlag || !resourceNode.parent || resourceNode.userData.depleted || resourceNode.position.distanceToSquared(playerState.position) > INTERACT_DISTANCE_SQ * 1.4) { logMessage("Recolección interrumpida.", "warning"); resourceNode.userData.isHarvesting = false; resourceNode.userData.harvestTimeoutId = null; resourceNode.userData.interruptionFlag = false; return; }

            // Calcular Yield
            let finalYield = []; const baseItemId = resourceDef.baseItemId; const minAmount = resourceDef.baseItemMinAmount || 1; const maxAmount = resourceDef.baseItemMaxAmount || 1;
            const skillBonusAmount = Math.floor(playerSkillLevel / (resourceDef.skillYieldDivisor || 10)); // Ajustable por recurso
            const baseAmount = Math.floor(Math.random() * (maxAmount - minAmount + 1)) + minAmount + skillBonusAmount;
            if (baseItemId && baseAmount > 0) finalYield.push({ itemId: baseItemId, amount: baseAmount });
            const rareItemId = resourceDef.rareItemId; const baseRareChance = resourceDef.rareItemChance || 0; const skillBonusRareChance = playerSkillLevel * 0.001;
            if (rareItemId && Math.random() < (baseRareChance + skillBonusRareChance)) { finalYield.push({ itemId: rareItemId, amount: 1 }); logMessage(`¡Encontraste ${getItemName(rareItemId)}!`, 'loot', 5000); }

            // Añadir a Inventario
            let allAdded = true; let itemsAdded = [];
            for (const yieldItem of finalYield) { if (itemDefinitions[yieldItem.itemId]) { const added = addItemToInventory(yieldItem.itemId, yieldItem.amount); if (added) itemsAdded.push(yieldItem); else { allAdded = false; logMessage(`Inv. lleno, no se recogió ${yieldItem.amount} ${getItemName(yieldItem.itemId)}.`, "error"); showNotification("Inventario Lleno", "error"); break; } } }

            // Finalizar
            if (itemsAdded.some(item => item.itemId === baseItemId)) {
                itemsAdded.forEach(item => logMessage(`Recolectaste ${item.amount} ${getItemName(item.itemId)}.`, "loot"));
                if (AudioManager && resourceDef.successSound) AudioManager.playSound(resourceDef.successSound, 0.6);
                if (requiredSkill) { const baseXP = resourceDef.skillXpBase || 5; const levelMultiplier = resourceDef.skillXpLevelMultiplier || 1; const levelDiffBonus = Math.max(0, playerSkillLevel - requiredLevel) * 0.5; const xpAmount = Math.max(1, Math.floor(baseXP + levelDiffBonus)); gainSkillExperience(requiredSkill, xpAmount); }
                resourceNode.userData.depleted = true; const depletionTimestamp = Date.now(); world.worldStateData.depletedNodes[nodeId] = depletionTimestamp;
                resourceNode.scale.set(0.4, 0.4, 0.4); if (resourceNode.material instanceof THREE.MeshStandardMaterial) { if (!resourceNode.material.clonedForDepletion) { resourceNode.material = resourceNode.material.clone(); resourceNode.material.clonedForDepletion = true; } resourceNode.material.opacity = 0.25; resourceNode.material.transparent = true; resourceNode.material.depthWrite = false; }
                scheduleNodeRespawn(resourceNode, depletionTimestamp, resourceDef.respawnTime || RESOURCE_RESPAWN_TIME);
            } else if (!allAdded) { logMessage("Recolección fallida, inventario lleno.", "warning"); if(AudioManager) AudioManager.playSound('ui_error', 0.4); }
            resourceNode.userData.isHarvesting = false; resourceNode.userData.harvestTimeoutId = null; resourceNode.userData.interruptionFlag = false;
        }, harvestTime);
    }

    function displayRespawnTimeNotification(nodeId) {
        const depletionTime = world.worldStateData.depletedNodes[nodeId];
        if (depletionTime) {
            const defId = nodeId.split('_')[0]; const nodeDef = resourceDefinitions[defId]; const respawnDelay = nodeDef?.respawnTime || RESOURCE_RESPAWN_TIME;
            const timeRemaining = Math.max(0, respawnDelay - (Date.now() - depletionTime));
            if (timeRemaining > 1000) { const m = Math.floor(timeRemaining/60000); const s = Math.floor((timeRemaining%60000)/1000); showNotification(`Regenera en ${m}m ${s}s`, "info", 2000); }
        }
    }

    function startHarvestVisualEffect(node, duration) {
         if (!node.userData.visualEffect) { const light = new THREE.PointLight(0xffffaa, 0, 1.5, 2); light.position.y = 0.6; node.add(light); node.userData.visualEffect = light; node.userData.visualEffectStartTime = performance.now(); node.userData.visualEffectDuration = duration; animateHarvestVisual(node); }
    }

    function animateHarvestVisual(node) {
        const light = node.userData.visualEffect; const startTime = node.userData.visualEffectStartTime; const duration = node.userData.visualEffectDuration;
        if (!light || !startTime || !duration || !node.userData.isHarvesting || node.userData.interruptionFlag) { stopHarvestVisualEffect(node); return; }
        const elapsed = performance.now() - startTime; const progress = elapsed / duration;
        light.intensity = Math.sin(progress * Math.PI * 6) * 0.4 + 0.6; // Pulso
        if (progress < 1 && node.userData.isHarvesting && !node.userData.interruptionFlag) { requestAnimationFrame(() => animateHarvestVisual(node)); }
        else { stopHarvestVisualEffect(node); } // Detener si termina, se interrumpe o deja de recolectar
    }

    function stopHarvestVisualEffect(node) {
         if (node.userData.visualEffect) { node.remove(node.userData.visualEffect); node.userData.visualEffect = null; node.userData.visualEffectStartTime = null; node.userData.visualEffectDuration = null;}
    }

    /**
     * Obtiene el nombre legible de un atributo a partir de su clave interna.
     * @param {string | null | undefined} attributeKey - Clave interna ('strength', 'dexterity', etc.).
     * @returns {string} - Nombre legible ("Fuerza", "Destreza", etc.) o fallback.
     */
    function getAttributeName(attributeKey) {
        if (typeof attributeKey !== 'string' || !attributeKey) return "[Atributo Inválido]";
        const attributeNameMap = {
            strength: "Fuerza", dexterity: "Destreza", intelligence: "Inteligencia", constitution: "Constitución",
            // Añadir otros si se usan en el futuro
        };
        const readableName = attributeNameMap[attributeKey.toLowerCase()];
        return readableName || attributeKey.charAt(0).toUpperCase() + attributeKey.slice(1); // Devolver clave capitalizada si no hay traducción
    }

    /**
     * Selecciona o deselecciona un item del inventario al hacer clic en su slot.
     * Actualiza el estado `inventory.selectedItemIndex`, la clase CSS 'selected'
     * y los botones de acción.
     * @param {number} index - Índice del slot clickeado.
     */
    function selectInventoryItem(index) {
        if (typeof index !== 'number' || index < 0 || index >= inventory.maxItems) return;
        exitSpellTargetingMode(); cancelAiming(); playerState.isChargingAttack = false; // Cancelar otras acciones

        const previouslySelectedIndex = inventory.selectedItemIndex;
        if (previouslySelectedIndex !== null) { const prevSlot = document.querySelector(`.inventory-slot[data-index="${previouslySelectedIndex}"]`); if (prevSlot) prevSlot.classList.remove('selected'); }

        if (previouslySelectedIndex === index || index >= inventory.items.length) {
            inventory.selectedItemIndex = null; // Deseleccionar
        } else {
            inventory.selectedItemIndex = index; // Seleccionar nuevo
            const newSlot = document.querySelector(`.inventory-slot[data-index="${index}"]`); if (newSlot) newSlot.classList.add('selected');
        }
        updateActionButtons(); // Actualizar botones según nueva selección
        if (previouslySelectedIndex !== inventory.selectedItemIndex) AudioManager.playSound('ui_confirm', 0.3); // Sonido si cambió la selección
    }

    /**
     * Obtiene el nombre legible de un objeto a partir de su ID.
     * @param {string | null | undefined} itemId - ID del objeto.
     * @returns {string} - Nombre legible o fallback.
     */
    function getItemName(itemId) {
        if (typeof itemId !== 'string' || !itemId) return "[ID Inválido]";
        const itemDefinition = itemDefinitions[itemId];
        if (itemDefinition?.name) return itemDefinition.name;
        console.warn(`getItemName: Definición/nombre no encontrado para ID: ${itemId}`);
        return `[${itemId}]`; // Fallback: mostrar ID
    }

    /**
     * Obtiene el nombre legible de un slot de equipamiento.
     * @param {string | null | undefined} slotKey - Clave interna ('head', 'weapon', etc.).
     * @returns {string} - Nombre legible ("Cabeza", "Arma", etc.) o fallback.
     */
    function getSlotName(slotKey) {
        if (typeof slotKey !== 'string' || !slotKey) return "[Slot Inválido]";
        const slotNameMap = {
            head: "Cabeza", chest: "Pecho", legs: "Piernas", feet: "Pies",
            weapon: "Arma", shield: "Escudo", amulet: "Amuleto",
            ring: "Anillo", ring1: "Anillo 1", ring2: "Anillo 2",
            gloves: "Guantes", belt: "Cinturón", back: "Espalda"
        };
        const readableName = slotNameMap[slotKey];
        return readableName || slotKey.charAt(0).toUpperCase() + slotKey.slice(1);
    }

    /**
     * Oculta el tooltip activo y limpia timeouts pendientes.
     */
    function hideTooltip() {
        if (gameState.tooltipTimeout) { clearTimeout(gameState.tooltipTimeout); gameState.tooltipTimeout = null; }
        if (gameState.activeTooltip instanceof HTMLElement) { gameState.activeTooltip.style.display = 'none'; }
        gameState.activeTooltip = null;
    }

    /**
     * Posiciona un tooltip cerca del cursor, ajustando para que no salga de la pantalla.
     * @param {HTMLElement} tooltipElement - El elemento del tooltip.
     * @param {MouseEvent} event - El evento de ratón para obtener coords.
     */
    function positionTooltip(tooltipElement, event) {
        if (!(tooltipElement instanceof HTMLElement) || !event) return;
        const margin = 18; let x = event.clientX + margin; let y = event.clientY + margin;
        // Forzar reflow para obtener dimensiones correctas si es necesario (a veces display:none lo impide)
        // tooltipElement.style.display = 'block'; // Mostrar temporalmente para medir
        const tooltipWidth = tooltipElement.offsetWidth; const tooltipHeight = tooltipElement.offsetHeight;
        // tooltipElement.style.display = 'none'; // Ocultar de nuevo si se forzó
        const windowWidth = window.innerWidth; const windowHeight = window.innerHeight;
        if (x + tooltipWidth > windowWidth - margin) x = event.clientX - tooltipWidth - margin;
        if (x < margin) x = margin;
        if (y + tooltipHeight > windowHeight - margin) y = event.clientY - tooltipHeight - margin;
        if (y < margin) y = margin;
        tooltipElement.style.left = `${Math.round(x)}px`; tooltipElement.style.top = `${Math.round(y)}px`;
        // Asegurar que display sea block después de posicionar
        // tooltipElement.style.display = 'block'; // Se hace en la función show...Tooltip
    }

    /**
     * (OPTIMIZADA v2 - DOM Checks)
     * Actualiza los elementos principales de la UI del jugador (barras, nombre, nivel, oro).
     * Evita actualizaciones innecesarias del DOM.
     */
    function updatePlayerUI() {
        if (!playerState?.stats || !playerState.attributes) return;

        // --- Información Básica ---
        const updateTextContent = (elementId, newValue) => {
            const element = domCache[elementId];
            // Verificar si es HTMLElement y si el contenido realmente cambió
            if (element instanceof HTMLElement && element.textContent !== newValue.toString()) {
                element.textContent = newValue.toString();
            } else if (!updatePlayerUI.warnedIds?.has(elementId) && !(element instanceof HTMLElement)) { // Advertir solo una vez si falta
                 console.warn(`updatePlayerUI: Elemento #${elementId} no encontrado.`);
                 if(!updatePlayerUI.warnedIds) updatePlayerUI.warnedIds = new Set();
                 updatePlayerUI.warnedIds.add(elementId);
            }
        };
        updateTextContent('player-name', playerState.name || 'Héroe');
        updateTextContent('player-level', playerState.level);
        updateTextContent('gold-text', playerState.gold);

        // --- Barras de Estado ---
        updateStatusBar('health', playerState.stats.health, playerState.stats.maxHealth, true);
        updateStatusBar('mana', playerState.stats.mana, playerState.stats.maxMana);
        updateStatusBar('stamina', playerState.stats.stamina, playerState.stats.maxStamina);
        updateStatusBar('xp', playerState.xp, playerState.xpToNextLevel);

        // --- Efectos de Estado (Llama a su propia función de UI) ---
        updateStatusEffectsUI();

        // --- Actualizar Hoja Personaje si está abierta ---
        if (gameState.isCharacterSheetOpen) updateCharacterSheet();
        // --- Actualizar Hotbar (si existe) ---
        if (domCache['action-bar']) updateActionSlotsUI();
         // --- Actualizar Quest Tracker (si existe) ---
        if (domCache['quest-tracker']) updateQuestTrackerUI();
    }
    updatePlayerUI.warnedIds = new Set(); // Inicializar Set para warnings

    /**
     * Función auxiliar para actualizar una barra de estado específica (progreso y texto).
     * Optimizado para minimizar cambios en el DOM.
     * @param {string} type - Tipo ('health', 'mana', 'stamina', 'xp').
     * @param {number} current - Valor actual.
     * @param {number} max - Valor máximo.
     * @param {boolean} [checkLow=false] - Aplicar clase 'low-health'.
     */
    function updateStatusBar(type, current, max, checkLow = false) {
        const barElement = domCache[`${type}-bar`]; const textElement = domCache[`${type}-text`];
        const statBarContainer = barElement?.parentElement;
        if (!(barElement instanceof HTMLElement) || !(statBarContainer instanceof HTMLElement)) { if(!updateStatusBar.warnedIds?.has(type)){ console.warn(`Barra ${type} o contenedor no encontrado.`); if(!updateStatusBar.warnedIds) updateStatusBar.warnedIds=new Set(); updateStatusBar.warnedIds.add(type);} return; }
        updateStatusBar.warnedIds?.delete(type); // Resetear warning si se encuentra

        // Cálculo Porcentaje
        const maxValid = Math.max(1, max); const currentValid = Math.max(0, current);
        const percentage = Math.min(100, (currentValid / maxValid) * 100);
        const newWidth = `${percentage.toFixed(1)}%`;

        // Actualizar Ancho (Solo si cambia)
        if (barElement.style.width !== newWidth) barElement.style.width = newWidth;

        // Actualizar Texto (Solo si cambia)
        if (textElement instanceof HTMLElement) {
            const currentFormatted = Math.floor(current); const maxFormatted = Math.floor(max);
            const newText = `${currentFormatted}/${maxFormatted}`;
            if (textElement.textContent !== newText) textElement.textContent = newText;
        } else if(!updateStatusBar.warnedIds?.has(`${type}-text`)) { console.warn(`Texto #${type}-text no encontrado.`); if(!updateStatusBar.warnedIds) updateStatusBar.warnedIds=new Set(); updateStatusBar.warnedIds.add(`${type}-text`); }

        // Clases Especiales
        if (checkLow) statBarContainer.classList.toggle('low-health', percentage < 25 && max > 0);
        if (type === 'health') barElement.classList.toggle('ghost-mode', gameState.isGhost);
    }
    updateStatusBar.warnedIds = new Set(); // Inicializar Set para warnings

    function updateInventoryUI() { // Añadir listener para asignar a hotbar y usar imágenes
        const inventoryGrid = domCache['inventory-grid']; const maxItems = inventory.maxItems;
        if (!(inventoryGrid instanceof HTMLElement)) { console.error("updateInventoryUI: #inventory-grid no encontrado."); return; }
        let slots = inventoryGrid.children;
        // Auto-corrección de slots
        if (slots.length !== maxItems) {
            console.warn(`updateInventoryUI: Regenerando slots (${slots.length} != ${maxItems}).`);
            inventoryGrid.innerHTML = '';
            for (let i = 0; i < maxItems; i++) {
                const slotElement = document.createElement('div'); slotElement.className = 'inventory-slot'; slotElement.dataset.index = i.toString();
                slotElement.addEventListener('click', () => selectInventoryItem(i));
                slotElement.addEventListener('contextmenu', (e) => { e.preventDefault(); handleInventoryContextMenu(i, e); });
                inventoryGrid.appendChild(slotElement);
            }
            slots = inventoryGrid.children; if (slots.length !== maxItems) { console.error("Fallo crítico regenerando slots."); return; }
        }

        // Actualizar cada slot
        for (let i = 0; i < maxItems; i++) {
            const slotElement = slots[i]; if (!(slotElement instanceof HTMLElement)) continue;
            const itemData = inventory.items[i]; const itemDef = itemData ? itemDefinitions[itemData.id] : null;
            let mouseEnterListener = null; let mouseLeaveListener = null;
            // Limpiar listeners tooltip/context
            if (slotElement.currentMouseEnterListener) slotElement.removeEventListener('mouseenter', slotElement.currentMouseEnterListener);
            if (slotElement.currentMouseLeaveListener) slotElement.removeEventListener('mouseleave', slotElement.currentMouseLeaveListener);
            if (slotElement.currentContextMenuListener) slotElement.removeEventListener('contextmenu', slotElement.currentContextMenuListener);
            slotElement.currentMouseEnterListener=null; slotElement.currentMouseLeaveListener=null; slotElement.currentContextMenuListener=null;

            if (itemData && itemDef) { // Slot Ocupado
                let iconDiv = slotElement.querySelector('.inventory-item');
                const iconHTML = itemDef.icon_type === 'html' ? itemDef.icon : `<span style="font-size:22px;">${itemDef.icon || '❓'}</span>`;
                if (!iconDiv) { iconDiv = document.createElement('div'); iconDiv.className = 'inventory-item'; slotElement.appendChild(iconDiv); }
                if (iconDiv.innerHTML !== iconHTML) iconDiv.innerHTML = iconHTML;

                let countDiv = slotElement.querySelector('.item-count'); const showCount = itemDef.stackable && itemData.count > 1;
                if (showCount) { const countContent = itemData.count.toString(); if (!countDiv) { countDiv = document.createElement('div'); countDiv.className = 'item-count'; slotElement.appendChild(countDiv); } if (countDiv.textContent !== countContent) countDiv.textContent = countContent; }
                else if (countDiv) { slotElement.removeChild(countDiv); }

                const rarity = itemDef.rarity || 'common'; const targetRarityClass = `item-rarity-${rarity}`; const rarityClasses = ['common','uncommon','rare','epic','legendary','quest'].map(r=>`item-rarity-${r}`); let needsRarityUpdate = true;
                for(const cls of rarityClasses) { if(slotElement.classList.contains(cls)){ if(cls!==targetRarityClass) slotElement.classList.remove(cls); else needsRarityUpdate=false; } }
                if(needsRarityUpdate) slotElement.classList.add(targetRarityClass);
                if(!slotElement.classList.contains('inventory-slot')) slotElement.classList.add('inventory-slot');

                mouseEnterListener = (e) => handleInventorySlotMouseEnter(e); mouseLeaveListener = hideTooltip;
                slotElement.addEventListener('mouseenter', mouseEnterListener); slotElement.addEventListener('mouseleave', mouseLeaveListener);
                slotElement.currentMouseEnterListener = mouseEnterListener; slotElement.currentMouseLeaveListener = mouseLeaveListener;

                const contextMenuListener = (e) => { e.preventDefault(); handleInventoryContextMenu(i, e); };
                slotElement.addEventListener('contextmenu', contextMenuListener); slotElement.currentContextMenuListener = contextMenuListener;

            } else { // Slot Vacío
                if (slotElement.innerHTML !== '') slotElement.innerHTML = '';
                slotElement.className = 'inventory-slot';
            }
            slotElement.classList.toggle('selected', i === inventory.selectedItemIndex);
        }
        updateActionButtons();
    }
    
    function equipSelectedItem() {
        if (inventory.selectedItemIndex === null || inventory.selectedItemIndex >= inventory.items.length) { logMessage("Selecciona un objeto para equipar.", "info"); return; }
        const itemInstance = inventory.items[inventory.selectedItemIndex];
        if (!itemInstance) { console.error("Item seleccionado inválido."); return; }
        const itemDef = itemDefinitions[itemInstance.id];

        const validEquipTypes = ['weapon', 'armor', 'amulet', 'ring', 'shield'];
        if (!itemDef?.slot || !validEquipTypes.includes(itemDef.type)) { logMessage("Este objeto no se puede equipar.", "warning"); AudioManager.playSound('ui_error', 0.4); return; }

        // --- Check Requirements (with specific class message) ---
        if (!checkItemRequirements(itemDef)) {
            let reason = "No cumples los requisitos";
            // Check if the failure was specifically the class requirement
            if (itemDef.allowedClasses && Array.isArray(itemDef.allowedClasses) && itemDef.allowedClasses.length > 0 && !itemDef.allowedClasses.includes(playerState.class)) {
                 reason = `Tu clase (${playerState.class}) no puede usar este objeto`; // <<< SPECIFIC MESSAGE
                 console.log(`Equip Failed: Class mismatch for ${itemDef.name}. Player: ${playerState.class}, Allowed: ${itemDef.allowedClasses.join(',')}`); // Console log
            } else if (itemDef.requirements?.level && playerState.level < itemDef.requirements.level){
                 reason = `Requiere Nivel ${itemDef.requirements.level}`;
            } // Add checks for attributes if needed for the message

            logMessage(`${reason} para equipar ${itemDef.name}.`, "warning");
            AudioManager.playSound('ui_error', 0.4);
            return;
        }
        // --- End Requirement Check ---

        if (gameState.isGhost) { logMessage("No puedes equipar como fantasma.", "info"); return; }

        // ... (rest of the equipping logic remains the same) ...
        let targetSlot = itemDef.slot;
        let isTwoHanded = itemDef.twoHanded || false;
        let offHandSlot = 'shield';

        if (targetSlot === 'ring') { targetSlot = playerState.equipment?.ring1 ? (playerState.equipment?.ring2 ? 'ring1' : 'ring2') : 'ring1'; }

        const currentlyEquippedItem = playerState.equipment?.[targetSlot] || null;
        const offHandItem = isTwoHanded ? (playerState.equipment?.[offHandSlot] || null) : null;

        let slotsNeeded = 0; if (currentlyEquippedItem) slotsNeeded++; if (offHandItem) slotsNeeded++;
        const freeSlots = inventory.maxItems - inventory.items.length;
        if (freeSlots < slotsNeeded) { logMessage("Inventario lleno para desequipar.", "error"); showNotification("Inventario lleno", "error"); AudioManager.playSound('ui_error', 0.4); return; }

        if (!playerState.equipment) playerState.equipment = {};
        const originalIndex = inventory.selectedItemIndex;

        if (currentlyEquippedItem) { inventory.items.push(currentlyEquippedItem); playerState.equipment[targetSlot] = null; logMessage(`Desequipado: ${currentlyEquippedItem.name}.`, "system"); AudioManager.playSound('unequip', 0.5); }
        if (isTwoHanded && offHandItem) { inventory.items.push(offHandItem); playerState.equipment[offHandSlot] = null; logMessage(`Desequipado: ${offHandItem.name} (por 2H).`, "system"); }
        if (targetSlot === offHandSlot) { const mainHandWpn = playerState.equipment?.weapon; if (mainHandWpn && itemDefinitions[mainHandWpn.id]?.twoHanded) { if (freeSlots < slotsNeeded + 1) { logMessage("Inv. lleno para desequipar arma 2H.", "error"); if(currentlyEquippedItem) inventory.items.pop(); playerState.equipment[targetSlot] = currentlyEquippedItem; return; } inventory.items.push(mainHandWpn); playerState.equipment.weapon = null; logMessage(`Desequipado: ${mainHandWpn.name} (equipando ${offHandSlot}).`, "system"); AudioManager.playSound('unequip', 0.5); } }

        playerState.equipment[targetSlot] = itemInstance;
        inventory.items.splice(originalIndex, 1);
        deselectInventoryItem();

        AudioManager.playSound('equip', 0.5); logMessage(`Equipado: ${itemDef.name} en ${getSlotName(targetSlot)}.`, "system");

        updatePlayerAppearance(); updatePlayerStats(); updateInventoryUI(); updateEquipmentUI(); updatePlayerUI(); updateCharacterSheet(); updateActionButtons();
    }
    
        /**
     * Verifica si el jugador cumple los requisitos para usar/equipar un item.
     * (v3 - Added allowedClasses check & Logging)
     * @param {object} itemDef - La definición del item a verificar.
     * @returns {boolean} - True si cumple los requisitos, false si no.
     */
    function checkItemRequirements(itemDef) {
        const functionName = "checkItemRequirements (v3)";
        if (!itemDef) {
            // console.log(`[${functionName}] No item definition provided.`);
            return true; // No definition means no requirements
        }
        const reqs = itemDef.requirements;
        const allowedClasses = itemDef.allowedClasses; // Get the new property

        // --- Log Inicial ---
        // console.log(`[${functionName}] Checking reqs for: ${itemDef.name}`);

        // --- Check Level ---
        if (reqs?.level && playerState.level < reqs.level) {
            console.log(`[${functionName}] FAILED: Level requirement not met for ${itemDef.name} (${playerState.level} < ${reqs.level})`);
            return false;
        }

        // --- Check Class (Using allowedClasses) ---
        // Check if allowedClasses is defined and is an array with elements
        if (allowedClasses && Array.isArray(allowedClasses) && allowedClasses.length > 0) {
            // Check if the player's current class is NOT included in the allowed list
            if (!allowedClasses.includes(playerState.class)) {
                console.log(`[${functionName}] FAILED: Class requirement not met for ${itemDef.name} (${playerState.class} not in [${allowedClasses.join(', ')}])`);
                return false; // Requirement failed
            } else {
                // console.log(`[${functionName}] PASSED: Class requirement met for ${itemDef.name}.`); // Optional success log
            }
        }
        // --- Check OLD classRequirement (for backward compatibility or specific use cases) ---
        // You might want to keep this *or* remove it if `allowedClasses` replaces it entirely.
        // For now, let's keep it as an additional check if needed.
        if (itemDef.classRequirement && Array.isArray(itemDef.classRequirement) && itemDef.classRequirement.length > 0) {
            if (!itemDef.classRequirement.includes(playerState.class)) {
                 console.log(`[${functionName}] FAILED: Secondary Class requirement check not met for ${itemDef.name} (${playerState.class} not in [${itemDef.classRequirement.join(', ')}])`);
                 return false;
             }
        }


        // --- Check Attributes ---
        if (reqs?.attributes) {
            for (const attrKey in reqs.attributes) {
                const requiredValue = reqs.attributes[attrKey];
                const playerValue = playerState.attributes[attrKey] || 0;
                if (playerValue < requiredValue) {
                    console.log(`[${functionName}] FAILED: Attribute requirement not met for ${itemDef.name} (${attrKey}: ${playerValue} < ${requiredValue})`);
                    return false;
                }
            }
        }

        // --- Passed all checks ---
        // console.log(`[${functionName}] PASSED all requirements for: ${itemDef.name}`);
        return true;
    }
    
     /**
     * Maneja la acción del botón/tecla "Usar/Lanzar".
     * Determina si usar un item consumible o iniciar el lanzamiento/targeting de un hechizo.
     * (v3 - Handles Targeting Mode Correctly)
     */
    function useOrCastSelectedItem() {
        const functionName = "useOrCastSelectedItem (v3)";
        console.log(`[${functionName}] Triggered.`);

        // --- 1. Validaciones Iniciales ---
        if (gameState.isGhost) { logMessage("Fantasmas no pueden actuar.", "warning"); return; }
        if (gameState.isTargetingSpell || gameState.isAimingWithBow) { console.log(`[${functionName}] Aborting: Already targeting/aiming.`); return; } // Prevent action if already targeting

        let actionInitiated = false;

        // --- 2. Intentar Usar Item Seleccionado ---
        if (inventory.selectedItemIndex !== null && inventory.selectedItemIndex < inventory.items.length) {
            const itemInstance = inventory.items[inventory.selectedItemIndex];
            if (itemInstance) {
                const itemDef = itemDefinitions[itemInstance.id];
                // Check if it's a usable item (consumable or spellscroll with a use function)
                if (itemDef && (itemDef.type === 'consumable' || itemDef.type === 'spellscroll') && typeof itemDef.use === 'function') {
                    console.log(`[${functionName}] Attempting to use selected item: ${itemDef.name}`);
                    useSelectedItem(); // Calls the item's specific use logic
                    actionInitiated = true;
                }
            }
        }

        // --- 3. Intentar Lanzar Hechizo Seleccionado (Only if no item was used) ---
        if (!actionInitiated && spells.selectedSpellIndex !== null && spells.selectedSpellIndex < spells.known.length) {
            const spellInstance = spells.known[spells.selectedSpellIndex];
            if (spellInstance) {
                const spellDef = spellDefinitions[spellInstance.id];
                if (spellDef) {
                    console.log(`[${functionName}] Attempting to cast selected spell: ${spellDef.name}`);
                    // --- a. Check Cooldown, Mana, Requirements (Preliminary) ---
                    if ((spellInstance.cooldownRemaining || 0) > 50) { logMessage(`${spellDef.name} en enfriamiento.`, "warning"); console.log(`[${functionName}] Spell Cast Aborted: Cooldown.`); return; }
                    const finalManaCost = Math.floor((spellDef.manaCost || 0) * (playerState.manaCostMultiplier || 1));
                    if (playerState.stats.mana < finalManaCost) { logMessage("No tienes suficiente maná.", "warning"); AudioManager.playSound('ui_error', 0.4); console.log(`[${functionName}] Spell Cast Aborted: Not enough mana.`); return; }
                    if (spellDef.requiredSkillLevel) { const skillId = Object.keys(spellDef.requiredSkillLevel)[0]; const reqLevel = spellDef.requiredSkillLevel[skillId]; if ((playerState.skills[skillId]?.level || 0) < reqLevel) { logMessage(`Requiere Nivel ${reqLevel} de ${skillDefinitions[skillId]?.name || skillId}.`, "warning"); console.log(`[${functionName}] Spell Cast Aborted: Skill requirement.`); return; } }

                    // --- b. Determine Action: Self-Cast or Enter Targeting ---
                    actionInitiated = true; // An action will be taken
                    const isSelfCast = spellDef.targetType === 'self' || spellDef.type === 'buff' || spellDef.type === 'healing';
                    const requiresTargeting = !isSelfCast;

                    if (isSelfCast) {
                        console.log(`[${functionName}] Self-casting ${spellDef.name}`);
                        castSpellAtTarget(spellDef, playerModel); // Cast immediately
                        // DO NOT DESELECT SPELL HERE
                    } else if (requiresTargeting) {
                        console.log(`[${functionName}] Entering targeting mode for ${spellDef.name}`);
                        enterSpellTargetingMode(spellDef); // Enter targeting mode
                        // DO NOT DESELECT SPELL HERE
                    } else {
                        console.warn(`[${functionName}] Unhandled spell type/target combination for ${spellDef.id}`);
                        logMessage("No se puede lanzar este hechizo ahora.", "error");
                        actionInitiated = false;
                    }
                } else { console.error(`[${functionName}] Spell definition missing for ID: ${spellInstance.id}`); }
            } else { console.error(`[${functionName}] Spell instance invalid at index: ${spells.selectedSpellIndex}`); }
        }

        // --- 4. Feedback if Nothing Selected ---
        if (!actionInitiated && inventory.selectedItemIndex === null && spells.selectedSpellIndex === null) {
            logMessage("Selecciona un objeto o hechizo para usar/lanzar.", "info");
        }

        // --- 5. Update Buttons ---
        // This is important to reflect cooldowns or if targeting started
        updateActionButtons();
        console.log(`[${functionName}] Finished. Action Initiated: ${actionInitiated}`);

    } // --- Fin useOrCastSelectedItem (v3) ---

    
    /**
     * Añade un hechizo a la lista de hechizos conocidos del jugador.
     * @param {string} spellId - El ID del hechizo a aprender.
     * @returns {boolean} - True si el hechizo se aprendió con éxito, False si ya se conocía o es inválido.
     */
    function learnSpell(spellId) {
        if (!spellDefinitions[spellId]) {
            console.error(`learnSpell: Definición no encontrada para el hechizo ID: ${spellId}`);
            logMessage("Error: Pergamino inválido.", "error");
            return false; // Indicar fallo, no consumir scroll
        }
        if (spells.known.some(s => s.id === spellId)) {
            logMessage(`Ya conoces el hechizo ${spellDefinitions[spellId].name}.`, "info");
            return false; // Ya lo conoce, no consumir scroll
        }

        const spellDef = spellDefinitions[spellId];
        // Añadir copia de la definición con estado inicial
        spells.known.push({
            ...spellDef, // Copiar todas las propiedades de la definición
            id: spellId, // Asegurar que el ID esté presente
            cooldownRemaining: 0 // Estado inicial
        });

        logMessage(`¡Has aprendido el hechizo: ${spellDef.name}!`, "success");
        showNotification(`Nuevo Hechizo Aprendido: ${spellDef.name}`, "magic");
        AudioManager.playSound('quest_accept', 0.6); // Reutilizar sonido de quest? O uno nuevo?

        updateSpellsUI(); // Actualizar la lista visual de hechizos
        // No necesariamente actualizamos botones aquí, depende de si estaba seleccionado
        // updateActionButtons();

        console.log(`Hechizo ${spellId} aprendido.`);
        return true; // Éxito, indica que el scroll puede ser consumido
    }
    // --- FIN NUEVA FUNCIÓN ---



  // === MODIFICADA: useSelectedItem ===
    function useSelectedItem() {
        if (inventory.selectedItemIndex === null || inventory.selectedItemIndex >= inventory.items.length) return;
        if (gameState.isGhost) { logMessage("No puedes usar objetos como fantasma.", "warning"); return; }

        const itemInstance = inventory.items[inventory.selectedItemIndex];
        if (!itemInstance) { console.error("useSelectedItem: itemInstance es null/undefined."); return; } // Check extra
        const itemDef = itemDefinitions[itemInstance.id];

        if (!itemDef) { console.error(`useSelectedItem: itemDef no encontrada para ID: ${itemInstance.id}`); return; }

        let usedSuccessfully = false;

        if (itemDef.type === 'consumable' && typeof itemDef.use === 'function') {
            // Usar consumible
            usedSuccessfully = itemDef.use(playerState, itemInstance); // Llama a la función use del item
            if (usedSuccessfully) {
                 logMessage(`Has usado ${itemDef.name}.`, 'system');
                 AudioManager.playSound(`use_${itemDef.id}`.startsWith('use_potion') ? 'use_potion' : 'ui_confirm', 0.5);
            } else {
                 AudioManager.playSound('ui_error', 0.4); // use() ya mostró mensaje
            }
        } else if (itemDef.type === 'spellscroll' && typeof itemDef.use === 'function') {
            // Usar pergamino para aprender hechizo
            // La función 'use' del pergamino llama a learnSpell()
            usedSuccessfully = itemDef.use(playerState, itemInstance); // learnSpell devuelve true si aprende, false si ya lo sabe
            // El mensaje/sonido se maneja dentro de learnSpell
        } else {
            logMessage("Este objeto no se puede usar.", "warning");
            AudioManager.playSound('ui_error', 0.4);
            return; // Salir si no es usable
        }

        // Si se usó exitosamente (consumible o pergamino aprendido):
        if (usedSuccessfully) {
             itemInstance.count--;
             if (itemInstance.count <= 0) {
                  const idxToRemove = inventory.selectedItemIndex; // Guardar antes de deseleccionar
                  inventory.items.splice(idxToRemove, 1);
                  deselectInventoryItem(); // Actualiza botones y UI inventario
             } else {
                  updateInventoryUI(); // Actualizar count en UI
             }
             updatePlayerUI(); // Actualizar stats si es necesario (ej: poción)
             updateActionButtons(); // Re-evaluar botones
        } else {
             // Si learnSpell devolvió false (ya conocido), no se consume el pergamino
             // Si la poción no se pudo usar (vida llena), tampoco se consume
             updateActionButtons(); // Re-evaluar botones de todos modos
        }
    }
    // --- FIN MODIFICADA: useSelectedItem ---



/**
 * Inicia el proceso para soltar el item seleccionado.
 * Llama a openDropItemPanel si el stack es > 1.
 * (v5 - Llama a nuevo panel)
 */
function dropSelectedItem() {
    if (gameState.isGhost) { logMessage("Fantasmas no sueltan objetos.", "info"); return; }
    console.log("[dropSelectedItem v5] Called.");

    if (inventory.selectedItemIndex === null || inventory.selectedItemIndex >= inventory.items.length) {
        logMessage("Selecciona objeto para soltar.", "info"); return;
    }
    const itemToDropOriginal = inventory.items[inventory.selectedItemIndex];
    if (!itemToDropOriginal) { console.error("[dropSelectedItem] Item seleccionado inválido."); return; }
    const itemDef = itemDefinitions[itemToDropOriginal.id];
    if (!itemDef) { console.error(`[dropSelectedItem] Definición no encontrada: ${itemToDropOriginal.id}`); return; }
    if (itemDef.questItem) { logMessage("No puedes soltar objetos de misión.", "warning"); AudioManager.playSound('ui_error', 0.4); return; }

    const currentCount = itemToDropOriginal.count || 1;
    console.log(`[dropSelectedItem] Processing: ${itemDef.name}, Count: ${currentCount}, Stackable: ${itemDef.stackable}`);

    // --- Lógica de Cantidad ---
    if (itemDef.stackable && currentCount > 1) {
        console.log("[dropSelectedItem] Stack > 1. Llamando a openDropItemPanel...");
        // *** LLAMAR AL NUEVO PANEL ***
        openDropItemPanel(itemToDropOriginal.id, itemDef.name, itemDef.icon, itemDef.icon_type, currentCount, inventory.selectedItemIndex);
    } else {
        // Soltar directamente (Single Item or Non-Stackable)
        console.log("[dropSelectedItem] Soltando directamente 1 item...");
        // La lógica de confirmDropSpecificQuantity ahora maneja el spawn y actualización de inventario
        // Pasamos la cantidad 1 y el índice
        confirmDropSpecificQuantity(1, inventory.selectedItemIndex);
    }
    console.log("[dropSelectedItem v5] Finished.");
}
/**
 * Abre y configura el nuevo panel para soltar items.
 * Valida todos los elementos necesarios, añade listeners con logs y usa estilos directos para mostrar.
 * (v6.3 - Añadidos logs en listeners, validación robusta)
 */
function openDropItemPanel(itemId, itemName, itemIcon, iconType, maxQuantity, inventoryIndex) {
    console.log(`[openDropItemPanel v6.3] Called for ${itemName} (Max: ${maxQuantity}, Index: ${inventoryIndex})`);

    // --- 1. Obtener Referencia al Panel Principal ---
    const panel = domCache['drop-item-panel'];
    if (!(panel instanceof HTMLElement)) {
        console.error("[openDropItemPanel] FATAL: Panel principal #drop-item-panel no encontrado en domCache.");
        logMessage("Error interfaz soltar objeto (Panel).", "error");
        return;
    }

    // --- 2. Validar TODOS los Elementos Internos Necesarios ---
    const elementsToValidate = {
        titleEl: 'drop-panel-title',
        iconEl: 'drop-item-icon',
        nameEl: 'drop-item-name',
        inputEl: 'drop-quantity-input',
        maxTextEl: 'drop-max-text', // El SPAN que muestra "(Max: N)"
        decreaseBtn: 'drop-decrease-btn',
        increaseBtn: 'drop-increase-btn',
        maxBtn: 'drop-quantity-max', // ID del BOTÓN MAX/Todo
        confirmBtn: 'drop-confirm-specific-btn', // Botón "Soltar Cantidad"
        allBtn: 'drop-confirm-all-btn', // Botón "Soltar Todo"
        allCountSpan: 'drop-all-count', // El SPAN dentro del botón "Soltar Todo"
        closeBtn: 'close-drop-panel-button' // Botón 'X' de cierre
    };
    let missingElement = false;
    const foundElements = {}; // Guardaremos los elementos encontrados aquí

    for (const key in elementsToValidate) {
        const elementId = elementsToValidate[key];
        const element = domCache[elementId]; // Buscar en el caché global

        // Validar que el elemento exista y sea del tipo correcto
        const isButton = key.endsWith('Btn') || key === 'closeBtn'; // Identificar botones
        const isInput = key === 'inputEl';
        const expectedType = isInput ? HTMLInputElement : (isButton ? HTMLButtonElement : HTMLElement); // Determinar tipo esperado

        if (!(element instanceof expectedType)) {
            console.error(`[openDropItemPanel] Elemento UI faltante o tipo incorrecto: #${elementId} (Expected: ${expectedType.name}, Found: ${element?.constructor.name})`);
            missingElement = true;
        } else {
            foundElements[key] = element; // Guardar referencia si se encuentra
        }
    }

    // Si falta algún elemento esencial, no continuar
    if (missingElement) {
        logMessage("Error interfaz soltar objeto (Elementos).", "error");
        // No intentar cerrar otros modales ni mostrar nada si la UI está rota
        return;
    }

    // --- Desestructuración de Elementos Validados ---
    const { titleEl, iconEl, nameEl, inputEl, maxTextEl, decreaseBtn, increaseBtn, maxBtn, confirmBtn, allBtn, allCountSpan, cancelBtn, closeBtn } = foundElements;

    // --- 3. Cerrar Otros Modales ---
    console.log("[openDropItemPanel] Closing other modals...");
    closeOtherModals(); // Asegúrate que esta función llama a hideDropItemPanel si estaba abierto

    // --- 4. Guardar Estado Global ---
    currentDropItemId = itemId;
    currentDropMaxQuantity = maxQuantity;
    currentDropInventoryIndex = inventoryIndex;
    console.log("[openDropItemPanel] State variables set.");

    // --- 5. Configurar UI del Panel ---
    titleEl.textContent = `Soltar`;
    nameEl.textContent = itemName;
    // Mostrar icono (HTML o Texto)
    iconEl.innerHTML = iconType === 'html' ? itemIcon : `<span style="font-size:22px;">${itemIcon || '❓'}</span>`;
    maxTextEl.textContent = `(Max: ${maxQuantity})`;
    inputEl.value = '1'; // Iniciar siempre en 1
    inputEl.max = maxQuantity.toString();
    inputEl.min = '1';
    allCountSpan.textContent = maxQuantity.toString(); // Mostrar cantidad total en botón "Soltar Todo"
    console.log("[openDropItemPanel] Panel UI configured.");

    // --- 6. Limpiar y Añadir Listeners (CON LOGS) ---
    const setupListener = (element, event, listener, listenerName) => { // Añadir nombre para log
        if(!element) return; // Comprobación extra
        // Limpiar listener anterior si existe en el elemento
        if(element.currentListener) {
            try { element.removeEventListener(event, element.currentListener); } catch(e){console.warn(`Error removing previous listener ${listenerName}:`, e)}
            element.currentListener = null; // Resetear referencia
        }
        // Envolver el listener original para añadir log
        const wrappedListener = (e) => {
            console.log(`Listener '${listenerName}' ejecutado para ${element.id || element.tagName}`); // LOG al ejecutar
            // Prevenir comportamiento por defecto si es un botón (evita submit de form si estuviera en uno)
            if (element instanceof HTMLButtonElement) e.preventDefault();
            listener(e); // Llamar a la función original
        };
        try {
            element.addEventListener(event, wrappedListener);
            element.currentListener = wrappedListener; // Guardar referencia al wrapper
             console.log(`Listener '${listenerName}' añadido a ${element.id || element.tagName}`); // LOG al añadir
        } catch(e){
            console.error(`Error adding listener ${listenerName}:`, e, element, event);
        }
    };

    // --- Añadir listeners con nombres descriptivos para logs ---
    setupListener(inputEl, 'change', () => updateDropPanelQuantity(0), 'Input_Change');
    setupListener(inputEl, 'input', () => updateDropPanelQuantity(0), 'Input_Input');
    setupListener(decreaseBtn, 'click', () => updateDropPanelQuantity(-1), 'Decrease_Click');
    setupListener(increaseBtn, 'click', () => updateDropPanelQuantity(1), 'Increase_Click');
    setupListener(maxBtn, 'click', () => updateDropPanelQuantity(Infinity), 'MaxBtn_Click');
    setupListener(confirmBtn, 'click', () => { const qty = parseInt(inputEl.value, 10); if (!isNaN(qty) && qty > 0) { confirmDropSpecificQuantity(qty, currentDropInventoryIndex); } else { logMessage("Cantidad inválida.", "warning"); } }, 'ConfirmSpecific_Click');
    setupListener(allBtn, 'click', () => confirmDropSpecificQuantity(currentDropMaxQuantity, currentDropInventoryIndex), 'ConfirmAll_Click');
    setupListener(cancelBtn, 'click', closeDropItemPanel, 'CancelBtn_Click');
    setupListener(closeBtn, 'click', closeDropItemPanel, 'CloseBtn_Click');
    console.log("[openDropItemPanel] Listeners set with logging.");

    // --- 7. Inicializar Estado de Botones según Cantidad Inicial ---
    updateDropPanelQuantity(0); // Llama a la función para establecer estado inicial disabled/enabled

    // --- 8. MOSTRAR PANEL (Manipulación directa de estilos) ---
    panel.style.display = 'flex';
    panel.style.visibility = 'visible';
    panel.style.opacity = '1';
    panel.style.zIndex = '2500'; // Asegurar z-index muy alto

    // --- 9. Verificar Visibilidad (Para Depuración) ---
    requestAnimationFrame(() => {
        if (panel.parentElement) {
            const styles = window.getComputedStyle(panel);
            console.log(`[openDropItemPanel v6.3] Panel styles after setting - Display: ${styles.display}, Visibility: ${styles.visibility}, Opacity: ${styles.opacity}, Z-Index: ${styles.zIndex}`);
            if (styles.display !== 'flex' || styles.visibility !== 'visible' || parseFloat(styles.opacity) < 1) {
                console.error("¡EL PANEL SIGUE SIN MOSTRARSE VISUALMENTE! Revisa CSS y estructura HTML.");
            } else {
                 console.log("[openDropItemPanel v6.3] Panel mostrado correctamente.");
            }
        } else {
            console.error("[openDropItemPanel v6.3] Panel no está en el DOM después de intentar mostrarlo.");
        }
    });

    // --- 10. Sonido ---
    AudioManager.playSound('ui_open', 0.3);
}



/**
 * Cierra el panel de soltar items, limpia listeners y resetea el estado.
 * (v2 - CORREGIDO para usar style.display en lugar de classList)
 */
function closeDropItemPanel() {
    const panel = domCache['drop-item-panel'];
    let wasVisible = false; // Para controlar el sonido

    // 1. Validar que el panel existe
    if (!(panel instanceof HTMLElement)) {
        console.error("closeDropItemPanel: Panel #drop-item-panel no encontrado en caché.");
        // Resetear estado lógico por si acaso
        currentDropItemId = null;
        currentDropMaxQuantity = 0;
        currentDropInventoryIndex = -1;
        return;
    }

    // 2. Comprobar si estaba visible y ocultarlo usando ESTILOS DIRECTOS
    if (panel.style.display !== 'none') {
        wasVisible = true;
        panel.style.display = 'none'; // Ocultar
        panel.style.visibility = 'hidden';
        panel.style.opacity = '0';
        console.log("Panel de soltar ocultado usando estilos directos."); // DEBUG

        // 3. Limpiar listeners (Igual que antes)
        const inputEl = domCache['drop-quantity-input'];
        const decreaseBtn = domCache['drop-decrease-btn'];
        const increaseBtn = domCache['drop-increase-btn'];
        const maxBtn = domCache['drop-quantity-max']; // Asegúrate que este ID es correcto para el botón MAX
        const confirmBtn = domCache['drop-confirm-specific-btn'];
        const allBtn = domCache['drop-confirm-all-btn'];
        const closeBtn = domCache['close-drop-panel-button'];

        const clearListener = (el, ev) => {
            if (el && el.currentListener) {
                try { el.removeEventListener(ev, el.currentListener); } catch (e) {}
                el.currentListener = null;
            }
        };
        clearListener(inputEl, 'change'); clearListener(inputEl, 'input');
        clearListener(decreaseBtn, 'click'); clearListener(increaseBtn, 'click');
        clearListener(maxBtn, 'click'); // Limpiar listener del botón MAX
        clearListener(confirmBtn, 'click'); clearListener(allBtn, 'click');
        clearListener(cancelBtn, 'click'); clearListener(closeBtn, 'click');
        console.log("Listeners del panel de soltar limpiados."); // DEBUG

    } else {
        // Si no estaba visible, no hacemos nada más (ya está oculto y listeners probablemente limpios)
        // console.log("closeDropItemPanel: Panel ya estaba oculto."); // DEBUG opcional
    }

    // 4. Limpiar estado global (siempre, por seguridad)
    currentDropItemId = null;
    currentDropMaxQuantity = 0;
    currentDropInventoryIndex = -1;

    // 5. Sonido (solo si estaba visible)
    if (wasVisible) {
        AudioManager.playSound('ui_close', 0.3);
    }
}

function updatePlayerAppearance(forceClear = false) {
        const playerVisualModel = playerModel?.getObjectByName("PlayerVisualModel");
        const equipment = playerState?.equipment;
        const currentMeshes = playerMeshes; // Contiene refs a weaponHand, shieldHand

        if (!forceClear && (!playerVisualModel || !equipment || !currentMeshes)) { return; }
        // console.log("--- updatePlayerAppearance (v6 Limpieza) ---"); // Reduce spam

        // --- Limpieza Exhaustiva de Mallas Procedurales Anteriores ---
        const visualsToRemove = [];
        const searchAndMark = (parent, isRootVisual = false) => {
             if (!parent) return;
             for (let i = parent.children.length - 1; i >= 0; i--) {
                 const child = parent.children[i];
                 // Marcar si es un visual de equipo y NO es un anclaje persistente
                 if (child.userData?.isEquipmentVisual && child !== currentMeshes?.weaponHand && child !== currentMeshes?.shieldHand) {
                      visualsToRemove.push({ parent: parent, child: child });
                 }
                 // NO buscar recursivamente dentro de los anclajes si no es el modelo visual raíz
                  if (isRootVisual || (child !== currentMeshes?.weaponHand && child !== currentMeshes?.shieldHand)) {
                     searchAndMark(child, false); // Buscar recursivamente en otros hijos
                 }
             }
        };

        // Buscar en el modelo visual principal y sus hijos (excluyendo anclajes)
        searchAndMark(playerVisualModel, true);
        // Buscar dentro de los anclajes (si existen)
        searchAndMark(currentMeshes?.weaponHand);
        searchAndMark(currentMeshes?.shieldHand);

        // Ejecutar la eliminación
        if (visualsToRemove.length > 0) {
            // console.log(`   -> Eliminando ${visualsToRemove.length} mallas de equipo procedurales anteriores...`);
            visualsToRemove.forEach(item => {
                if (item.parent && item.child && item.parent.remove) {
                    item.parent.remove(item.child);
                     // Limpiar geometría/material
                     if (item.child.geometry) item.child.geometry.dispose();
                     if (item.child.material) { if (Array.isArray(item.child.material)) item.child.material.forEach(m => m.dispose()); else item.child.material.dispose(); }
                }
            });
            // console.log("   -> Limpieza completada.");
        }

        // --- LÓGICA FUTURA (Mostrar/Ocultar partes del GLB) ---
        // Aquí iría la lógica para encontrar nodos específicos DENTRO del
        // 'playerVisualModel' (ej: 'Helmet_Node', 'Sword_Bone') y
        // establecer su propiedad `visible = true/false` según `playerState.equipment`.
        // Ejemplo conceptual:
        /*
        if (playerVisualModel && equipment) {
             playerVisualModel.traverse((node) => {
                  if (node.isMesh || node.isGroup) { // O podría ser Bone si el equipo está skineado
                       const slot = node.userData?.equipmentSlot; // Asumir que los nodos tienen este dato
                       if (slot) {
                            const itemInSlot = equipment[slot];
                            // Hacer visible si el slot tiene un item y el ID del nodo coincide (o una lógica similar)
                            node.visible = !!itemInSlot; // Simple mostrar/ocultar
                       }
                  }
             });
        }
        */
        // Por ahora, esta función solo limpia.

    } // Fin updatePlayerAppearance (v6 - Solo Limpieza)


/**
 * Actualiza el minimapa de la sidebar.
 * El mapa permanece fijo (Norte arriba).
 * El indicador del jugador está centrado y rota para indicar dirección.
 * Incluye caché de fondo y dibujo de entidades/marcador de quest.
 * (v5 - CORREGIDO Rotación Indicador)
 */
function updateMinimap() {
    const now = performance.now();
    // Limitar la frecuencia de actualización para optimizar rendimiento
    if (now - lastMinimapRenderTime < MINIMAP_FRAME_THROTTLE_MS) {
        return;
    }
    lastMinimapRenderTime = now;

    const ctx = domCache.minimapCtx; // Contexto del minimapa principal (sidebar)
    const canvas = ctx?.canvas;

    // --- Validaciones Esenciales ---
    if (!ctx || !(canvas instanceof HTMLCanvasElement) || ctx.isDummyContext || canvas.width <= 0) {
        if (!updateMinimap.warnedCanvas) {
             console.warn("updateMinimap: Contexto/Canvas de minimapa inválido o no listo.");
             updateMinimap.warnedCanvas = true;
        }
        return;
    }
    updateMinimap.warnedCanvas = false;

    if (!playerState?.position || typeof playerState.rotationY !== 'number') {
        if (!updateMinimap.warnedPlayerState) {
             console.warn("updateMinimap: playerState inválido o no listo.");
             updateMinimap.warnedPlayerState = true;
        }
        return;
    }
    updateMinimap.warnedPlayerState = false;

    // --- Parámetros y Coordenadas ---
    const canvasSize = canvas.width;
    const worldRadiusVisible = MINIMAP_WORLD_RADIUS;
    const scale = canvasSize / (worldRadiusVisible * 2);
    const centerX = canvasSize / 2;
    const centerY = canvasSize / 2;
    const playerWorldX = playerState.position.x;
    const playerWorldZ = playerState.position.z;
    const playerAngle = playerState.rotationY;

    // --- Actualización del Caché de Fondo ---
    const distSqMoved = (playerWorldX - lastMinimapCacheCenter.x)**2 + (playerWorldZ - lastMinimapCacheCenter.z)**2;
    const desiredCacheSize = Math.round(canvasSize * MINIMAP_CACHE_SIZE_FACTOR);
    const needsCacheUpdate = distSqMoved > MINIMAP_CACHE_UPDATE_DISTANCE**2 || !minimapBgCache || minimapBgCache.width !== desiredCacheSize;

    if (needsCacheUpdate) {
        lastMinimapCacheCenter.x = playerWorldX;
        lastMinimapCacheCenter.z = playerWorldZ;
        if (!minimapBgCache || minimapBgCache.width !== desiredCacheSize) {
            minimapBgCache = document.createElement('canvas');
            minimapBgCache.width = desiredCacheSize;
            minimapBgCache.height = desiredCacheSize;
        }
        const bgCtx = minimapBgCache.getContext('2d', { alpha: false });

        if (bgCtx) {
             console.log(`[Minimap Cache] Updating cache centered at (${playerWorldX.toFixed(1)}, ${playerWorldZ.toFixed(1)})...`);
             bgCtx.fillStyle = '#1a1a1a';
             bgCtx.fillRect(0, 0, desiredCacheSize, desiredCacheSize);
             const imageData = bgCtx.createImageData(desiredCacheSize, desiredCacheSize);
             const data = imageData.data;
             const sampleStep = MINIMAP_BG_SAMPLE_STEP;
             const centerCacheX = desiredCacheSize / 2;
             const centerCacheY = desiredCacheSize / 2;
             const worldRadiusCache = worldRadiusVisible * MINIMAP_CACHE_SIZE_FACTOR;
             const scaleCache = desiredCacheSize / (worldRadiusCache * 2);

             for (let py = 0; py < desiredCacheSize; py += sampleStep) {
                 for (let px = 0; px < desiredCacheSize; px += sampleStep) {
                     const worldX = lastMinimapCacheCenter.x + (px + sampleStep / 2 - centerCacheX) / scaleCache;
                     const worldZ = lastMinimapCacheCenter.z + (py + sampleStep / 2 - centerCacheY) / scaleCache;
                     const { height: h, biomeId } = ChunkManager._getFinalTerrainHeightAndBiome(worldX, worldZ);
                     const biomeName = worldData.getBiomeName(biomeId);
                     let cellColor = new THREE.Color(worldData.biomeColors[biomeName] || 0x6b8e23);
                     if (biomeId === worldData.getBiomeId('water')) { cellColor.setHex(worldData.biomeColors.water || 0x2a5e8f); }
                     else if (biomeId !== worldData.getBiomeId('road') && biomeId !== worldData.getBiomeId('city')) {
                         const snowLine = BIOME_PARAMS.heightMountain * 1.05;
                         if (h > snowLine) { cellColor.lerp(new THREE.Color(worldData.biomeColors.snow || 0xfffafa), 0.85); }
                         else if (h < WATER_LEVEL + 1.0 && biomeId !== worldData.getBiomeId('beach')) { cellColor.lerp(new THREE.Color(worldData.biomeColors.water_shallow || 0x60a0b0), 0.6); }
                     }
                     const roadInfluence = getRoadInfluence(worldX, worldZ);
                     if (roadInfluence > 0) { cellColor.lerp(new THREE.Color(worldData.biomeColors.road || 0xaa8866), roadInfluence * 0.85); }
                     const r = Math.floor(cellColor.r * 255); const g = Math.floor(cellColor.g * 255); const b = Math.floor(cellColor.b * 255);
                     for (let sy = 0; sy < sampleStep; sy++) {
                         for (let sx = 0; sx < sampleStep; sx++) {
                             const cpx = px + sx; const cpy = py + sy;
                             if (cpx < desiredCacheSize && cpy < desiredCacheSize) {
                                 const idx = (cpy * desiredCacheSize + cpx) * 4;
                                 data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                             }
                         }
                     }
                 }
             }
             bgCtx.putImageData(imageData, 0, 0);
             bgCtx.strokeStyle = '#a96'; bgCtx.lineWidth = Math.max(1, 1.8 * scaleCache); bgCtx.lineCap = 'round';
             (worldData.mainRoads || []).forEach(road => { if (!road.points || road.points.length < 2) return; bgCtx.beginPath(); let first = true; for (const p of road.points) { const scx = centerCacheX + (p.x - lastMinimapCacheCenter.x) * scaleCache; const scy = centerCacheY + (p.z - lastMinimapCacheCenter.z) * scaleCache; if (first) { bgCtx.moveTo(scx, scy); first = false; } else { bgCtx.lineTo(scx, scy); } } bgCtx.stroke(); });
             console.log("[Minimap Cache] Cache update finished.");
        } else { console.error("[Minimap Cache] Failed to get 2D context for background cache."); }
    }

    // --- Dibujar en el Canvas Visible ---
    ctx.fillStyle = '#080808';
    ctx.fillRect(0, 0, canvasSize, canvasSize);

    // --- DIBUJAR EL CACHÉ ---
    if (minimapBgCache) {
        const cacheDeltaX = (playerWorldX - lastMinimapCacheCenter.x) * scale;
        const cacheDeltaZ = (playerWorldZ - lastMinimapCacheCenter.z) * scale;
        const sourceX = minimapBgCache.width / 2 - centerX + cacheDeltaX;
        const sourceY = minimapBgCache.height / 2 - centerY + cacheDeltaZ;
        try {
            ctx.drawImage( minimapBgCache, sourceX, sourceY, canvasSize, canvasSize, 0, 0, canvasSize, canvasSize );
        } catch (e) { console.error("Error drawImage minimapa cache:", e); ctx.fillStyle = '#282828'; ctx.fillRect(0, 0, canvasSize, canvasSize); }
    } else { ctx.fillStyle = '#303030'; ctx.fillRect(0, 0, canvasSize, canvasSize); console.warn("updateMinimap: minimapBgCache no disponible para dibujar."); }

    // --- Dibujar Entidades (NPCs, Enemigos, Items, Quests) ---
    // (Código sin cambios, se mantiene igual)
        const entitiesToDraw = [
             ...world.npcs,
             ...world.enemies,
             ...world.items,
             ...world.interactables.filter(i => i?.userData?.type === 'chest' || i?.userData?.type === 'resource' || i?.userData?.type === 'shrine') // Incluir altares?
        ];
        
        const trackedQuest = playerState.trackedQuestId ? quests.active.find(q => q && q.id === playerState.trackedQuestId) : null;
        entitiesToDraw.forEach(entity => {
            // Validaciones robustas
            if (!entity?.position || typeof entity.visible !== 'boolean' || !entity.visible || entity === playerModel || entity.userData?.isDead || entity.userData?.isOpen || entity.userData?.depleted) {
                return;
            }
            // Calcular posición relativa al jugador
            const relX = entity.position.x - playerWorldX;
            const relZ = entity.position.z - playerWorldZ;
            const distSq = relX * relX + relZ * relZ;

            // Solo dibujar si está dentro del radio visible
            if (distSq < worldRadiusVisible ** 2) {
                 // Calcular posición en el canvas (relativa al centro)
                 const sx = centerX + relX * scale;
                 const sy = centerY + relZ * scale;

                 // Dibujar marcador según tipo
                 let color = '#888888'; let size = 1.5; let shape = 'circle';
                 const entityType = entity.userData.type;
                 if (entityType === 'npc') { color = '#ffff00'; size = 2.0; shape = 'square'; }
                 else if (entityType === 'enemy') { color = entity.userData.isAggro ? '#ff0000' : '#ff8800'; size = 1.8; shape = 'triangle'; }
                 else if (entityType === 'item_pickup') { try{color=getComputedStyle(document.documentElement).getPropertyValue(getRarityColorVar(entity.userData.itemDef?.rarity||'common')).trim()||'#aaaaaa';}catch(e){color='#aaaaaa';} size=1.6; }
                 else if (entityType === 'chest') { color = '#aa6600'; size = 1.8; shape = 'square'; }
                 else if (entityType === 'resource') { color = '#00aaff'; size = 1.5; }
                 else if (entityType === 'shrine') { color = '#00ff00'; size = 2.0; shape = 'diamond'; } // Forma diamante para altares

                 ctx.fillStyle = color;
                 ctx.strokeStyle = 'rgba(0,0,0,0.7)';
                 ctx.lineWidth = 0.5;
                 ctx.beginPath();
                 if (shape === 'circle') { ctx.arc(sx, sy, size, 0, Math.PI * 2); }
                 else if (shape === 'square') { ctx.rect(sx - size * 0.7, sy - size * 0.7, size * 1.4, size * 1.4); }
                 else if (shape === 'triangle') { ctx.moveTo(sx, sy - size); ctx.lineTo(sx + size * 0.8, sy + size * 0.6); ctx.lineTo(sx - size * 0.8, sy + size * 0.6); ctx.closePath(); }
                 else if (shape === 'diamond') { ctx.moveTo(sx, sy - size); ctx.lineTo(sx + size*0.7, sy); ctx.lineTo(sx, sy + size); ctx.lineTo(sx - size*0.7, sy); ctx.closePath(); }
                 ctx.fill();
                 ctx.stroke();
             }
        });
        if (trackedQuest) {
            const questDef = questDefinitions[trackedQuest.id];
            if (questDef?.objectives) {
                ctx.fillStyle = 'rgba(255, 220, 0, 0.9)'; // Amarillo Quest
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 0.5;
                questDef.objectives.forEach((objDef, index) => {
                    const objState = trackedQuest.objectives?.find(o => o && ((o.id && o.id === objDef.id) || (o.type === objDef.type && o.target === objDef.target))) || trackedQuest.objectives?.[index];
                    if (objState && objState.current < (objDef.count || 1)) {
                        let targetPos = findQuestObjectivePosition(objDef); // Usar helper
                        if (targetPos) {
                            const relX = targetPos.x - playerWorldX;
                            const relZ = targetPos.z - playerWorldZ;
                            const distSq = relX * relX + relZ * relZ;
                            if (distSq < worldRadiusVisible ** 2) {
                                const sx = centerX + relX * scale;
                                const sy = centerY + relZ * scale;
                                // Dibujar un marcador más distintivo (ej. estrella o círculo con borde grueso)
                                ctx.beginPath();
                                ctx.arc(sx, sy, 3.5, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.stroke();
                                // Podría añadir un borde exterior blanco para resaltar
                                // ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 1.5; ctx.stroke();
                            }
                        }
                    }
                });
            }
        }

    // --- Dibujar Indicador del Jugador (ROTADO en el Centro) ---
    const playerIconSize = 6;
    ctx.save();
    ctx.translate(centerX, centerY);
    // CORRECCIÓN: Negar el ángulo para que rote en la dirección correcta
    ctx.rotate(-playerAngle); // <-- *** CORRECCIÓN AQUÍ ***

    ctx.fillStyle = gameState.isGhost ? 'rgba(162, 155, 254, 0.9)' : 'rgba(255, 255, 255, 0.95)';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, -playerIconSize * 0.8); // Punta hacia arriba local (-Y)
    ctx.lineTo(playerIconSize * 0.6, playerIconSize * 0.5);
    ctx.lineTo(playerIconSize * 0.2, playerIconSize * 0.3);
    ctx.lineTo(-playerIconSize * 0.2, playerIconSize * 0.3);
    ctx.lineTo(-playerIconSize * 0.6, playerIconSize * 0.5);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.restore();

    // --- Dibujar Borde del Minimapa ---
    // (Código sin cambios)
    ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(centerX, centerY, canvasSize / 2 - 0.5, 0, Math.PI * 2); ctx.stroke();
    try { ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-secondary').trim() || '#b89b40'; } catch(e){ ctx.strokeStyle = '#b89b40'; }
    ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(centerX, centerY, canvasSize / 2 - 1.5, 0, Math.PI * 2); ctx.stroke();
}
// Inicializar flags de advertencia para la función
updateMinimap.warnedCanvas = false;
updateMinimap.warnedPlayerState = false;

        // --- Helper para obtener variable CSS de rareza (Evita errores si no existe) ---
    function getRarityColorVar(rarity = 'common') {
         const validRarities = ['common', 'uncommon', 'rare', 'epic', 'legendary', 'quest'];
         const safeRarity = validRarities.includes(rarity) ? rarity : 'common';
         return `--rarity-${safeRarity}`;
    }
    
    
    // --- Helper para encontrar posición de objetivo de misión (NECESITAS IMPLEMENTARLO) ---
    function findQuestObjectivePosition(objectiveDefinition) {
         if (!objectiveDefinition) return null;
         const targetId = objectiveDefinition.target;
         switch(objectiveDefinition.type) {
              case 'reach': // Asume que targetId es el ID de un POI
                   return worldData.specialLocations?.find(loc => loc.id === targetId)?.pos || null;
              case 'kill': // Encuentra el enemigo más cercano de ese tipo
                   let closestEnemyPos = null; let minDistSq = Infinity;
                   world.enemies.forEach(e => {
                        if(e?.userData?.enemyType === targetId && !e.userData.isDead && e.position) {
                             const dSq = e.position.distanceToSquared(playerState.position);
                             if(dSq < minDistSq) { minDistSq = dSq; closestEnemyPos = e.position; }
                        }
                   });
                   return closestEnemyPos;
              case 'interact': // Encuentra NPC o interactuable
                   const npc = world.npcs.find(n => n?.userData?.npcType === targetId || n?.userData?.id === targetId);
                   if (npc?.position) return npc.position;
                   // Buscar otros interactuables por ID?
                   const interactable = world.interactables.find(i => i?.userData?.id === targetId);
                   return interactable?.position || null;
               case 'collect': // Encuentra el nodo de recurso más cercano
                   let closestNodePos = null; let minNodeDistSq = Infinity;
                   world.interactables.forEach(i => {
                        if(i?.userData?.type === 'resource' && !i.userData.depleted && i.userData.resourceDefId === targetId && i.position) {
                             const dSq = i.position.distanceToSquared(playerState.position);
                             if(dSq < minNodeDistSq) { minNodeDistSq = dSq; closestNodePos = i.position; }
                        }
                   });
                   return closestNodePos;
              default: return null;
         }
    }

    /**
     * Maneja la acción de recoger un item del suelo.
     * Llamada cuando el jugador interactúa con un objeto 'item_pickup'.
     * AHORA puede recibir el objeto directamente o usar gameState.targetEntity.
     * (v2 - Acepta argumento itemObject)
     * @param {THREE.Object3D | null} [itemObject=null] - El objeto 3D del item a recoger (opcional). Si es null, usa gameState.targetEntity.
     */
    function pickupItem(itemObject = null) {
        // Determinar el objetivo: usar el argumento si se proporciona, si no, usar el target global
        const target = itemObject || gameState.targetEntity;

        // 1. Validar que el objetivo es un item recogible
        if (!target || target.userData?.type !== 'item_pickup' || !target.userData.itemData || !target.userData.itemDef) {
            // console.warn("pickupItem: El objetivo no es un item recogible válido."); // Evitar log excesivo
            return; // No hacer nada si no es un item válido
        }

        // 2. Validar Distancia (usar radio un poco mayor para recoger "bajo los pies")
        const pickupRadiusSq = target === itemObject ? PICKUP_UNDERFOOT_RADIUS_SQ * 1.1 : PICKUP_DISTANCE_SQ * 1.1; // Radio mayor si viene de E sin mirar
        if (target.position.distanceToSquared(playerState.position) > pickupRadiusSq) {
            logMessage("Estás demasiado lejos para recoger eso.", "warning");
            return;
        }

        // 3. Obtener datos del item
        const itemDataToPickup = target.userData.itemData; // { id: '...', count: ... }
        const itemDef = target.userData.itemDef;

        // 4. Intentar añadir al inventario
        const addedSuccessfully = addItemToInventory(itemDataToPickup.id, itemDataToPickup.count);

        // 5. Procesar resultado
        if (addedSuccessfully) {
            logMessage(`Recogiste ${itemDataToPickup.count} ${itemDef.name}.`, "loot");
            AudioManager.playSound('pick_up', 0.55);

            // Eliminar el objeto 3D del mundo
            if (target.parent) {
                scene.remove(target);
                try {
                    if (target.geometry) target.geometry.dispose();
                    if (target.material) {
                        if (Array.isArray(target.material)) target.material.forEach(m => {m.map?.dispose(); m.dispose();});
                        else if (target.material.dispose) { target.material.map?.dispose(); target.material.dispose(); }
                    }
                } catch(disposeError) { console.warn("Error limpiando item recogido:", disposeError); }
            }

            // Eliminar de las listas del mundo
            const itemIndex = world.items.indexOf(target); if (itemIndex > -1) world.items.splice(itemIndex, 1);
            const interactableIndex = world.interactables.indexOf(target); if (interactableIndex > -1) world.interactables.splice(interactableIndex, 1);

            // Limpiar el target del jugador SI era el target global
            if (target === gameState.targetEntity) {
                gameState.targetEntity = null;
                updateTargetUI();
            }

        } else {
            // addItemToInventory ya muestra "Inventario Lleno"
            console.log("Fallo al recoger, inventario probablemente lleno.");
        }
    }

    /**
     * Verifica los items en el suelo y elimina los que han excedido su tiempo de vida.
     */
    function updateWorldItemDespawn() {
        const now = Date.now();
        for (let i = world.items.length - 1; i >= 0; i--) {
            const item = world.items[i];
            // Verificar si el item o sus datos son válidos y si ha expirado
            if (!item?.userData?.spawnTime || now - item.userData.spawnTime > ITEM_DESPAWN_TIME) {
                 if(item?.parent) {
                     try {
                          scene.remove(item); // Remover de la escena
try {
    if (item.geometry) item.geometry.dispose();
    if (item.material) {
        if (Array.isArray(item.material)) item.material.forEach(m => {m.map?.dispose(); m.dispose();});
        else { item.material.map?.dispose(); item.material.dispose(); }
    }
} catch(removeError) { console.error("Error al remover item despawneado:", removeError); }
                           // Limpiar geometría/material
                           if (item.geometry) item.geometry.dispose();
                           if (item.material) {
                               if (Array.isArray(item.material)) item.material.forEach(m => m.dispose());
                               else if(item.material.dispose) item.material.dispose();
                           }
                     } catch(removeError) { console.error("Error al remover item despawneado:", removeError); }
                 }
                 // Remover de la lista de interactuables
                 const interactableIndex = world.interactables.indexOf(item);
                 if(interactableIndex > -1) world.interactables.splice(interactableIndex, 1);
                 // Remover de la lista principal de items
                 world.items.splice(i, 1);
                 // console.log(`Item despawned: ${item?.userData?.itemDef?.name || 'Unknown'}`); // DEBUG
            }
        }
    }


    function regenerateResource(resourceNode) {
        if (!resourceNode || !resourceNode.userData || !resourceNode.userData.depleted) return;
        resourceNode.userData.depleted = false;
        delete world.worldStateData.depletedNodes[resourceNode.userData.id];
        resourceNode.scale.set(1, 1, 1);
        if (resourceNode.material instanceof THREE.MeshStandardMaterial) {
             // Restaurar material si fue clonado, o propiedades si no
             if(resourceNode.material.clonedForDepletion) {
                  // Asumimos que no guardamos referencia, restauramos propiedades
                  resourceNode.material.opacity = 1.0; resourceNode.material.transparent = false; resourceNode.material.depthWrite = true;
                  delete resourceNode.material.clonedForDepletion;
             } else { resourceNode.material.opacity = 1.0; resourceNode.material.transparent = false; }
        }
        logMessage(`Nodo de ${resourceNode.userData.resourceType || 'recurso'} regenerado.`, 'system');
    }

    // --- NUEVAS Funciones UI/Util ---
    function updateActionSlotsUI() {
        domCache.actionSlots?.forEach((slotElement, index) => {
             if (!(slotElement instanceof HTMLElement)) return;
             const slotData = playerState.actionSlots[index];
             const keybindText = slotElement.querySelector('.keybind-text'); if(!keybindText && slotElement.children.length === 0){ const k = document.createElement('span'); k.className='keybind-text'; k.textContent=(index+1).toString(); slotElement.appendChild(k);} // Crear keybind si no existe
             let iconSpan = slotElement.querySelector('.item-icon'); let countSpan = slotElement.querySelector('.item-count-hotbar'); let cooldownOverlay = slotElement.querySelector('.cooldown-overlay-hotbar');

             // Limpiar icono, count, overlay
             if(iconSpan) iconSpan.remove(); if(countSpan) countSpan.remove(); if(cooldownOverlay) cooldownOverlay.remove();
             slotElement.classList.remove('on-cooldown'); slotElement.title = ''; slotElement.style.opacity = '1';

             if (slotData) {
                 let def = null; let iconContent = '❓'; let name = 'Desconocido'; let currentCount = null; let cooldownPercent = 0; let isOnCooldown = false;
                 if (slotData.type === 'item') { def = itemDefinitions[slotData.id]; if(def) { iconContent = def.icon || '📦'; name = def.name; currentCount = countItemsInInventory(slotData.id); } }
                 else if (slotData.type === 'spell') { def = spellDefinitions[slotData.id]; const spellInstance = spells.known.find(s => s.id === slotData.id); if(def && spellInstance) { iconContent = def.icon || '✨'; name = def.name; if (spellInstance.cooldownRemaining > 0 && def.cooldown > 0) { isOnCooldown = true; cooldownPercent = (spellInstance.cooldownRemaining / def.cooldown) * 100; } } }

                 if(def) {
                      slotElement.title = name;
                      iconSpan = document.createElement('span'); iconSpan.className = 'item-icon'; iconSpan.textContent = iconContent; slotElement.appendChild(iconSpan);
                      if (currentCount !== null && currentCount > 0) { countSpan = document.createElement('span'); countSpan.className = 'item-count-hotbar'; countSpan.textContent = currentCount; slotElement.appendChild(countSpan); }
                      else if (currentCount === 0) { slotElement.style.opacity = '0.5'; }
                      if (isOnCooldown) { slotElement.classList.add('on-cooldown'); cooldownOverlay = document.createElement('div'); cooldownOverlay.className = 'cooldown-overlay-hotbar'; cooldownOverlay.style.height = `${cooldownPercent.toFixed(1)}%`; slotElement.appendChild(cooldownOverlay); }
                 } else { if(!slotElement.querySelector('.item-icon')) { const errIcon = document.createElement('span'); errIcon.className='item-icon'; errIcon.textContent='❌'; slotElement.appendChild(errIcon); } slotElement.title = 'Inválido'; slotElement.style.opacity = '0.5'; }
             } else { slotElement.title = 'Vacío'; }
        });
    }


    function assignToActionSlot(itemOrSpellData, slotIndex) {
         if (slotIndex < 0 || slotIndex >= playerState.actionSlots.length) return;
         if (!itemOrSpellData?.type || !itemOrSpellData?.id) return;
         // Obtener icono de la definición para asegurar que esté actualizado
         let icon = '❓'; let name = 'Item/Hechizo';
         if(itemOrSpellData.type === 'item' && itemDefinitions[itemOrSpellData.id]) { icon = itemDefinitions[itemOrSpellData.id].icon || '📦'; name = itemDefinitions[itemOrSpellData.id].name; }
         else if (itemOrSpellData.type === 'spell' && spellDefinitions[itemOrSpellData.id]) { icon = spellDefinitions[itemOrSpellData.id].icon || '✨'; name = spellDefinitions[itemOrSpellData.id].name;}

         playerState.actionSlots[slotIndex] = { type: itemOrSpellData.type, id: itemOrSpellData.id, icon: icon };
         logMessage(`${name} asignado a ranura ${slotIndex + 1}.`, 'system');
         updateActionSlotsUI();
    }


    function useActionSlot(index) {
         if (index < 0 || index >= playerState.actionSlots.length) return;
         const slotData = playerState.actionSlots[index]; if (!slotData) return;
         console.log(`Using action slot ${index+1}:`, slotData);

         if (slotData.type === 'item') {
              const itemIndex = inventory.items.findIndex(item => item && item.id === slotData.id);
              if (itemIndex > -1) { selectInventoryItem(itemIndex); useSelectedItem(); }
              else { logMessage(`Ya no tienes ${getItemName(slotData.id)}.`, 'warning'); }
         } else if (slotData.type === 'spell') {
              const spellIndex = spells.known.findIndex(spell => spell && spell.id === slotData.id);
              if (spellIndex > -1) { selectSpell(spellIndex); useOrCastSelectedItem(); }
              else { logMessage(`Ya no conoces ${getSpellName(slotData.id)}.`, 'warning'); }
         }
    }

    function updateQuestTrackerUI() {
        const trackerContainer = domCache['quest-tracker']; if (!trackerContainer) return;
        const trackedQuestId = playerState.trackedQuestId;
        if (!trackedQuestId) { trackerContainer.classList.remove('visible'); return; }
        const activeQuest = quests.active.find(q => q && q.id === trackedQuestId); const questDef = trackedQuestId ? questDefinitions[trackedQuestId] : null;
        if (!activeQuest || !questDef) { trackerContainer.classList.remove('visible'); playerState.trackedQuestId = null; return; }

        let content = `<h4>${questDef.name || 'Misión Seguida'}</h4>`;
        (activeQuest.objectives || []).forEach((objState, index) => {
            if(!objState) return;
            const objDef = questDef.objectives?.[index] || objState; if(!objDef) return;
            const targetCount = objDef.count || 1; const isCompleted = objState.current >= targetCount; const desc = objDef.description || getObjectiveText(objDef);
            content += `<div class="tracker-objective ${isCompleted ? 'completed' : ''}">${desc} (${objState.current}/${targetCount})</div>`;
        });
        trackerContainer.innerHTML = content; trackerContainer.classList.add('visible');
    }
    
/**
 * Actualiza los marcadores visuales (!) sobre los NPCs según las misiones disponibles o completables.
 */
function updateNPCMarkers() {
     // Iterar sobre los NPCs cargados en el mundo
     world.npcs.forEach(npc => {
          const marker = npc.getObjectByName('QuestMarker'); // Busca el objeto marcador
          if (!marker || !npc.userData || !npcDefinitions) return; // Salir si no hay marcador o datos

          const npcType = npc.userData.npcType;
          const npcDef = npcDefinitions[npcType];
          let showMarker = false;
          let markerColor = 0xffff00; // Amarillo por defecto (Nueva misión)

          // Salir si el NPC no tiene diálogos definidos
          if (!npcDef?.dialogues) {
              marker.visible = false;
              return;
          }

          // --- Lógica para mostrar marcador ---

          // 1. ¿Puede COMPLETAR una misión activa? (Prioridad alta, marcador verde)
          // Busca misiones ACTIVAS que listen a este NPC como 'giver' Y que se puedan completar
          const completableQuest = quests.active.find(q =>
              q &&                                          // Que la quest activa exista
              questDefinitions[q.id] &&                     // Que la definición de la quest exista
              questDefinitions[q.id].giver === npcType &&   // Que este NPC sea el que la dio
              canCompleteQuest(q.id)                        // Que se puedan completar los objetivos
          );

          if (completableQuest) {
              showMarker = true;
              markerColor = 0x00ff00; // Verde: Listo para entregar
          } else {
              // 2. ¿Puede OFRECER una nueva misión? (Marcador amarillo/naranja)
              // Itera sobre los diálogos del NPC buscando nodos con action 'acceptQuest'
              for (const key in npcDef.dialogues) {
                  const node = npcDef.dialogues[key];
                  if (node.action === 'acceptQuest' && node.questId) {
                      const questDefToOffer = questDefinitions[node.questId];
                      // Comprobar si la quest existe, el jugador NO la tiene Y NO la ha completado
                      if (questDefToOffer && !hasQuest(node.questId) && !isQuestCompleted(node.questId)) {
                          // Comprobar condiciones del NODO de diálogo y requisitos de la QUEST
                          let canOffer = true;
                          // Condición del nodo de diálogo
                          if (node.condition && typeof node.condition === 'function') {
                               try { canOffer = node.condition(npc, playerState); } catch(e) { canOffer = false; }
                          }
                          // Requisitos de la quest (nivel, clase)
                          if (canOffer && questDefToOffer.requirements?.level && playerState.level < questDefToOffer.requirements.level) {
                               canOffer = false;
                          }
                          if (canOffer && questDefToOffer.classRequirement && !questDefToOffer.classRequirement.includes(playerState.class)) {
                               canOffer = false;
                          }

                          if (canOffer) {
                              showMarker = true;
                              markerColor = 0xffaa00; // Naranja/Amarillo: Nueva misión disponible
                              break; // Salir del bucle, ya encontramos una misión para ofrecer
                          }
                      }
                  }
              }
          }

          // --- Aplicar Visibilidad y Color ---
          marker.visible = showMarker;
          if (showMarker && marker.material instanceof THREE.MeshBasicMaterial) {
              // Solo cambiar color si es diferente para evitar trabajo innecesario
              if (marker.material.color.getHex() !== markerColor) {
                   marker.material.color.setHex(markerColor);
              }
          }
     });
}

    function getStationName(type) {
         switch(type) { case 'forge': return 'una Fragua/Yunque'; case 'workbench': return 'un Banco de Trabajo'; case 'loom': return 'un Telar'; case 'alchemy_pot': return 'una Olla de Alquimia'; default: return 'una Estación Desconocida'; }
    }

    function checkItemRequirements(itemDef) {
        if (!itemDef?.requirements) return true; const reqs = itemDef.requirements;
        if (reqs.level && playerState.level < reqs.level) return false;
        if (reqs.class && !reqs.class.includes(playerState.class)) return false;
        if (reqs.attributes) { for (const attr in reqs.attributes) { if ((playerState.attributes[attr] || 0) < reqs.attributes[attr]) return false; } }
        return true;
    }

    function getSpellName(spellId) { return spellDefinitions[spellId]?.name || `[Hechizo ${spellId}]`; }
function activateShrine(shrineObject, effectType) {
        logMessage(`Has activado un ${shrineObject.userData.name || 'altar'}.`, "info");
        if (effectType === 'heal_player_full') {
            const wasHealed = playerState.stats.health < playerState.stats.maxHealth || playerState.stats.mana < playerState.stats.maxMana;
            playerState.stats.health = playerState.stats.maxHealth; playerState.stats.mana = playerState.stats.maxMana;
            if(wasHealed) { updatePlayerUI(); showFloatingText('heal-text', "¡Restaurado!", playerState.position.clone()); AudioManager.playSound('level_up', 0.7); }
             else { logMessage("Ya estabas al máximo.", "info"); }
        } else if (effectType === 'regen_mana_buff') {
             addStatusEffect({id:'shrine_mana_regen', name:'Bendición de Maná', icon:'fa-tint', duration:300, statsModifiers:{mpRegen: 2.0}, class:'status-buff', description: "+2 Regen. Maná (5 min)"});
             AudioManager.playSound('spell_buff', 0.6);
        } else { logMessage("El altar parece inerte.", "system"); }
        // Desactivar temporalmente?
        // shrineObject.userData.interactable = false;
        // shrineObject.visible = false; // Ocultar visualmente
        // setTimeout(()=> { shrineObject.userData.interactable = true; shrineObject.visible = true; }, 300000); // Reactivar en 5 min
    }

/**
 * Handles the transition from the overworld to a dungeon level.
 * (v3 - Dungeon Isolation, Scene Removal/Addition)
 */
async function enterDungeon(dungeonId) {
    console.log(`[Dungeon] Attempting to enter: ${dungeonId}`);
    if (!dungeonDefinitions[dungeonId]) {
        logMessage(`Error: Mazmorra '${dungeonId}' no definida.`, "error"); return;
    }
    if (gameState.currentLocation !== 'world') {
        logMessage("Ya estás en otra ubicación.", "warning"); return;
    }

    // --- 1. Save Player's World State & Feedback ---
    playerState.lastWorldPosition = playerState.position.clone(); // Guardar posición ABSOLUTA del overworld
    playerState.lastWorldRotationY = playerState.rotationY;
    const dungeonDef = dungeonDefinitions[dungeonId];
    logMessage(`Entrando a ${dungeonDef.name}...`, "system");
    showNotification(`Entrando a: ${dungeonDef.name}`, "info");
    AudioManager.playSound('teleport', 0.6);

    // --- 2. Desactivar y OCULTAR/REMOVER Overworld ---
    console.log("[Dungeon] Deactivating and removing overworld elements...");
    gameState.isLoading = true; // Bloquear updates mientras transicionamos

    // a. Guardar referencias a objetos del overworld a remover
    world.overworldObjectsToRemove = [];
    ChunkManager.activeChunks.forEach(chunk => {
        if (chunk.terrainMesh?.parent) world.overworldObjectsToRemove.push(chunk.terrainMesh);
        (chunk.objects || []).forEach(obj => {
            // Guardar solo objetos del overworld (sin dungeonId) que estén en la escena
            if (obj?.parent && !obj.userData.dungeonId && obj !== playerModel) {
                 world.overworldObjectsToRemove.push(obj);
            }
        });
    });
    if (world.water?.parent) world.overworldObjectsToRemove.push(world.water);
    // Remover NPCs, Enemigos, Items del overworld (ya lo hacías)
    world.enemies.filter(e => !e.userData.dungeonId).forEach(e => { if(e.parent) world.overworldObjectsToRemove.push(e); });
    world.npcs.filter(n => !n.userData.dungeonId).forEach(n => { if(n.parent) world.overworldObjectsToRemove.push(n); });
    world.items.filter(i => !i.userData.dungeonId).forEach(i => { if(i.parent) world.overworldObjectsToRemove.push(i); });

    // b. Removerlos de la escena
    console.log(`  Removing ${world.overworldObjectsToRemove.length} overworld objects from scene...`);
    world.overworldObjectsToRemove.forEach(obj => {
        if(obj.parent) obj.parent.remove(obj);
    });

    // c. Limpiar listas globales (manteniendo solo jugador y objetos persistentes si los hubiera)
    world.enemies = []; world.npcs = []; world.items = [];
    world.interactables = [playerModel]; // Mantener solo al jugador inicialmente
    world.objects = [playerModel]; // Mantener solo al jugador para colisión inicial

    // d. Pausar ChunkManager (ya no necesita actualizar chunks del overworld)
    // Opcional: podrías añadir un flag `ChunkManager.isEnabled = false;`

    // --- 3. Load/Generate Dungeon Scene ---
    console.log("[Dungeon] Generating dungeon scene...");
    gameState.currentLocation = dungeonId;
    world.dungeon = { id: dungeonId, geometryGroup: null, enemies: [], interactables: [], ambientLight: null };

    // a. Crear Geometría (AHORA se añade a world.objects internamente)
    createDungeonGeometry(dungeonDef.layout, dungeonDef.wallColor, dungeonDef.floorColor);

    // b. Spawnear Enemigos (AHORA se añade a world.objects/enemies internamente)
    await spawnDungeonEnemies(dungeonDef.enemies, dungeonDef.layout);

    // c. Spawnear Interactables (AHORA se añade a world.objects/interactables internamente)
    spawnDungeonInteractables(dungeonDef.interactables);

    // d. Crear Punto de Salida (AHORA se añade a world.objects/interactables internamente)
    createDungeonExitPoint(dungeonDef);

    // --- 4. Place Player at Dungeon Start (Coordenadas LOCALES) ---
    console.log("[Dungeon] Positioning player...");
    const startPos = dungeonDef.startPos || { x: 0, y: 0, z: 0 };
    // Usar getGroundHeightAt para asegurar Y correcta DENTRO del dungeon
    const dungeonGroundY = getGroundHeightAt(startPos.x, startPos.z); // <<< Usa la función nueva
    playerState.position.set(startPos.x, dungeonGroundY + PLAYER_HALF_HEIGHT, startPos.z); // <<< Posición LOCAL
    playerState.velocity.set(0, 0, 0);
    playerState.onGround = true;
    if (playerModel) {
        playerModel.position.copy(playerState.position);
        playerState.rotationY = dungeonDef.startRotY || 0; // <<< Rotación inicial (0 = mirando al 'fondo')
        playerModel.rotation.y = playerState.rotationY;
    }
    // Resetear cámara
    if (camera && orbitControls) {
        // Forzar actualización inmediata de cámara y target
        orbitControls.target.copy(playerState.position).add(new THREE.Vector3(0, PLAYER_HALF_HEIGHT * 0.8, 0));
        const camOffsetDungeon = cameraOffset.clone().applyAxisAngle(new THREE.Vector3(0,1,0), playerState.rotationY);
        camera.position.copy(playerState.position).add(camOffsetDungeon);
        camera.lookAt(orbitControls.target);
        orbitControls.update(); // Aplicar cambios
    }

    // --- 5. Update Environment ---
    console.log("[Dungeon] Setting environment...");
    if (scene) {
        scene.background = new THREE.Color(dungeonDef.bgColor || 0x101015);
        if (!scene.fog) {
            scene.fog = new THREE.Fog(scene.background, dungeonDef.fogNear || 10, dungeonDef.fogFar || 40);
        } else {
            scene.fog.color.set(scene.background);
            scene.fog.near = dungeonDef.fogNear || 10;
            scene.fog.far = dungeonDef.fogFar || 40;
        }
        // Atenuar luces SOLARES (ya no se quitan de la escena, solo se atenúan)
        scene.traverse(obj => {
            if (obj.isLight && (obj.userData?.type === 'sun' || obj.userData?.type === 'moon')) {
                if (obj.userData.originalIntensity === undefined) obj.userData.originalIntensity = obj.intensity; // Guardar intensidad original
                obj.intensity = obj.userData.originalIntensity * 0.05; // Muy tenue
            }
        });
        // Añadir luz ambiental específica del dungeon
        const dungeonLightIntensity = dungeonDef.ambientLightIntensity || 0.4;
        const dungeonLightColor = dungeonDef.ambientLightColor || 0x666677;
        const dungeonLight = new THREE.AmbientLight(dungeonLightColor, dungeonLightIntensity);
        dungeonLight.userData = { type: 'dungeon_ambient' };
        scene.add(dungeonLight);
        world.dungeon.ambientLight = dungeonLight; // Guardar referencia para limpiar
    }
    AudioManager.playMusic(dungeonDef.music || 'music_dungeon_cave');

    gameState.isLoading = false; // Desbloquear updates
    console.log(`[Dungeon] Player entered dungeon: ${dungeonId} successfully.`);
}


/**
 * Crea la geometría y mallas para un dungeon simple, añadiéndolas
 * al grupo world.dungeon.geometryGroup y los objetos colisionables a world.objects.
 * (v3 - Añade objetos a grupo y world.objects)
 * @param {object} layout - Objeto de layout de dungeonDefinitions.
 * @param {number} [wallColor=0x444455] - Color hexadecimal para paredes/techo.
 * @param {number} [floorColor=0x555555] - Color hexadecimal para el suelo.
 */
function createDungeonGeometry(layout, wallColor = 0x444455, floorColor = 0x555555) {
    if (!layout) { console.error("createDungeonGeometry: Layout no definido."); return; }
    // Asegurarse de que el grupo exista (enterDungeon debería haberlo creado)
    if (!world.dungeon?.geometryGroup) {
        console.error("createDungeonGeometry: world.dungeon.geometryGroup no existe!");
        world.dungeon.geometryGroup = new THREE.Group();
        world.dungeon.geometryGroup.position.y = world.dungeon.baseY || 0; // Poner en la altura base
        scene.add(world.dungeon.geometryGroup);
    }
    const group = world.dungeon.geometryGroup; // Usar el grupo existente

    const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, side: THREE.BackSide, roughness: 0.85, metalness: 0.1, name: `DungeonWallMat_${gameState.currentLocation}` });
    const floorMat = new THREE.MeshStandardMaterial({ color: floorColor, roughness: 0.9, metalness: 0.05, name: `DungeonFloorMat_${gameState.currentLocation}` });

    if (layout.type === 'box') {
        const [width, height, depth] = layout.size || [50, 10, 50];

        // --- Suelo ---
        const floorGeometry = new THREE.PlaneGeometry(width, depth);
        const floor = new THREE.Mesh(floorGeometry, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0; // Y=0 LOCAL dentro del grupo
        floor.receiveShadow = true;
        floor.name = "DungeonFloor";
        floor.userData = { type: 'dungeon_floor', dungeonId: gameState.currentLocation };
        group.add(floor); // <<< AÑADIR AL GRUPO DEL DUNGEON

        // --- Paredes y Techo ---
        const wallCeilingGeometry = new THREE.BoxGeometry(width + 0.2, height + 0.2, depth + 0.2);
        const wallsCeiling = new THREE.Mesh(wallCeilingGeometry, wallMat);
        wallsCeiling.position.y = height / 2; // Centrar LOCALMENTE
        wallsCeiling.name = "DungeonWallsCeiling";
        wallsCeiling.castShadow = true; // Paredes pueden proyectar sombra? Opcional
        wallsCeiling.userData = {
            type: 'dungeon_walls',
            dungeonId: gameState.currentLocation,
        };
        group.add(wallsCeiling); // <<< AÑADIR AL GRUPO DEL DUNGEON
        // Crear BBox DESPUÉS de añadir al grupo y posicionar grupo (o usar matrixWorld)
        wallsCeiling.updateMatrixWorld(true); // Asegurar que la matrixWorld esté actualizada
        wallsCeiling.userData.boundingBox = new THREE.Box3().setFromObject(wallsCeiling); // <<< Calcular BBox en coords mundo
        world.objects.push(wallsCeiling); // <<< AÑADIR A world.objects PARA COLISIÓN

        // --- Pilares ---
        if (layout.pillars && Array.isArray(layout.pillars)) {
            const pillarGeometry = new THREE.CylinderGeometry(0.5, 0.5, height, 8);
            layout.pillars.forEach((pillarData, index) => {
                const pillar = new THREE.Mesh(pillarGeometry, wallMat.clone());
                pillar.position.set(pillarData.x, height / 2, pillarData.z); // Posición LOCAL
                pillar.castShadow = true;
                pillar.receiveShadow = true;
                pillar.name = `DungeonPillar_${index}`;
                pillar.userData = { type: 'dungeon_structure', dungeonId: gameState.currentLocation };
                group.add(pillar); // <<< AÑADIR AL GRUPO DEL DUNGEON
                pillar.updateMatrixWorld(true); // Actualizar matrix
                pillar.userData.boundingBox = new THREE.Box3().setFromObject(pillar); // <<< Calcular BBox en coords mundo
                world.objects.push(pillar); // <<< AÑADIR A world.objects
            });
        }
        console.log(`Dungeon geometry type 'box' created for ${gameState.currentLocation}.`);

    } else {
        console.error(`createDungeonGeometry: Tipo de layout no soportado: ${layout.type}`);
        const fallbackFloor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
        fallbackFloor.rotation.x = -Math.PI / 2; fallbackFloor.position.y = 0;
        fallbackFloor.name = "DungeonFloor"; fallbackFloor.userData = { type: 'dungeon_floor', dungeonId: gameState.currentLocation };
        group.add(fallbackFloor);
    }
}

/**
 * Spawnea interactables específicos del dungeon (cofres, recursos, etc.).
 * (v1 - Básico para cofres y recursos)
 * @param {Array<object> | undefined} interactableList - Lista de interactables de dungeonDefinitions.
 */
function spawnDungeonInteractables(interactableList) {
    if (!interactableList || !Array.isArray(interactableList) || !world.dungeon) return;
    console.log(`[Dungeon] Spawning ${interactableList.length} interactables...`);

    interactableList.forEach(intData => {
        if (!intData || !intData.type || !intData.pos) return;

        const position = new THREE.Vector3(intData.pos.x, intData.pos.y ?? 0, intData.pos.z);
        let interactableObject = null;

        try {
            switch (intData.type) {
                case 'chest':
                    interactableObject = createChestModel(); // Asume que esta función existe
                    if (interactableObject) {
                        const chestId = `dungeon_${gameState.currentLocation}_chest_${Math.round(position.x)}_${Math.round(position.z)}`;
                        const isOpen = world.worldStateData.openedChests.has(chestId); // Comprobar si ya se abrió
                        interactableObject.userData = {
                            type: 'chest', id: chestId, isOpen: isOpen, interactable: !isOpen,
                            loot: isOpen ? [] : generateChestLoot(intData.level || 5),
                            interact: openChest, // Asegúrate que openChest exista
                            dungeonId: gameState.currentLocation // Marcar como de dungeon
                        };
                         // Animar si está abierto
                         if (isOpen) { const lid = interactableObject.getObjectByName('lidPivot'); if(lid) lid.rotation.x = -Math.PI / 1.6; }
                    }
                    break;
                case 'resource':
                    if (intData.defId && resourceDefinitions[intData.defId]) {
                        interactableObject = createResourceNodeModel(resourceDefinitions[intData.defId].resourceType, intData.defId); // Asume que existe
                        if (interactableObject) {
                            const nodeId = `dungeon_${gameState.currentLocation}_node_${intData.defId}_${Math.round(position.x)}_${Math.round(position.z)}`;
                            const isDepleted = !!world.worldStateData.depletedNodes[nodeId]; // Comprobar estado
                            interactableObject.userData = {
                                type: 'resource', id: nodeId, depleted: isDepleted, interactable: !isDepleted,
                                resourceDefId: intData.defId, resourceType: resourceDefinitions[intData.defId].resourceType,
                                interact: harvestResource, // Asegúrate que harvestResource exista
                                dungeonId: gameState.currentLocation // Marcar como de dungeon
                            };
                            // Cambiar apariencia si está agotado
                             if (isDepleted) { interactableObject.scale.setScalar(0.4); /* ... más cambios visuales ... */ }
                        }
                    } else { console.warn(`Interactable resource definition ${intData.defId} not found.`); }
                    break;
                case 'altar': // Ejemplo para altares
                    interactableObject = createShrineModel(intData.effect || 'heal_player_full'); // Asume que existe
                     if (interactableObject) {
                         interactableObject.userData = {
                             type: 'shrine', // O 'altar'
                             id: intData.id || `dungeon_${gameState.currentLocation}_altar_${Math.round(position.x)}_${Math.round(position.z)}`,
                             name: intData.name || "Altar Misterioso",
                             effect: intData.effect || 'heal_player_full',
                             interactable: true, // Asumir interactuable inicialmente
                             interact: (obj) => activateShrine(obj, obj.userData.effect), // Llamar a tu función activateShrine
                             dungeonId: gameState.currentLocation
                         };
                     }
                    break;
                // Añadir más tipos (palancas, puertas, etc.)
                default:
                    console.warn(`Tipo de interactable de dungeon no soportado: ${intData.type}`);
            }

            // Añadir objeto creado a la escena y listas
            if (interactableObject) {
                interactableObject.position.copy(position);
                // Ajustar Y para que esté sobre el suelo (Y=0)
                interactableObject.position.y += (interactableObject.userData?.heightOffset || 0.1);
                interactableObject.rotation.y = intData.rotY || Math.random() * Math.PI * 2;
                interactableObject.castShadow = true;
                interactableObject.receiveShadow = true; // Interactables pueden recibir sombra

                scene.add(interactableObject);
                world.interactables.push(interactableObject);
                // Añadir a world.objects si necesita colisión
                if (interactableObject.userData.type === 'altar' || interactableObject.userData.type === 'resource') {
                     interactableObject.userData.boundingBox = new THREE.Box3().setFromObject(interactableObject);
                     world.objects.push(interactableObject);
                }
                // Añadir a la lista específica del dungeon si se quiere trackear
                // world.dungeon.interactables.push(interactableObject);
            }
        } catch (error) {
            console.error(`Error spawning dungeon interactable (${intData.type}):`, error);
        }
    });
    console.log("[Dungeon] Interactable spawning complete.");
}



/**
 * Spawnea enemigos específicos del dungeon, colocándolos en posiciones fijas o aleatorias.
 * (v1 - Spawn Fijo y Aleatorio Básico)
 * @param {Array<object>} enemyList - Lista de enemigos de dungeonDefinitions.
 * @param {object} layout - Información del layout del dungeon (para límites de spawn aleatorio).
 */
async function spawnDungeonEnemies(enemyList, layout) {
    if (!enemyList || !Array.isArray(enemyList) || !world.dungeon) return;
    console.log(`[Dungeon] Spawning ${enemyList.length} enemy definitions...`);

    const spawnPromises = [];
    const [dWidth, dHeight, dDepth] = layout?.size || [50, 10, 50]; // Tamaño para spawn aleatorio
    const floorY = 0; // Asumiendo que el suelo está en Y=0

    enemyList.forEach(enemyInfo => {
        if (!enemyInfo || !enemyInfo.type) return;
        const enemyDef = enemyDefinitions[enemyInfo.type];
        if (!enemyDef) { console.warn(`spawnDungeonEnemies: Definición no encontrada para ${enemyInfo.type}`); return; }

        const count = enemyInfo.count || 1;

        for (let i = 0; i < count; i++) {
            let spawnPos;
            let spawnRotY = Math.random() * Math.PI * 2;

            if (enemyInfo.pos) { // Posición fija definida
                spawnPos = new THREE.Vector3(enemyInfo.pos.x, enemyInfo.pos.y ?? floorY, enemyInfo.pos.z);
                spawnRotY = enemyInfo.rotY ?? spawnRotY;
            } else { // Posición aleatoria dentro de los límites
                const margin = 2; // Margen para no spawnear pegado a la pared
                const randX = (Math.random() - 0.5) * (dWidth - margin * 2);
                const randZ = (Math.random() - 0.5) * (dDepth - margin * 2);
                spawnPos = new THREE.Vector3(randX, floorY, randZ);
                // TODO: Añadir check de colisión simple para evitar spawn dentro de pilares?
            }

            // Lanzar creación asíncrona del enemigo
            const promise = createAndAddEnemy(enemyInfo.type, spawnPos, spawnRotY)
                .then(enemyObj => {
                    if (enemyObj) {
                        // Asegurarse de que el dungeonId se marcó en createAndAddEnemy
                        if (enemyObj.userData.dungeonId !== gameState.currentLocation) {
                            console.warn(`Enemy ${enemyInfo.type} spawned but missing correct dungeonId!`);
                            enemyObj.userData.dungeonId = gameState.currentLocation;
                        }
                        // Añadir a la lista específica del dungeon si se quiere trackear
                        // world.dungeon.enemies.push(enemyObj);
                    }
                })
                .catch(err => {
                    console.error(`Failed to spawn dungeon enemy ${enemyInfo.type} at (${spawnPos.x}, ${spawnPos.z}):`, err);
                });
            spawnPromises.push(promise);
        } // fin for count
    });

    // Esperar a que todas las promesas de spawn terminen (opcional, pero bueno para logs)
    await Promise.all(spawnPromises);
    console.log(`[Dungeon] Enemy spawning process complete. Total active enemies: ${world.enemies.length}`);
}



/** Helper ASÍNCRONO para crear enemigos (usado por EnemySpawner y spawnDungeonEnemies). */
async function createAndAddEnemy(enemyType, position, rotationY, spawnPointData = {}) {
    // Usa tu lógica existente (async, carga GLB, ajusta Y, userData, etc.)
    // Asegúrate de añadir el enemigo a scene, world.enemies, y world.objects.
    // Retorna el objeto enemigo creado o null.
    // ... (implementación basada en tu código v2.5) ...
     const enemyDef = enemyDefinitions[enemyType]; if (!enemyDef || !enemyDef.modelPath) return null;
     try {
         const gltf = await loadGLBModel(enemyDef.modelPath); const loadedModel = gltf.scene; const animations = gltf.animations;
         const modelBox = new THREE.Box3().setFromObject(loadedModel); const pivotOffsetY = -modelBox.min.y; const definedHeightOffset = enemyHeightOffsets[enemyType]; const finalHeightOffset = typeof definedHeightOffset === 'number' ? definedHeightOffset : pivotOffsetY;
         const finalY = position.y + finalHeightOffset; // Usa position.y (altura del terreno) + offset
         const enemyGroup = new THREE.Group(); enemyGroup.name = `Enemy_${enemyType}`; enemyGroup.position.set(position.x, finalY, position.z); enemyGroup.rotation.y = rotationY ?? (Math.random() * Math.PI * 2);
         loadedModel.name = "EnemyVisualModel"; loadedModel.rotation.y = -Math.PI / 2;
         loadedModel.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; /* Ajustar mats si quieres */ } });
         let scale = enemyDef.scaleMultiplier || 1.0; loadedModel.scale.set(scale, scale, scale); enemyGroup.add(loadedModel);
         let mixer = null; const animMap = {}; if (animations?.length > 0) { mixer = new THREE.AnimationMixer(loadedModel); animations.forEach(c=>{if(c.name)animMap[c.name.toLowerCase()]=c;}); const idle = animMap['idle']||animMap['idle_base']||Object.values(animMap)[0]; if(idle)mixer.clipAction(idle).play(); }
         enemyGroup.userData = { // --- UserData Completo ---
             type: 'enemy', enemyType: enemyType, name: enemyDef.name || enemyType,
             health: enemyDef.health || 30, maxHealth: enemyDef.health || 30,
             damage: enemyDef.damage || { min: 3, max: 6 }, attackCooldown: enemyDef.attackCooldown || 2000,
             attackRange: enemyDef.attackRange || 2.0, xp: enemyDef.xp || 10,
             loot: enemyDef.loot || [], equipmentLoot: enemyDef.equipmentLoot || [],
             equipmentLootChance: enemyDef.equipmentLootChance || 0.05, lootChance: enemyDef.lootChance || 0.3,
             resistances: enemyDef.resist || {}, isDead: false, isProcessingDeath: false, isAggro: false,
             lastAttackTime: 0, aiState: 'idle', wanderTarget: null, target: null,
             spawnPosition: enemyGroup.position.clone(), heightOffset: finalHeightOffset,
             mixer: mixer, animations: animMap,
             deathAnimationClips: findAnimationClips(animations, ['Death','Die','Fall']), // Asume que findAnimationClips existe
             isKnockedBack: false, knockbackVelocity: new THREE.Vector3(),
             abilities: enemyDef.abilities || [], lastAbilityTime: {},
             hitRadius: enemyDef.hitRadius || 0.7, detectionRange: enemyDef.detectionRange || 18,
             loseAggroRange: enemyDef.loseAggroRange || 30, fleeHealthPercent: enemyDef.fleeHealthPercent,
             canFlee: enemyDef.canFlee !== false,
             // --- Datos del Spawner (si vienen de ahí) ---
             spawnPointId: spawnPointData.id, originChunkKey: spawnPointData.originChunkKey,
             respawnTime: spawnPointData.respawnTime, isUnique: spawnPointData.isUnique,
             
             // --- Marcar si es de Dungeon ---
        dungeonId: gameState.currentLocation !== 'world' ? gameState.currentLocation : null
         };
         enemyGroup.userData.boundingBox = new THREE.Box3().setFromObject(enemyGroup); // Añadir BBox
         scene.add(enemyGroup); world.enemies.push(enemyGroup); world.objects.push(enemyGroup);
         return enemyGroup;
     } catch (error) { console.error(`Error creando enemigo ${enemyType}:`, error); return null; }
}
    
    
/**
 * Handles exiting a dungeon and returning to the overworld.
 * (v3 - Scene Removal/Addition, Restore Environment)
 */
function exitDungeon() {
    console.log("[Dungeon] Attempting to exit...");
    if (gameState.currentLocation === 'world') {
        logMessage("Ya estás en el mundo principal.", "info"); return;
    }
    const currentDungeonId = gameState.currentLocation;
    const dungeonDef = dungeonDefinitions[currentDungeonId];
    logMessage(`Saliendo de ${dungeonDef?.name || 'la mazmorra'}...`, "system");
    AudioManager.playSound('teleport', 0.6);
    gameState.isLoading = true; // Bloquear updates

    // --- 1. Clear Dungeon Specific Elements ---
    console.log("[Dungeon] Clearing dungeon elements...");

    // a. Remover Geometría, Luz Ambiental, Enemigos, Interactables, Items del dungeon
    if (world.dungeon?.geometryGroup?.parent) { scene.remove(world.dungeon.geometryGroup); world.dungeon.geometryGroup.traverse(child => { /* Dispose */ if (child.isMesh){child.geometry?.dispose(); if(child.material){const m=Array.isArray(child.material)?child.material:[child.material]; m.forEach(mat=>{mat.map?.dispose();mat.dispose();});}} }); }
    if (world.dungeon?.ambientLight?.parent) { scene.remove(world.dungeon.ambientLight); }
    world.enemies.filter(e => e.userData?.dungeonId === currentDungeonId).forEach(e => { if(e.parent) scene.remove(e); /* Dispose? */ });
    world.interactables.filter(i => i.userData?.dungeonId === currentDungeonId).forEach(i => { if(i.parent) scene.remove(i); /* Dispose? */ });
    world.items.filter(i => i.userData?.dungeonId === currentDungeonId).forEach(i => { if(i.parent) scene.remove(i); /* Dispose? */ });

    // b. Limpiar listas globales de elementos del dungeon
    world.enemies = world.enemies.filter(e => e.userData?.dungeonId !== currentDungeonId);
    world.interactables = world.interactables.filter(i => i.userData?.dungeonId !== currentDungeonId);
    world.items = world.items.filter(i => i.userData?.dungeonId !== currentDungeonId);
    world.objects = world.objects.filter(o => o.userData?.dungeonId !== currentDungeonId); // Limpiar objetos estructurales

    world.dungeon = {}; // Resetear contenedor
    console.log("[Dungeon] Dungeon elements cleared.");

    // --- 2. Restore Overworld Elements from Backup ---
    console.log("[Dungeon] Restoring overworld elements...");
    if (Array.isArray(world.overworldObjectsToRemove)) {
        console.log(`  Adding ${world.overworldObjectsToRemove.length} overworld objects back to scene...`);
        world.overworldObjectsToRemove.forEach(obj => {
            if (obj && !obj.parent) { // Añadir solo si no está ya en la escena por alguna razón
                 scene.add(obj);
                 // Readicionar a listas globales si es necesario (interactables, objects para colisión)
                 if (obj.userData?.interactable) world.interactables.push(obj);
                 if (obj.userData?.boundingBox && obj.userData?.type !== 'player') world.objects.push(obj);
            }
        });
        world.overworldObjectsToRemove = []; // Limpiar backup
    } else { console.warn("No overworld backup found to restore."); }

    // --- 3. Restore Player Position (ABSOLUTA del Overworld) ---
    console.log("[Dungeon] Restoring player state...");
    if (playerState.lastWorldPosition instanceof THREE.Vector3) {
        playerState.position.copy(playerState.lastWorldPosition);
        playerState.rotationY = playerState.lastWorldRotationY ?? Math.PI;
        playerState.velocity.set(0, 0, 0);
        // <<< USA getGroundHeightAt para la altura del OVERWORLD >>>
        const terrainY = getGroundHeightAt(playerState.position.x, playerState.position.z);
        playerState.position.y = terrainY + PLAYER_HALF_HEIGHT;
        playerState.onGround = true;
        if (playerModel) { playerModel.position.copy(playerState.position); playerModel.rotation.y = playerState.rotationY; }
        playerState.lastWorldPosition = null;
        playerState.lastWorldRotationY = Math.PI;
    } else { /* Fallback a RESPAWN_POINT */ console.error("[Dungeon] lastWorldPosition not found!"); playerState.position.copy(RESPAWN_POINT); const tY = getGroundHeightAt(RESPAWN_POINT.x, RESPAWN_POINT.z); playerState.position.y = tY + PLAYER_HALF_HEIGHT; if(playerModel){playerModel.position.copy(playerState.position);} }
    // Resetear cámara
    if (camera && orbitControls) { updateCameraPosition(0.1); orbitControls.target.copy(playerState.position); orbitControls.update(); }

    // --- 4. Restore Overworld Environment ---
    console.log("[Dungeon] Restoring environment...");
    gameState.currentLocation = 'world';
    if (scene) {
        // Restaurar luces solares a su intensidad original guardada
        scene.traverse(obj => {
            if (obj.isLight && (obj.userData?.type === 'sun' || obj.userData?.type === 'moon')) {
                if (obj.userData.originalIntensity !== undefined) {
                    obj.intensity = obj.userData.originalIntensity;
                    delete obj.userData.originalIntensity; // Limpiar dato guardado
                }
            }
        });
        // updateTimeOfDay recalculará la niebla/fondo del overworld basado en la hora actual
        updateTimeOfDay(0);
    }
    AudioManager.updateMusic(); // Actualizar música al tema del overworld

    // --- 5. Force ChunkManager Update ---
    ChunkManager.playerChunkCoords = { x: -Infinity, z: -Infinity }; // Forzar reactivación de chunks
    console.log("[Dungeon] ChunkManager update forced.");

    gameState.isLoading = false; // Desbloquear updates
    console.log("[Dungeon] Player returned to world successfully.");
}


/**
 * Inicializa todas las definiciones de datos del juego.
 * Define estructuras independientes y luego las asigna a worldData.
 */
function initGameDataDefinitions() {
    console.log("Poblando definiciones de juego completas (vCitiesFixed)...");

    // ============================================
    // === DEFINICIONES DE DATOS INDIVIDUALES ===
    // ============================================

    // --- ITEMS ---
    itemDefinitions = {
        // Herramientas
        pickaxe: { id: 'pickaxe', name: 'Piquete de Minero', icon: '<img src="icons/pickaxe.png" alt="Pico">', icon_type:'html', type: 'tool', slot: 'weapon', rarity: 'common', value: 20, stackable: false, toolType: 'mining', description: 'Para minar vetas de nivel bajo.', worldModelPath: 'models/items/loot_pickaxe.glb' },
        gold_pickaxe: { id: 'gold_pickaxe', name: 'Piquete Dorado', icon: '<img src="icons/gold_pickaxe.png" alt="Pico Oro">', icon_type:'html', type: 'tool', slot: 'weapon', rarity: 'rare', value: 150, stackable: false, toolType: 'mining', requirements: { level: 33 }, description: 'Necesario para extraer oro.', worldModelPath: 'models/items/loot_pickaxe_gold.glb' },
        wood_axe: { id: 'wood_axe', name: 'Hacha Leñador', icon: '<img src="icons/wood_axe.png" alt="Hacha">', icon_type:'html', type: 'tool', slot: 'weapon', rarity: 'common', value: 18, stackable: false, toolType: 'woodcutting', stats: { physDmgMin: 2, physDmgMax: 5 }, requirements: { level: 1 }, description: 'Para talar madera común.', worldModelPath: 'models/items/loot_axe.glb' },
        elfic_axe: { id: 'elfic_axe', name: 'Hacha Élfica', icon: '<img src="icons/elfic_axe.png" alt="Hacha Élfica">', icon_type:'html', type: 'tool', slot: 'weapon', rarity: 'rare', value: 200, stackable: false, toolType: 'woodcutting', stats: { physDmgMin: 5, physDmgMax: 9 }, requirements: { level: 23 }, description: 'Necesaria para madera élfica.', worldModelPath: 'models/items/loot_axe_elfic.glb' },
        fishing_rod: { id: 'fishing_rod', name: 'Caña de Pescar', icon: '<img src="icons/fishing_rod.png" alt="Caña">', icon_type:'html', type: 'tool', rarity: 'common', value: 15, stackable: false, toolType: 'fishing', requirements: { level: 1 }, description: 'Para pescar en la orilla.', worldModelPath: 'models/items/loot_fishing_rod.glb' },
        fishing_net: { id: 'fishing_net', name: 'Red de Pesca', icon: '<img src="icons/fishing_net.png" alt="Red">', icon_type:'html', type: 'tool', rarity: 'uncommon', value: 80, stackable: false, toolType: 'fishing', requirements: { level: 23 }, description: 'Para pescar en alta mar.', worldModelPath: 'models/items/loot_fishing_net.glb' },
        saw: { id: 'saw', name: 'Serrucho', icon: '<img src="icons/saw.png" alt="Serrucho">', icon_type:'html', type: 'tool', rarity: 'common', value: 12, stackable: false, toolType: 'carpentry', requirements: { level: 1 }, description: 'Herramienta básica de carpintería.', worldModelPath: 'models/items/loot_saw.glb' },
        blacksmith_hammer: { id: 'blacksmith_hammer', name: 'Martillo de Herrero', icon: '<img src="icons/hammer.png" alt="Martillo">', icon_type:'html', type: 'tool', slot: 'weapon', rarity: 'common', value: 22, stackable: false, toolType: 'blacksmithing', stats: { physDmgMin: 3, physDmgMax: 6 }, description: 'Para forjar metales.', worldModelPath: 'models/items/loot_hammer.glb' },
        alchemy_pot: { id: 'alchemy_pot', name: 'Olla de Alquimia', icon: '<img src="icons/pot.png" alt="Olla">', icon_type:'html', type: 'tool', rarity: 'common', value: 25, stackable: false, toolType: 'alchemy', classRequirement: ['worker'], description: 'Necesaria para ciertas pociones.', worldModelPath: 'models/items/loot_pot.glb' },
        mortar_pestle: { id: 'mortar_pestle', name: 'Mortero', icon: '<img src="icons/mortar.png" alt="Mortero">', icon_type:'html', type: 'tool', rarity: 'common', value: 10, stackable: false, toolType: 'alchemy', classRequirement: ['worker'], description: 'Para preparar ingredientes alquímicos.', worldModelPath: 'models/items/loot_mortar.glb' },
        sewing_kit: { id: 'sewing_kit', name: 'Costurero', icon: '<img src="icons/sewing_kit.png" alt="Costurero">', icon_type:'html', type: 'tool', rarity: 'common', value: 15, stackable: false, toolType: 'tailoring', description: 'Herramientas básicas de sastrería.', worldModelPath: 'models/items/loot_sewing_kit.glb' },
        lute: { id: 'lute', name: 'Laúd', icon: '<img src="icons/lute.png" alt="Laúd">', icon_type:'html', type: 'instrument', rarity: 'uncommon', value: 40, stackable: false, instrumentType: 'lute', classRequirement: ['bard'], description: 'Instrumento para bardos.', worldModelPath: 'models/items/loot_lute.glb'},
        flute: { id: 'flute', name: 'Flauta', icon: '<img src="icons/flute.png" alt="Flauta">', icon_type:'html', type: 'instrument', rarity: 'uncommon', value: 35, stackable: false, instrumentType: 'flute', classRequirement: ['druid'], description: 'Instrumento para druidas.', worldModelPath: 'models/items/loot_flute.glb'},

        // Materiales
        coal: { id: 'coal', name: 'Carbón', icon: '<img src="icons/coal.png" alt="Carbón">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 100, description: 'Combustible básico.' },
        iron_ore: { id: 'iron_ore', name: 'Mena de Hierro', icon: '<img src="icons/iron_ore.png" alt="Mena Hierro">', icon_type:'html', type: 'material', rarity: 'common', value: 3, stackable: true, maxStack: 50, description: 'Mineral de hierro en bruto.', worldModelPath: 'models/items/loot_ore_iron.glb' },
        copper_ore: { id: 'copper_ore', name: 'Mena de Cobre', icon: '<img src="icons/copper_ore.png" alt="Mena Cobre">', icon_type:'html', type: 'material', rarity: 'common', value: 2, stackable: true, maxStack: 50, description: 'Mineral de cobre.', worldModelPath: 'models/items/loot_ore_copper.glb' },
        silver_ore: { id: 'silver_ore', name: 'Mena de Plata', icon: '<img src="icons/silver_ore.png" alt="Mena Plata">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 10, stackable: true, maxStack: 50, description: 'Mineral de plata.', worldModelPath: 'models/items/loot_ore_silver.glb' },
        gold_ore: { id: 'gold_ore', name: 'Mena de Oro', icon: '<img src="icons/gold_ore.png" alt="Mena Oro">', icon_type:'html', type: 'material', rarity: 'rare', value: 25, stackable: true, maxStack: 50, description: 'Mineral de oro precioso.', worldModelPath: 'models/items/loot_ore_gold.glb' },
        iron_ingot: { id: 'iron_ingot', name: 'Lingote de Hierro', icon: '<img src="icons/iron_ingot.png" alt="Lingote Hierro">', icon_type:'html', type: 'material', rarity: 'common', value: 8, stackable: true, maxStack: 50, description: 'Hierro refinado listo para forjar.', worldModelPath: 'models/items/loot_ingot_iron.glb' },
        silver_ingot: { id: 'silver_ingot', name: 'Lingote de Plata', icon: '<img src="icons/silver_ingot.png" alt="Lingote Plata">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 25, stackable: true, maxStack: 50, description: 'Plata purificada.', worldModelPath: 'models/items/loot_ingot_silver.glb' },
        gold_ingot: { id: 'gold_ingot', name: 'Lingote de Oro', icon: '<img src="icons/gold_ingot.png" alt="Lingote Oro">', icon_type:'html', type: 'material', rarity: 'rare', value: 60, stackable: true, maxStack: 50, description: 'Oro brillante y maleable.', worldModelPath: 'models/items/loot_ingot_gold.glb' },
        wood_log: { id: 'wood_log', name: 'Leña Común', icon: '<img src="icons/wood_log.png" alt="Leña">', icon_type:'html', type: 'material', rarity: 'common', value: 2, stackable: true, maxStack: 100, description: 'Madera básica para construcción o fuego.', worldModelPath: 'models/items/loot_log.glb' },
        elfic_wood_log: { id: 'elfic_wood_log', name: 'Leña Élfica', icon: '<img src="icons/elfic_wood_log.png" alt="Leña Élfica">', icon_type:'html', type: 'material', rarity: 'rare', value: 15, stackable: true, maxStack: 100, description: 'Madera ligera y resonante.', worldModelPath: 'models/items/loot_log_elfic.glb' },
        healing_herb: { id: 'healing_herb', name: 'Hierba Curativa', icon: '<img src="icons/herb_heal.png" alt="Hierba">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 50, description: 'Planta con propiedades medicinales.', worldModelPath: 'models/items/loot_herb_heal.glb' },
        mana_herb: { id: 'mana_herb', name: 'Hierba de Maná', icon: '<img src="icons/herb_mana.png" alt="Hierba Mana">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 3, stackable: true, maxStack: 50, description: 'Hierba imbuida de energía arcana.', worldModelPath: 'models/items/loot_herb_mana.glb' },
        magic_crystal: { id: 'magic_crystal', name: 'Cristal Mágico', icon: '<img src="icons/crystal.png" alt="Cristal">', icon_type:'html', type: 'material', rarity: 'rare', value: 15, stackable: true, maxStack: 10, description: 'Un fragmento de poder arcano solidificado.', worldModelPath: 'models/items/loot_crystal.glb' },
        empty_flask: { id: 'empty_flask', name: 'Frasco Vacío', icon: '<img src="icons/flask_empty.png" alt="Frasco">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 50, description: 'Recipiente para líquidos.', worldModelPath: 'models/items/loot_flask_empty.glb' },
        wolf_pelt: { id: 'wolf_pelt', name: 'Piel de Lobo', icon: '<img src="icons/pelt_wolf.png" alt="Piel Lobo">', icon_type:'html', type: 'material', rarity: 'common', value: 4, stackable: true, maxStack: 30, description: 'Piel de lobo gris.', worldModelPath: 'models/items/loot_pelt.glb' },
        bear_pelt: { id: 'bear_pelt', name: 'Piel de Oso', icon: '<img src="icons/pelt_bear.png" alt="Piel Oso">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 12, stackable: true, maxStack: 20, description: 'Piel gruesa y resistente de oso.', worldModelPath: 'models/items/loot_pelt_bear.glb' },
        fishing_thread: { id: 'fishing_thread', name: 'Hilo de Pesca', icon: '<img src="icons/thread.png" alt="Hilo">', icon_type:'html', type: 'material', rarity: 'common', value: 2, stackable: true, maxStack: 20, description: 'Hilo resistente para reparar cañas.' },
        orc_tooth: { id: 'orc_tooth', name: 'Diente de Orco', icon: '<img src="icons/tooth.png" alt="Diente">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 5, stackable: true, maxStack: 15, description: 'Un colmillo orco como trofeo.', worldModelPath: 'models/items/loot_tooth.glb' },
        snake_fang: { id: 'snake_fang', name: 'Colmillo de Serpiente', icon: '<img src="icons/fang.png" alt="Colmillo">', icon_type:'html', type: 'material', rarity: 'common', value: 2, stackable: true, maxStack: 30, description: 'Colmillo afilado.', worldModelPath: 'models/items/loot_fang.glb'},
        feather: { id: 'feather', name: 'Pluma', icon: '<img src="icons/feather.png" alt="Pluma">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 50, description: 'Pluma de ave.', worldModelPath: 'models/items/loot_feather.glb'},
        rat_tail: { id: 'rat_tail', name: 'Cola de Rata', icon: '<img src="icons/tail.png" alt="Cola">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 20, description: 'Una asquerosa cola de rata.', worldModelPath: 'models/items/loot_tail.glb'},
        spider_silk: { id: 'spider_silk', name: 'Seda de Araña', icon: '<img src="icons/silk.png" alt="Seda">', icon_type:'html', type: 'material', rarity: 'common', value: 3, stackable: true, maxStack: 40, description: 'Fibra pegajosa y resistente.', worldModelPath: 'models/items/loot_silk.glb'},
        bone: { id: 'bone', name: 'Hueso', icon: '<img src="icons/bone.png" alt="Hueso">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 50, description: 'Restos óseos.', worldModelPath: 'models/items/loot_bone.glb'},
        scorpion_stinger: { id: 'scorpion_stinger', name: 'Aguijón Escorpión', icon: '<img src="icons/stinger.png" alt="Aguijón">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 6, stackable: true, maxStack: 10, description: 'Aguijón venenoso.', worldModelPath: 'models/items/loot_stinger.glb'},
        troll_hide: { id: 'troll_hide', name: 'Piel de Troll', icon: '<img src="icons/hide_troll.png" alt="Piel Troll">', icon_type:'html', type: 'material', rarity: 'rare', value: 20, stackable: true, maxStack: 10, description: 'Piel extremadamente dura.', worldModelPath: 'models/items/loot_hide_thick.glb'},
        cyclops_eye: { id: 'cyclops_eye', name: 'Ojo de Cíclope', icon: '<img src="icons/eye_cyclops.png" alt="Ojo Ciclope">', icon_type:'html', type: 'material', rarity: 'rare', value: 50, stackable: true, maxStack: 5, description: 'Un gran ojo, aún observa.', worldModelPath: 'models/items/loot_eye.glb'},
        harpy_feather: { id: 'harpy_feather', name: 'Pluma de Arpía', icon: '<img src="icons/feather_harpy.png" alt="Pluma Arpía">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 8, stackable: true, maxStack: 20, description: 'Pluma grande y afilada.', worldModelPath: 'models/items/loot_feather_large.glb'},
        lizard_scale: { id: 'lizard_scale', name: 'Escama de Lagarto', icon: '<img src="icons/scale_lizard.png" alt="Escama Lagarto">', icon_type:'html', type: 'material', rarity: 'uncommon', value: 7, stackable: true, maxStack: 30, description: 'Escama resistente.', worldModelPath: 'models/items/loot_scale.glb'},
        bandages: { id: 'bandages', name: 'Vendas', icon: '<img src="icons/bandages.png" alt="Vendas">', icon_type:'html', type: 'material', rarity: 'common', value: 1, stackable: true, maxStack: 50, description: 'Vendas de tela vieja.', worldModelPath: 'models/items/loot_bandages.glb'},
        stone_heart: { id: 'stone_heart', name: 'Corazón de Piedra', icon: '<img src="icons/heart_stone.png" alt="Corazón Piedra">', icon_type:'html', type: 'material', rarity: 'epic', value: 100, stackable: true, maxStack: 5, description: 'Núcleo de un golem.', worldModelPath: 'models/items/loot_heart_stone.glb'},
        drake_scale: { id: 'drake_scale', name: 'Escama de Draco', icon: '<img src="icons/scale_drake.png" alt="Escama Draco">', icon_type:'html', type: 'material', rarity: 'rare', value: 30, stackable: true, maxStack: 15, description: 'Escama resistente al fuego.', worldModelPath: 'models/items/loot_scale_large.glb'},
        meduza_head: { id: 'meduza_head', name: 'Cabeza de meduza', icon: '<img src="icons/head_meduza.png" alt="Cabeza meduza">', icon_type:'html', type: 'material', rarity: 'rare', value: 40, stackable: true, maxStack: 5, description: 'Cabeza de meduza.', worldModelPath: 'models/items/loot_meduza_head.glb'},
        ice_core: { id: 'ice_core', name: 'Núcleo de Hielo', icon: '<img src="icons/core_ice.png" alt="Núcleo Hielo">', icon_type:'html', type: 'material', rarity: 'rare', value: 35, stackable: true, maxStack: 5, description: 'Esencia de frío elemental.', worldModelPath: 'models/items/loot_core_ice.glb'},
        lich_phylactery_shard: { id: 'lich_phylactery_shard', name: 'Fragmento Filacteria', icon: '<img src="icons/phylactery_shard.png" alt="Frag Filact">', icon_type:'html', type: 'material', rarity: 'epic', value: 250, stackable: true, maxStack: 3, description: 'Fragmento de la fuente de poder de un Liche.', worldModelPath: 'models/items/loot_phylactery_shard.glb'},
        minotaur_horn: { id: 'minotaur_horn', name: 'Cuerno Minotauro', icon: '<img src="icons/horn_minotaur.png" alt="Cuerno Mino">', icon_type:'html', type: 'material', rarity: 'rare', value: 45, stackable: true, maxStack: 10, description: 'Cuerno grueso y pesado.', worldModelPath: 'models/items/loot_horn.glb'},
        dragon_scale_red: { id: 'dragon_scale_red', name: 'Escama Dragón Rojo', icon: '<img src="icons/scale_dragon_red.png" alt="Escama Dragón Rojo">', icon_type:'html', type: 'material', rarity: 'legendary', value: 300, stackable: true, maxStack: 5, description: 'Escama imbuida de fuego.', worldModelPath: 'models/items/loot_scale_dragon.glb'},
        iron_core: { id: 'iron_core', name: 'Núcleo de Hierro', icon: '<img src="icons/core_iron.png" alt="Núcleo Hierro">', icon_type:'html', type: 'material', rarity: 'epic', value: 150, stackable: true, maxStack: 5, description: 'Corazón de un golem de hierro.', worldModelPath: 'models/items/loot_core_metal.glb'},
        beholder_eye: { id: 'beholder_eye', name: 'Ojo Contemplador', icon: '<img src="icons/eye_beholder.png" alt="Ojo Contempl">', icon_type:'html', type: 'material', rarity: 'legendary', value: 400, stackable: true, maxStack: 3, description: 'Un ojo que todo lo ve, lleno de magia.', worldModelPath: 'models/items/loot_eye_magic.glb'},
        demon_heart: { id: 'demon_heart', name: 'Corazón Demonio', icon: '<img src="icons/heart_demon.png" alt="Corazón Demonio">', icon_type:'html', type: 'material', rarity: 'legendary', value: 500, stackable: true, maxStack: 3, description: 'Corazón oscuro y corrupto.', worldModelPath: 'models/items/loot_heart_demon.glb'},
        herradura: { id: 'herradura', name: 'Herradura', icon: '<img src="icons/horseshoe.png" alt="Herradura">', icon_type:'html', type:'material', rarity:'common', value: 10, stackable:true, maxStack:20, description:'Para caballos.'},
        plank: { id: 'plank', name: 'Tablón', icon: '<img src="icons/plank.png" alt="Tablón">', icon_type:'html', type:'material', rarity:'common', value: 5, stackable:true, maxStack:50, description:'Madera procesada.', worldModelPath: 'models/items/loot_plank.glb'},

        // MONEDA
        gold_coin: { id: 'gold_coin', name: 'Moneda de Oro', icon: '<img src="icons/gold_coin.png" alt="Oro">', icon_type:'html', type: 'currency', rarity: 'common', value: 1, description: 'La moneda estándar del reino.', worldModelPath: 'models/items/loot_gold_pile_small.glb' },

        // QUEST ITEMS
        wolfang_pelt_quest: { id: 'wolfang_pelt_quest', name: 'Piel de Wolfang', icon: '<img src="icons/pelt_wolf_quest.png" alt="Piel Quest">', icon_type:'html', type: 'material', rarity: 'quest', value: 0, stackable: false, questItem: true, description: 'Piel única del temible líder lobo.', worldModelPath: 'models/items/loot_pelt_unique.glb' },
        // Añadir más items de quest según sea necesario

        // CONSUMIBLES
        health_potion: { id: 'health_potion', name: 'Poción de Salud', icon: '<img src="icons/potion_health.png" alt="Poción Vida">', icon_type:'html', type: 'consumable', rarity: 'common', value: 10, stackable: true, maxStack: 20, use: (user) => { const v=50; if(user.stats.health>=user.stats.maxHealth){logMessage("Salud al máximo."); return false;} const healed = Math.min(v, user.stats.maxHealth - user.stats.health); user.stats.health+=healed; showFloatingText('heal-text',`+${Math.floor(healed)}`,user.position); return true; }, description: 'Restaura 50 PS.', worldModelPath: 'models/items/loot_potion_health.glb' },
        mana_potion: { id: 'mana_potion', name: 'Poción de Maná', icon: '<img src="icons/potion_mana.png" alt="Poción Mana">', icon_type:'html', type: 'consumable', rarity: 'common', value: 15, stackable: true, maxStack: 20, use: (user) => { const v=40; if(user.stats.mana>=user.stats.maxMana){logMessage("Maná al máximo."); return false;} const restored = Math.min(v, user.stats.maxMana - user.stats.mana); user.stats.mana+=restored; showFloatingText('mana-text',`+${Math.floor(restored)}`,user.position); return true; }, description: 'Restaura 40 PM.', worldModelPath: 'models/items/loot_potion_mana.glb' },
        antidote_potion: { id: 'antidote_potion', name: 'Antídoto', icon: '<img src="icons/potion_antidote.png" alt="Antídoto">', icon_type:'html', type: 'consumable', rarity: 'uncommon', value: 25, stackable: true, maxStack: 10, use: (user) => { const removed = removeStatusEffect('poison'); if(!removed) logMessage("No estás envenenado."); return removed; }, description: 'Cura el veneno.', worldModelPath: 'models/items/loot_potion_antidote.glb' },
        potion_agility: { id: 'potion_agility', name: 'Poción de Agilidad', icon: '<img src="icons/potion_agility.png" alt="Poción Agi">', icon_type:'html', type: 'consumable', rarity: 'uncommon', value: 30, stackable: true, maxStack: 10, use: (user) => { addStatusEffect({...AGILITY_BUFF_DATA, duration: 60}); return true; }, description: 'Aumenta Destreza (+3) por 60s.', worldModelPath: 'models/items/loot_potion_strength_buff.glb' },
        potion_strength: { id: 'potion_strength', name: 'Poción de Fuerza', icon: '<img src="icons/potion_strength.png" alt="Poción Str">', icon_type:'html', type: 'consumable', rarity: 'uncommon', value: 30, stackable: true, maxStack: 10, use: (user) => { addStatusEffect({...STRENGTH_BUFF_DATA, duration: 60}); return true; }, description: 'Aumenta Fuerza (+3) por 60s.', worldModelPath: 'models/items/loot_potion_agility_buff.glb' },
        potion_energy: { id: 'potion_energy', name: 'Poción de Energía', icon: '<img src="icons/potion_energy.png" alt="Poción Ene">', icon_type:'html', type: 'consumable', rarity: 'uncommon', value: 20, stackable: true, maxStack: 10, use: (user) => { const v=60; if(user.stats.stamina>=user.stats.maxStamina){logMessage("Resistencia al máximo."); return false;} const restored = Math.min(v, user.stats.maxStamina - user.stats.stamina); user.stats.stamina+=restored; showFloatingText('system-text',`+${Math.floor(restored)} Resistencia`,user.position); return true; }, description: 'Restaura 60 Resistencia.', worldModelPath: 'models/items/loot_potion_energy.glb' },
        potion_major_heal: {id: 'potion_major_heal', name: 'Poción Curación Mayor', icon:'<img src="icons/potion_health_major.png">', icon_type:'html', type: 'consumable', rarity:'rare', value: 50, stackable: true, maxStack:15, use:(user)=>{const v=120; if(user.stats.health>=user.stats.maxHealth) return false; const h=Math.min(v, user.stats.maxHealth-user.stats.health); user.stats.health+=h; showFloatingText('heal-text',`+${Math.floor(h)}`,user.position); return true; }, description:'Restaura 120 PS.', worldModelPath:'models/items/loot_potion_health_major.glb'},
        potion_major_mana: {id: 'potion_major_mana', name: 'Poción Maná Mayor', icon:'<img src="icons/potion_mana_major.png">', icon_type:'html', type: 'consumable', rarity:'rare', value: 60, stackable: true, maxStack:15, use:(user)=>{const v=100; if(user.stats.mana>=user.stats.maxMana) return false; const r=Math.min(v, user.stats.maxMana-user.stats.mana); user.stats.mana+=r; showFloatingText('mana-text',`+${Math.floor(r)}`,user.position); return true; }, description:'Restaura 100 PM.', worldModelPath:'models/items/loot_potion_mana_major.glb'},

        // ARMAS
        unarmed: {
            id: 'unarmed', name: 'Puños', icon: '<img src="icons/unarmed.png" alt="Puños">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'common', value: 0, stackable: false,
            stats: { physDmgMin: 1, physDmgMax: 3 }, description: 'Tus propios puños.'
            // No allowedClasses needed, everyone has fists
        },
        iron_sword: {
            id: 'iron_sword', name: 'Espada de Hierro', icon: '<img src="icons/sword_iron.png" alt="Espada">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'common', value: 25, stackable: false,
            stats: { physDmgMin: 5, physDmgMax: 9 },
            allowedClasses: ['warrior', 'paladin', 'assassin', 'bandit'], // Fighters, Paladins, maybe Assassins/Bandits
            description: 'Una espada de hierro básica pero fiable.', worldModelPath: 'models/items/loot_sword_iron.glb'
        },
        iron_dagger: {
            id: 'iron_dagger', name: 'Daga de Hierro', icon: '<img src="icons/dagger_iron.png" alt="Daga">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'common', value: 18, stackable: false, isDagger: true,
            stats: { physDmgMin: 3, physDmgMax: 6, critChance: 2 },
            allowedClasses: ['assassin', 'hunter', 'mage', 'worker', 'bard', 'bandit'], // More classes can use daggers
            description: 'Daga rápida, buena para ataques sigilosos.', worldModelPath: 'models/items/loot_dagger_iron.glb'
        },
        steel_axe: {
            id: 'steel_axe', name: 'Hacha de Acero', icon: '<img src="icons/axe_steel.png" alt="Hacha Acero">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'uncommon', value: 60, stackable: false,
            stats: { physDmgMin: 8, physDmgMax: 14, critChance: 2 }, requirements: { level: 5 },
            allowedClasses: ['warrior', 'paladin', 'worker', 'bandit'], // Strength-focused
            description: 'Hacha pesada de acero forjado.', worldModelPath: 'models/items/loot_axe_steel.glb'
        },
        wizard_staff: {
            id: 'wizard_staff', name: 'Bastón de Mago', icon: '<img src="icons/staff_wizard.png" alt="Bastón">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'uncommon', value: 55, stackable: false, twoHanded: true,
            stats: { magicDmgMin: 5, magicDmgMax: 8, maxMana: 15, mpRegen: 0.2 },
            allowedClasses: ['mage', 'druid', 'cleric'], // Magic users (Removed Paladin maybe?)
            requirements: { level: 1 }, // Staff for level 1 mage
            description: 'Un bastón imbuido para canalizar energía arcana.', worldModelPath: 'models/items/loot_staff_wizard.glb'
        },
        short_bow: {
            id: 'short_bow', name: 'Arco Corto', icon: '<img src="icons/bow_short.png" alt="Arco Corto">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'common', value: 20, stackable: false, weaponType: 'bow',
            stats: { physDmgMin: 4, physDmgMax: 7, hitChance: 3 },
            allowedClasses: ['hunter', 'warrior', 'assassin', 'bandit'], // Dexterity/Ranged focused
            description: 'Arco ligero y manejable.', worldModelPath: 'models/items/loot_bow_short.glb'
        },
        iron_mace: {
            id: 'iron_mace', name: 'Maza de Hierro', icon: '<img src="icons/mace_iron.png" alt="Maza Hierro">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'common', value: 30, stackable: false,
            stats: { physDmgMin: 6, physDmgMax: 10 },
            allowedClasses: ['warrior', 'paladin', 'cleric', 'worker'], // Blunt weapon users
            description: 'Arma contundente para aplastar armaduras.', worldModelPath: 'models/items/loot_mace_iron.glb'
        },
        orcish_axe: {
            id: 'orcish_axe', name: 'Hacha Barbara', icon:'<img src="icons/axe_barbara.png">', icon_type:'html',
            type:'weapon', slot:'weapon', rarity:'uncommon', value:70, stackable:false,
            stats:{physDmgMin:10, physDmgMax:17}, requirements:{level:8, strength:15},
            allowedClasses: ['warrior', 'orc', 'bandit'], // Orc/Barbarian flavor
            description:'Hacha tosca pero brutal.', worldModelPath:'models/items/loot_axe_barbara.glb'
        },
        giant_club: {
            id: 'giant_club', name: 'Garrote Gigante', icon:'<img src="icons/club_giant.png">', icon_type:'html',
            type:'weapon', slot:'weapon', rarity:'rare', value:180, stackable:false, twoHanded: true,
            stats:{physDmgMin:25, physDmgMax:40, constitution: 2}, requirements:{level:18, strength:25},
            allowedClasses: ['warrior', 'orc'], // Very strong users
            description:'Un garrote enorme y pesado.', worldModelPath:'models/items/loot_club_giant.glb'
        },
        tribal_spear: {
            id: 'tribal_spear', name: 'Lanza Tribal', icon:'<img src="icons/spear_tribal.png">', icon_type:'html',
            type:'weapon', slot:'weapon', rarity:'uncommon', value:65, stackable:false,
            stats:{physDmgMin:9, physDmgMax:15, hitChance:2}, requirements:{level:10},
            allowedClasses: ['hunter', 'warrior', 'druid'], // Polearm users
            description:'Lanza adornada con motivos tribales.', worldModelPath:'models/items/loot_spear_tribal.glb'
        },
        ogre_club: {
            id: 'ogre_club', name: 'Garrote de Ogro', icon:'<img src="icons/club_ogre.png">', icon_type:'html',
            type:'weapon', slot:'weapon', rarity:'rare', value:250, stackable:false, twoHanded: true,
            stats:{physDmgMin:30, physDmgMax:48, strength:3}, requirements:{level:28, strength:30},
            allowedClasses: ['warrior', 'orc'], // Extremely strong
            description:'Aún más grande y feo.', worldModelPath:'models/items/loot_club_ogre.glb'
        },
        epic_weapon: {
            id: 'epic_weapon', name: 'Hoja Épica', icon:'<img src="icons/sword_epic.png">', icon_type:'html',
            type:'weapon', slot:'weapon', rarity:'epic', value:4000, stackable:false,
            stats:{physDmgMin:50, physDmgMax:75, critChance:5, hitChance:5}, requirements:{level:40},
            // allowedClasses: ['warrior', 'paladin'], // Example: Restrict epics? Or allow all high level?
            description:'Un arma de leyenda.', worldModelPath:'models/items/loot_sword_epic.glb'
        },
        knuckles_basic: {
            id: 'knuckles_basic', name: 'Nudillos Básicos', icon: '<img src="icons/knuckles_basic.png" alt="Nudillos">', icon_type:'html',
            type: 'weapon', slot: 'weapon', rarity: 'common', value: 10, stackable: false, weaponType: 'knuckles',
            stats: { physDmgMin: 2, physDmgMax: 4 },
            allowedClasses: ['assassin', 'worker', 'bandit', 'bard'], // Classes likely to fist fight
            description: 'Protección simple para los puños.', worldModelPath: 'models/items/loot_knuckles_basic.glb'
        },

        // ==== ARMADURAS ====
        cloth_shirt: {
            id: 'cloth_shirt', name: 'Camisa de Tela', icon: '<img src="icons/shirt_cloth.png" alt="Camisa">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'common', value: 5, stackable: false,
            stats: { defense: 1 },
            // allowedClasses: null, // No restriction needed - usable by all
            description: 'Ropa simple de algodón.', worldModelPath: 'models/items/loot_shirt_folded.glb'
        },
        cloth_pants: {
            id: 'cloth_pants', name: 'Pantalones de Tela', icon: '<img src="icons/pants_cloth.png" alt="Pantalones">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'common', value: 4, stackable: false,
            stats: { defense: 1 },
            // allowedClasses: null, // No restriction needed - usable by all
            description: 'Pantalones cómodos pero poco resistentes.', worldModelPath: 'models/items/loot_pants_folded.glb'
        },
        leather_armor: {
            id: 'leather_armor', name: 'Armadura de Cuero', icon: '<img src="icons/armor_leather.png" alt="Armadura Cuero">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'common', value: 20, stackable: false,
            stats: { defense: 3 },
            // allowedClasses: null, // Basic leather usable by most/all
            description: 'Protección básica de cuero curtido.', worldModelPath: 'models/items/loot_armor_leather.glb'
        },
        leather_pants: {
            id: 'leather_pants', name: 'Pantalones de Cuero', icon: '<img src="icons/pants_leather.png" alt="Pantalones Cuero">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'common', value: 15, stackable: false,
            stats: { defense: 2 },
            // allowedClasses: null, // Basic leather usable by most/all
            description: 'Pantalones de cuero resistentes.', worldModelPath: 'models/items/loot_pants_leather.glb'
        },
        chainmail_vest: {
            id: 'chainmail_vest', name: 'Cota de Malla', icon: '<img src="icons/armor_chain.png" alt="Cota Malla">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'uncommon', value: 55, stackable: false,
            stats: { defense: 6, moveSpeed: -0.1 }, requirements: { level: 6 },
            allowedClasses: ['warrior', 'paladin', 'cleric'], // Classes typically using heavy armor
            description: 'Ofrece buena protección contra cortes.', worldModelPath: 'models/items/loot_armor_chain.glb'
        },
        chainmail_leggings: {
            id: 'chainmail_leggings', name: 'Musleras de Malla', icon: '<img src="icons/legs_chain.png" alt="Musleras Malla">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'uncommon', value: 45, stackable: false,
            stats: { defense: 4, moveSpeed: -0.05 }, requirements: { level: 6 },
            allowedClasses: ['warrior', 'paladin', 'cleric'], // Classes typically using heavy armor
            description: 'Protección de malla para las piernas.', worldModelPath: 'models/items/loot_legs_chain.glb'
        },
        mage_robe: {
            id: 'mage_robe', name: 'Túnica de Mago', icon: '<img src="icons/robe_mage.png" alt="Túnica Mago">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'uncommon', value: 40, stackable: false,
            stats: { defense: 2, magicResist: 5, maxMana: 10 },
            allowedClasses: ['mage', 'druid', 'cleric', 'bard'], // Caster/Light armor classes
            requirements: { level: 1 }, // Requirement set to 1
            description: 'Túnica imbuida que potencia la energía arcana.', worldModelPath: 'models/items/loot_robe_folded.glb'
        },
        mage_pants: {
            id: 'mage_pants', name: 'Pantalones de Mago', icon: '<img src="icons/pants_mage.png" alt="Pantalones Mago">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'uncommon', value: 30, stackable: false,
            stats: { defense: 1, magicResist: 3 },
            allowedClasses: ['mage', 'druid', 'cleric', 'bard'], // Caster/Light armor classes
            requirements: { level: 1 }, // Requirement set to 1
            description: 'Pantalones ligeros encantados.', worldModelPath: 'models/items/loot_pants_folded.glb'
        },
        hunter_tunic: {
            id: 'hunter_tunic', name: 'Túnica de Cazador', icon: '<img src="icons/tunic_hunter.png" alt="Túnica Cazador">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'uncommon', value: 45, stackable: false,
            stats: { defense: 4, dexterity: 1 }, requirements: { level: 5 },
            allowedClasses: ['hunter', 'assassin', 'bard'], // Agile/Ranged classes
            description: 'Ropa ligera y silenciosa para acechar.', worldModelPath: 'models/items/loot_tunic_folded.glb'
        },
        hunter_leggings: {
            id: 'hunter_leggings', name: 'Pantalones de Cazador', icon: '<img src="icons/pants_hunter.png" alt="Pantalones Cazador">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'uncommon', value: 35, stackable: false,
            stats: { defense: 3 }, requirements: { level: 5 },
            allowedClasses: ['hunter', 'assassin', 'bard'], // Agile/Ranged classes
            description: 'Pantalones diseñados para el sigilo.', worldModelPath: 'models/items/loot_pants_folded.glb'
        },
        rogue_vest: {
            id: 'rogue_vest', name: 'Chaleco de Pícaro', icon: '<img src="icons/vest_rogue.png" alt="Chaleco Pícaro">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'uncommon', value: 50, stackable: false,
            stats: { defense: 3, critChance: 1 }, requirements: { level: 6 },
            allowedClasses: ['assassin', 'bandit', 'bard'], // Stealthy classes
            description: 'Chaleco oscuro lleno de bolsillos ocultos.', worldModelPath: 'models/items/loot_vest_folded.glb'
        },
        rogue_pants: {
            id: 'rogue_pants', name: 'Pantalones de Pícaro', icon: '<img src="icons/pants_rogue.png" alt="Pantalones Pícaro">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'uncommon', value: 40, stackable: false,
            stats: { defense: 2, moveSpeed: 0.1 }, requirements: { level: 6 },
            allowedClasses: ['assassin', 'bandit', 'bard'], // Stealthy classes
            description: 'Pantalones ajustados que favorecen la agilidad.', worldModelPath: 'models/items/loot_pants_folded.glb'
        },
        worker_shirt: {
            id: 'worker_shirt', name: 'Camisa de Trabajador', icon: '<img src="icons/shirt_worker.png" alt="Camisa Trabajo">', icon_type:'html',
            type: 'armor', slot: 'chest', rarity: 'common', value: 10, stackable: false,
            stats: { defense: 2, constitution: 1 },
            allowedClasses: ['worker', 'warrior'], // Practical classes
            description: 'Ropa resistente para el trabajo duro.', worldModelPath: 'models/items/loot_shirt_folded.glb'
        },
        worker_trousers: {
            id: 'worker_trousers', name: 'Pantalones de Trabajo', icon: '<img src="icons/pants_worker.png" alt="Pantalones Trabajo">', icon_type:'html',
            type: 'armor', slot: 'legs', rarity: 'common', value: 8, stackable: false,
            stats: { defense: 2 },
            allowedClasses: ['worker', 'warrior'], // Practical classes
            description: 'Pantalones reforzados y duraderos.', worldModelPath: 'models/items/loot_pants_folded.glb'
        },
        iron_helm: {
            id: 'iron_helm', name: 'Yelmo de Hierro', icon: '<img src="icons/helm_iron.png" alt="Yelmo Hierro">', icon_type:'html',
            type: 'armor', slot: 'head', rarity: 'common', value: 18, stackable: false,
            stats: { defense: 2 },
            allowedClasses: ['warrior', 'paladin', 'cleric', 'worker', 'bandit'], // Most non-light armor classes
            description: 'Protección básica para la cabeza.', worldModelPath: 'models/items/loot_helm_iron.glb'
        },
        steel_plate_armor: {
            id:'steel_plate_armor', name:'Armadura Placas Acero', icon:'<img src="icons/armor_plate_steel.png">', icon_type:'html',
            type:'armor', slot:'chest', rarity:'rare', value:120, stackable:false,
            stats:{defense:10, moveSpeed:-0.2}, requirements:{level:15, strength:20},
            allowedClasses: ['warrior', 'paladin'], // Heavy armor specialists
            description:'Pesada armadura de placas.', worldModelPath:'models/items/loot_armor_plate_steel.glb'
        },
        ogre_plate: {
            id:'ogre_plate', name:'Placa de Ogro', icon:'<img src="icons/armor_plate_ogre.png">', icon_type:'html',
            type:'armor', slot:'chest', rarity:'rare', value:200, stackable:false,
            stats:{defense:12, strength:2, moveSpeed:-0.25}, requirements:{level:25, strength:28},
            allowedClasses: ['warrior', 'orc'], // Orc flavor heavy armor
            description:'Placa de metal tosco usada por ogros.', worldModelPath:'models/items/loot_armor_plate_ogre.glb'
        },
        boots_of_speed: {
            id: 'boots_of_speed', name: 'Botas de Velocidad', icon: '<img src="icons/boots_speed.png" alt="Botas Vel.">', icon_type:'html',
            type: 'armor', slot: 'feet', rarity: 'rare', value: 120, stackable: false,
            stats: { moveSpeed: 0.5, defense: 1 },
            // allowedClasses: null, // Allow all? Or restrict to agile? Your choice.
            description: 'Encantadas para correr más rápido.', worldModelPath: 'models/items/loot_boots_speed.glb'
        },
        leather_boots: {
            id: 'leather_boots', name: 'Botas de Cuero', icon: '<img src="icons/boots_leather.png" alt="Botas Cuero">', icon_type:'html',
            type: 'armor', slot: 'feet', rarity: 'common', value: 12, stackable:false,
            stats: { defense: 1 },
            // allowedClasses: null, // Usable by all
            description: 'Botas básicas de cuero.', worldModelPath: 'models/items/loot_boots_leather.glb'
        },
        leather_cap: {
            id: 'leather_cap', name: 'Gorro de Cuero', icon: '<img src="icons/cap_leather.png" alt="Gorro Cuero">', icon_type:'html',
            type: 'armor', slot: 'head', rarity: 'common', value: 10, stackable:false,
            stats: { defense: 1 },
            // allowedClasses: null, // Usable by all
            description: 'Un simple gorro de cuero.', worldModelPath: 'models/items/loot_cap_leather.glb'
        },
        // ==== ESCUDOS ====
        wooden_shield: {
            id: 'wooden_shield', name: 'Escudo de Madera', icon:'<img src="icons/shield_wood.png">', icon_type:'html',
            type: 'shield', slot: 'shield', rarity: 'common', value: 15, stackable: false,
            stats: { defense: 2 },
            allowedClasses: ['warrior', 'paladin', 'cleric', 'worker', 'bandit', 'druid'], // Most non-rogue/mage/hunter
            description: 'Un escudo básico de madera.', worldModelPath: 'models/items/loot_shield_wood.glb'
        },
        iron_shield: {
            id: 'iron_shield', name: 'Escudo de Hierro', icon: '<img src="icons/shield_iron.png" alt="Escudo Hierro">', icon_type:'html',
            type: 'shield', slot: 'shield', rarity: 'common', value: 35, stackable: false,
            stats: { defense: 4 },
            allowedClasses: ['warrior', 'paladin', 'cleric', 'worker'], // Standard shield users
            description: 'Un escudo simple pero resistente.', worldModelPath: 'models/items/loot_shield_iron.glb'
        },
        silver_shield: {
            id: 'silver_shield', name: 'Escudo de Plata', icon:'<img src="icons/shield_silver.png">', icon_type:'html',
            type: 'shield', slot: 'shield', rarity: 'uncommon', value: 80, stackable: false,
            stats: { defense: 6, magicResist: 3 }, requirements:{level:12},
            allowedClasses: ['warrior', 'paladin', 'cleric'], // Users of metal shields
            description: 'Escudo de plata con propiedades mágicas.', worldModelPath: 'models/items/loot_shield_silver.glb'
        },
        oak_shield: {
            id: 'oak_shield', name: 'Escudo de Roble', icon:'<img src="icons/shield_oak.png">', icon_type:'html',
            type: 'shield', slot: 'shield', rarity: 'uncommon', value: 70, stackable: false,
            stats: { defense: 5 }, requirements:{level:10},
            allowedClasses: ['warrior', 'paladin', 'druid', 'cleric'], // Include Druid for wood theme
            description: 'Escudo robusto de madera de roble.', worldModelPath: 'models/items/loot_shield_oak.glb'
        },

        // ACCESORIOS
        amulet_of_power: { id: 'amulet_of_power', name: 'Amuleto de Poder', icon: '<img src="icons/amulet_power.png" alt="Amuleto">', icon_type:'html', type: 'amulet', slot: 'amulet', rarity: 'rare', value: 150, stackable: false, stats: { strength: 2, intelligence: 2 }, description: 'Incrementa atributos.', worldModelPath: 'models/items/loot_amulet_generic.glb' },
        ring_of_regen: { id: 'ring_of_regen', name: 'Anillo de Regeneración', icon: '<img src="icons/ring_regen.png" alt="Anillo Regen">', icon_type:'html', type: 'ring', slot: 'ring', rarity: 'uncommon', value: 80, stackable: false, stats: { hpRegen: 0.3 }, description: 'Acelera la curación natural.', worldModelPath: 'models/items/loot_ring_generic.glb' },
        ring_magic_resist: { id: 'ring_magic_resist', name: 'Anillo Res. Mágica', icon:'<img src="icons/ring_magic_res.png">', icon_type:'html', type:'ring', slot:'ring', rarity:'uncommon', value: 90, stackable:false, stats:{magicResist: 5}, description:'Anillo que protege contra la magia.', worldModelPath:'models/items/loot_ring_magic.glb'},
        legendary_amulet: { id: 'legendary_amulet', name: 'Amuleto Legendario', icon:'<img src="icons/amulet_legendary.png">', icon_type:'html', type:'amulet', slot:'amulet', rarity:'legendary', value:5000, stackable:false, stats:{strength:5, dexterity:5, intelligence:5, constitution:5, hpRegen:1, mpRegen:1}, description:'Un amuleto de poder ancestral.', worldModelPath:'models/items/loot_amulet_legendary.glb'},

        // FLECHAS
        arrow_common: { id: 'arrow_common', name: 'Flecha Común', icon:'<img src="icons/arrow_common.png">', icon_type:'html', type:'ammo', ammoType:'arrow', rarity:'common', value:1, stackable:true, maxStack: 250, stats:{physDmgMin:2, physDmgMax:4}, description:'Flecha estándar.', worldModelPath:'models/items/loot_arrow.glb' },
        arrow_plus1: { id: 'arrow_plus1', name: 'Flecha +1', icon:'<img src="icons/arrow_plus1.png">', icon_type:'html', type:'ammo', ammoType:'arrow', rarity:'uncommon', value:3, stackable:true, maxStack: 200, stats:{physDmgMin:4, physDmgMax:7}, requirements:{level:8}, description:'Flecha de mejor calidad.', worldModelPath:'models/items/loot_arrow.glb' },
        arrow_plus2: { id: 'arrow_plus2', name: 'Flecha +2', icon:'<img src="icons/arrow_plus2.png">', icon_type:'html', type:'ammo', ammoType:'arrow', rarity:'rare', value:8, stackable:true, maxStack: 150, stats:{physDmgMin:7, physDmgMax:11}, requirements:{level:16}, description:'Flecha excelente.', worldModelPath:'models/items/loot_arrow.glb' },
        arrow_elfic: { id: 'arrow_elfic', name: 'Flecha Élfica', icon:'<img src="icons/arrow_elfic.png">', icon_type:'html', type:'ammo', ammoType:'arrow', rarity:'rare', value:12, stackable:true, maxStack: 100, stats:{physDmgMin:6, physDmgMax:10, hitChance: 5}, requirements:{level:20}, description:'Flecha ligera y precisa.', worldModelPath:'models/items/loot_arrow_elfic.glb'},

        // MISC/CRAFTED
        wooden_spoon: { id: 'wooden_spoon', name: 'Cuchara de Madera', icon: '<img src="icons/spoon.png" alt="Cuchara">', icon_type:'html', type: 'junk', rarity: 'common', value: 1, stackable: false, description: 'Una simple cuchara de madera.', worldModelPath: 'models/items/loot_spoon.glb' },
        stone_bullet: { id: 'stone_bullet', name: 'Bala de Piedra', icon: '<img src="icons/bullet_stone.png" alt="Bala">', icon_type:'html', type: 'ammo', ammoType:'bullet', rarity: 'common', value: 0, stackable: true, maxStack: 100, description: 'Munición improvisada.' },
        common_quiver: { id: 'common_quiver', name: 'Carcaj Común', icon: '<img src="icons/quiver.png" alt="Carcaj">', icon_type:'html', type: 'quiver', slot: 'back', rarity: 'common', value: 50, stackable: false, quiverCapacity: 250, description: 'Protege 250 flechas al morir.', worldModelPath: 'models/items/loot_quiver.glb' },
        plus1_quiver: { id: 'plus1_quiver', name: 'Carcaj +1', icon: '<img src="icons/quiver_plus1.png" alt="Carcaj+1">', icon_type:'html', type: 'quiver', slot: 'back', rarity: 'uncommon', value: 150, stackable: false, quiverCapacity: 500, description: 'Protege 500 flechas al morir.', worldModelPath: 'models/items/loot_quiver.glb' },
        plus2_quiver: { id: 'plus2_quiver', name: 'Carcaj +2', icon: '<img src="icons/quiver_plus2.png" alt="Carcaj+2">', icon_type:'html', type: 'quiver', slot: 'back', rarity: 'rare', value: 300, stackable: false, quiverCapacity: 1000, description: 'Protege 1000 flechas al morir.', worldModelPath: 'models/items/loot_quiver.glb' },
        wagon_wheel: { id: 'wagon_wheel', name: 'Rueda de Carro', icon: '<img src="icons/wheel.png" alt="Rueda">', icon_type:'html', type:'junk', rarity:'common', value: 10, stackable:false, description:'Parte de un carro roto.', worldModelPath: 'models/items/loot_wheel.glb'},

        // Monturas y Vehículos
        mule: { id: 'mule', name: 'Mula', icon: '<img src="icons/mule.png">', icon_type:'html', type: 'mount', rarity:'common', value: 100, stackable: false, description:'Montura básica.', worldModelPath:'models/mounts/mule.glb'},
        brown_horse_armored: { id: 'brown_horse_armored', name: 'Caballo Marrón Acorazado', icon: '<img src="icons/horse_brown_armored.png">', icon_type:'html', type: 'mount', rarity:'uncommon', value: 500, stackable: false, description:'Montura de guerra.', worldModelPath:'models/mounts/horse_brown_armored.glb'},
        white_horse: { id: 'white_horse', name: 'Caballo Blanco', icon: '<img src="icons/horse_white.png">', icon_type:'html', type: 'mount', rarity:'rare', value: 1500, stackable: false, description:'Montura veloz.', worldModelPath:'models/mounts/horse_white.glb'},
        // ... otras monturas ...
        barca: {id:'barca', name:'Barca', icon:'<img src="icons/boat_small.png">', icon_type:'html', type:'vehicle', rarity:'common', value:200, stackable:false, description:'Embarcación pequeña.', worldModelPath:'models/vehicles/boat_small.glb'},
        galera: {id:'galera', name:'Galera', icon:'<img src="icons/boat_large.png">', icon_type:'html', type:'vehicle', rarity:'rare', value:1000, stackable:false, description:'Embarcación grande (Trabajadores).', classRequirement:['worker'], worldModelPath:'models/vehicles/boat_large.glb'},

        // Pergaminos de Hechizo
        // Pergaminos de Hechizo (AÑADIR worldModelPath a CADA UNO)
        spellscroll_magic_arrow: {
            id:'spellscroll_magic_arrow', name:'Pergamino: Flecha Mágica', icon:'<img src="icons/scroll_magic_arrow.png">', icon_type:'html', type:'spellscroll', spellId:'magic_arrow', rarity:'common', value:50, stackable:true, maxStack:10, description: 'Un pergamino polvoriento que enseña el hechizo Flecha Mágica.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('magic_arrow')
        },
        spellscroll_heal_light: {
            id:'spellscroll_heal_light', name:'Pergamino: Curar Leves', icon:'<img src="icons/scroll_heal_light.png">', icon_type:'html', type:'spellscroll', spellId:'heal_light', rarity:'common', value:60, stackable:true, maxStack:10, description: 'Enseña el hechizo básico de curación.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('heal_light')
        },
        spellscroll_strength_buff: {
            id:'spellscroll_strength_buff', name:'Pergamino: Fuerza', icon:'<img src="icons/scroll_strength.png">', icon_type:'html', type:'spellscroll', spellId:'strength_buff', rarity:'common', value:80, stackable:true, maxStack:10, description:'Enseña Fuerza.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            // 'use' function missing in original, assuming it should call learnSpell
            use: (userState, itemInstance) => learnSpell('strength_buff')
        },
        spellscroll_cure_poison: {
            id:'spellscroll_cure_poison', name:'Pergamino: Curar Veneno', icon:'<img src="icons/scroll_cure_poison.png">', icon_type:'html', type:'spellscroll', spellId:'cure_poison', rarity:'uncommon', value:100, stackable:true, maxStack:10, description:'Enseña Curar Veneno.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('cure_poison')
        },
        spellscroll_fireball: {
            id:'spellscroll_fireball', name:'Pergamino: Bola de Fuego', icon:'<img src="icons/scroll_fireball.png">', icon_type:'html', type:'spellscroll', spellId:'fireball', rarity:'uncommon', value:150, stackable:true, maxStack:5, description: 'Desata una esfera de fuego abrasador.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('fireball')
        },
        spellscroll_ice_shard: {
            id:'spellscroll_ice_shard', name:'Pergamino: Esquirla Hielo', icon:'<img src="icons/scroll_ice.png">', icon_type:'html', type:'spellscroll', spellId:'ice_shard', rarity:'uncommon', value:130, stackable:true, maxStack:5, description:'Enseña Esquirla Hielo.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('ice_shard')
        },
         spellscroll_paralyze: {
            id:'spellscroll_paralyze', name:'Pergamino: Paralizar', icon:'<img src="icons/scroll_paralyze.png">', icon_type:'html', type:'spellscroll', spellId:'paralyze', rarity:'rare', value:250, stackable:true, maxStack:3, description:'Enseña Paralizar.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('paralyze')
        },
        spellscroll_immobilize: {
            id:'spellscroll_immobilize', name:'Pergamino: Inmovilizar', icon:'<img src="icons/scroll_immobilize.png">', icon_type:'html', type:'spellscroll', spellId:'immobilize', rarity:'uncommon', value:180, stackable:true, maxStack:5, description:'Enseña Inmovilizar.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('immobilize')
        },
        spellscroll_celerity: {
            id:'spellscroll_celerity', name:'Pergamino: Celeridad', icon:'<img src="icons/scroll_haste.png">', icon_type:'html', type:'spellscroll', spellId:'celerity', rarity:'uncommon', value:160, stackable:true, maxStack:5, description:'Enseña Celeridad.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('celerity')
        },
        spellscroll_remove_paralysis: {
            id:'spellscroll_remove_paralysis', name:'Pergamino: Remover Parálisis', icon:'<img src="icons/scroll_remove_paralysis.png">', icon_type:'html', type:'spellscroll', spellId:'remove_paralysis', rarity:'uncommon', value:140, stackable:true, maxStack:5, description:'Enseña Remover Parálisis.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('remove_paralysis')
        },
        spellscroll_heal_medium: {
            id:'spellscroll_heal_medium', name:'Pergamino: Curar Graves', icon:'<img src="icons/scroll_heal_medium.png">', icon_type:'html', type:'spellscroll', spellId:'heal_medium', rarity:'uncommon', value:200, stackable:true, maxStack:5, description:'Enseña Curar Graves.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('heal_medium')
        },
        spellscroll_stun: {
            id:'spellscroll_stun', name:'Pergamino: Aturdir', icon:'<img src="icons/scroll_stun.png">', icon_type:'html', type:'spellscroll', spellId:'stun', rarity:'rare', value:280, stackable:true, maxStack:3, description:'Enseña Aturdir.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('stun')
        },
        spellscroll_summon_skeleton: {
            id:'spellscroll_summon_skeleton', name:'Pergamino: Invocar Esqueleto', icon:'<img src="icons/scroll_summon_skeleton.png">', icon_type:'html', type:'spellscroll', spellId:'summon_skeleton', rarity:'rare', value:350, stackable:true, maxStack:2, description: 'Aprende a invocar un sirviente esquelético.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('summon_skeleton')
        },
        spellscroll_invisibility: {
            id:'spellscroll_invisibility', name:'Pergamino: Invisibilidad', icon:'<img src="icons/scroll_invis.png">', icon_type:'html', type:'spellscroll', spellId:'invisibility', rarity:'epic', value:600, stackable:true, maxStack:1, description:'Enseña Invisibilidad.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('invisibility')
        },
        spellscroll_resurrect: {
            id:'spellscroll_resurrect', name:'Pergamino: Resucitar', icon:'<img src="icons/scroll_resurrect.png">', icon_type:'html', type:'spellscroll', spellId:'resurrect', rarity:'epic', value:1000, stackable:true, maxStack:1, description:'Enseña Resucitar.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('resurrect')
        },
        spellscroll_summon_elemental: {
            id:'spellscroll_summon_elemental', name:'Pergamino: Invocar Elemental', icon:'<img src="icons/scroll_summon_elemental.png">', icon_type:'html', type:'spellscroll', spellId:'summon_elemental', rarity:'epic', value:800, stackable:true, maxStack:1, description:'Enseña Invocar Elemental.',
            worldModelPath: 'models/items/loot_scroll.glb', // <--- AÑADIDO
            use: (userState, itemInstance) => learnSpell('summon_elemental')
        },
    };

    // --- HECHIZOS ---
    spellDefinitions = {
        // *** ASEGÚRATE QUE targetType y cast ESTÉN DEFINIDOS CORRECTAMENTE ***
        magic_arrow: {
            id: 'magic_arrow', name: 'Flecha Mágica', icon: '🪄',
            type: 'projectile', // The effect type
            targetType: 'enemy', // Can target enemies
            element: 'magic', manaCost: 8, cooldown: 1500, castTime: 300, range: 35,
            damageMin: 8, damageMax: 15,
            requiredSkillLevel: { magic: 1 }, words: 'ZZZ',
            description: 'Lanza un proyectil de energía mágica pura hacia un enemigo.',
            // --- Verify this 'cast' function ---
            cast: (caster, target, spellId) => { // target here should be the enemy Object3D
                if (target instanceof THREE.Vector3) {
                    console.error("Magic Arrow cast called with ground target, expected enemy object.");
                    return; // Don't cast if target is ground
                }
                 if (!target?.position) {
                     console.error("Magic Arrow cast called with invalid target object (no position).");
                     return
                 }
                // Use the target's position (the enemy object) for the projectile destination
                console.log(`Magic Arrow cast: Creating projectile towards ${target.userData?.name}`);
                createProjectile(caster, target.position, spellId || 'magic_arrow');
            }
        },
        electric_arrow: { id: 'electric_arrow', name: 'Flecha Eléctrica', icon: '<img src="icons/spell_electric_arrow.png" alt="Flecha Eléctrica">', type: 'projectile', element: 'electric', manaCost: 10, cooldown: 1800, castTime: 350, damageMin: 10, damageMax: 18, requiredSkillLevel: { magic: 4 }, words: 'ABC', description: 'Un rápido proyectil eléctrico.', cast: (caster, targetPos, id) => createProjectile(caster, targetPos, id || 'electric_arrow') },
        magic_missile: { id: 'magic_missile', name: 'Misil Mágico', icon: '<img src="icons/spell_missile.png" alt="Misil">', type: 'projectile', element: 'magic', manaCost: 12, cooldown: 2000, castTime: 400, damageMin: 12, damageMax: 20, requiredSkillLevel: { magic: 6 }, words: 'DEF', description: 'Proyectil guiado de energía pura.', cast: (caster, targetPos, id) => createProjectile(caster, targetPos, id || 'magic_missile') },
        heal_light: { id: 'heal_light', name: 'Curar Leves', icon: '<img src="icons/spell_heal_light.png" alt="Curar Leve">', type: 'healing', targetType: 'friendly', manaCost: 12, cooldown: 3000, castTime: 600, healAmount: 35, requiredSkillLevel: { magic: 3 }, words: 'GHI', description: 'Restaura una pequeña cantidad de salud.', cast: (caster, target) => { if(target?.userData) applyDamage(target, spellDefinitions.heal_light.healAmount, 'heal'); } },
        cure_poison: { id: 'cure_poison', name: 'Curar Veneno', icon: '<img src="icons/spell_cure_poison.png" alt="Cura Veneno">', type: 'utility', targetType: 'friendly', manaCost: 15, cooldown: 5000, castTime: 500, requiredSkillLevel: { magic: 7 }, words: 'JKL', description: 'Elimina efectos de veneno.', cast: (caster, target) => { const targetData = (target === playerModel ? playerState : target?.userData); return targetData ? removeStatusEffect('poison') : false; } },
        strength_buff: { id: 'strength_buff', name: 'Fuerza', icon: '<img src="icons/spell_strength.png" alt="Fuerza">', type: 'buff', targetType: 'friendly', manaCost: 20, cooldown: 60000, castTime: 700, duration: 60, requiredSkillLevel: { magic: 5 }, words: 'MNO', description: 'Aumenta la Fuerza temporalmente (+3 por 60s).', cast: (caster, target) => addStatusEffectToTarget((target === playerModel ? playerState : target?.userData), {id:'strength_buff', name:'Fuerza Aumentada', icon:'fa-dumbbell', duration:60, statsModifiers:{strength: 3}, class:'status-buff'}) },
        celerity: { id: 'celerity', name: 'Celeridad', icon: '<img src="icons/spell_haste.png" alt="Celeridad">', type: 'buff', targetType: 'friendly', manaCost: 22, cooldown: 75000, castTime: 650, duration: 45, requiredSkillLevel: { magic: 9 }, words: 'PQR', description: 'Aumenta la velocidad de movimiento (45s).', cast: (caster, target) => addStatusEffectToTarget((target === playerModel ? playerState : target?.userData), {id:'haste_buff', name:'Celeridad', icon:'fa-running', duration:45, statsModifiers:{moveSpeedMultiplier: 1.2}, class:'status-buff'}) },
        remove_paralysis: { id: 'remove_paralysis', name: 'Remover Parálisis', icon: '<img src="icons/spell_remove_paralysis.png" alt="Remover Paral">', type: 'utility', targetType: 'friendly', manaCost: 18, cooldown: 8000, castTime: 400, requiredSkillLevel: { magic: 11 }, words: 'STU', description: 'Libera de efectos de parálisis.', cast: (caster, target) => { const targetData = (target === playerModel ? playerState : target?.userData); return targetData ? removeStatusEffect('paralysis') : false; } },

        // --- Intermedios (Banderbill, Arkhein, Lindos, Eldoria) ---
        fireball: { id: 'fireball', name: 'Bola de Fuego', icon: '<img src="icons/spell_fireball.png" alt="Fuego">', type: 'projectile', element: 'fire', manaCost: 15, cooldown: 3000, castTime: 500, damageMin: 15, damageMax: 25, requiredSkillLevel: { magic: 8 }, words: 'VWX', description: 'Lanza una esfera ígnea explosiva.', cast: (caster, targetPos, id) => createProjectile(caster, targetPos, id || 'fireball'), burnChance: 0.2, burnDuration: 4, burnDmg: 3 },
        ice_shard: { id: 'ice_shard', name: 'Esquirla Hielo', icon: '<img src="icons/spell_ice.png" alt="Hielo">', type: 'projectile', element: 'ice', manaCost: 12, cooldown: 2500, castTime: 400, damageMin: 10, damageMax: 18, requiredSkillLevel: { magic: 6 }, words: 'YZA', description: 'Lanza esquirla helada, chance de ralentizar.', cast: (caster, targetPos, id) => createProjectile(caster, targetPos, id || 'ice_shard'), slowChance: 0.3, slowDuration: 3 },
        magic_shield: { id: 'magic_shield', name: 'Escudo Mágico', icon: '<img src="icons/spell_magic_shield.png" alt="Escudo Mag">', icon_type:'html', type: 'buff', targetType: 'self', manaCost: 25, cooldown: 45000, castTime: 800, duration: 30, requiredSkillLevel: { magic: 10 }, words:'MAG_SHIELD', description:'Crea un escudo que aumenta Res. Mágica (30s).', cast:(caster) => addStatusEffect({id:'magic_shield_buff', name:'Escudo Mágico', icon:'fa-shield-alt', duration:30, statsModifiers:{magicResist: 15}, class:'status-shield'}) },
        fire_storm: { id: 'fire_storm', name: 'Tormenta de Fuego', icon: '<img src="icons/spell_firestorm.png" alt="Torm Fuego">', type: 'area_effect', element: 'fire', manaCost: 35, cooldown: 15000, castTime: 1200, radius: 5, duration: 6, tickTime: 1.0, damagePerTick: { amount: 12, type: 'fire' }, requiredSkillLevel: { magic: 15 }, words: 'BCD', description: 'Invoca una tormenta ígnea (5m, 6s).', cast: (caster, targetPos) => createAOE(caster, targetPos, 'fire_storm'), burnChance: 0.15 },
        paralyze: { id: 'paralyze', name: 'Paralizar', icon: '<img src="icons/spell_paralyze.png" alt="Paralizar">', type: 'debuff', targetType: 'enemy', manaCost: 30, cooldown: 20000, castTime: 800, duration: 4, requiredSkillLevel: { magic: 18 }, words: 'EFG', description: 'Inmoviliza completamente al objetivo (4s).', cast: (caster, target) => addStatusEffectToTarget(target?.userData, { id: 'paralysis', name: 'Paralizado', icon: 'fa-ban', duration: 4, onApply:(t)=>{t.aiState='paralyzed'; if(t.mixer)t.mixer.stopAllAction();}, onEnd:(t)=>{if(!t.isDead) t.aiState=t.isAggro?'chasing':'idle';}, class: 'status-stun'}) },
        petrify_npc: { id: 'petrify_npc', name: 'Petrificar NPC', icon: '<img src="icons/spell_petrify.png" alt="Petrificar">', icon_type:'html', type: 'debuff', targetType: 'npc', manaCost: 50, cooldown: 60000, castTime: 1500, duration: 30, requiredSkillLevel: { magic: 22 }, words:'PETRIFY', description:'Convierte un NPC en piedra temporalmente (30s).', cast:(caster, target)=>{ /* Lógica especial para NPCs */ }},
        immobilize: { id: 'immobilize', name: 'Inmovilizar', icon: '<img src="icons/spell_immobilize.png" alt="Inmovilizar">', type: 'debuff', targetType: 'enemy', manaCost: 22, cooldown: 10000, castTime: 600, duration: 6, requiredSkillLevel: { magic: 14 }, words: 'HIJ', description: 'Impide que el objetivo se mueva (6s).', cast: (caster, target) => addStatusEffectToTarget(target?.userData, { id: 'root', name: 'Enraizado', icon: 'fa-link', duration: 6, onApply:(t)=>{t.canMove=false;}, onEnd:(t)=>{t.canMove=true;}, class: 'status-debuff'}) },
        stun: { id: 'stun', name: 'Aturdir', icon: '<img src="icons/spell_stun.png" alt="Aturdir">', type: 'debuff', targetType: 'enemy', manaCost: 28, cooldown: 18000, castTime: 750, duration: 2.5, requiredSkillLevel: { magic: 16 }, words: 'KLM', description: 'Incapacita brevemente al objetivo (2.5s).', cast: (caster, target) => addStatusEffectToTarget(target?.userData, {...STAGGER_EFFECT_DATA, duration: 2.5, name:'Aturdido (Hechizo)'}) },
        summon_skeleton: { id: 'summon_skeleton', name: 'Invocar Esqueleto', icon: '<img src="icons/spell_summon_skeleton.png" alt="Invocar Esq">', type: 'summon', manaCost: 40, cooldown: 45000, castTime: 1500, summonType: 'skeleton', summonCount: 1, summonDuration: 60, requiredSkillLevel: { magic: 20 }, words: 'NOP', description: 'Invoca un esqueleto aliado por 60s.', cast: (caster, targetPos) => summonCreature('skeleton', 1, 60, caster) },
        heal_medium: { id: 'heal_medium', name: 'Curar Heridas Graves', icon: '<img src="icons/spell_heal_medium.png" alt="Curar Grave">', type: 'healing', targetType: 'friendly', manaCost: 28, cooldown: 4000, castTime: 900, healAmount: 80, requiredSkillLevel: { magic: 13 }, words: 'QRS', description: 'Restaura una cantidad moderada de salud.', cast: (caster, target) => { if(target?.userData) applyDamage(target, spellDefinitions.heal_medium.healAmount, 'heal'); } },

        // --- Avanzados (Eleusis, Ciudad Abandonada) ---
        resurrect: { id: 'resurrect', name: 'Resucitar', icon: '<img src="icons/spell_resurrect.png" alt="Resucitar">', type: 'utility', targetType: 'player_ghost', manaCost: 100, cooldown: 300000, castTime: 5000, requiredSkillLevel: { magic: 30 }, words: 'TUV', description: 'Devuelve el espíritu al cuerpo (solo sobre uno mismo).', cast: (caster, target) => { if(target === playerModel && gameState.isGhost) revivePlayer(); else logMessage("Solo puedes resucitarte a ti mismo.", "info"); } },
        invisibility: { id: 'invisibility', name: 'Invisibilidad', icon: '<img src="icons/spell_invis.png" alt="Invis">', type: 'buff', targetType: 'self', manaCost: 35, cooldown: 90000, castTime: 1000, duration: 30, requiredSkillLevel: { magic: 25 }, words: 'WXY', description: 'Te vuelve invisible temporalmente (30s).', cast: (caster) => addStatusEffect({id:'invisibility', name:'Invisible', icon:'fa-eye-slash', duration:30, onApply:(t)=>{t.isInvisible=true; /* Modificar apariencia */}, onEnd:(t)=>{t.isInvisible=false; /* Restaurar apariencia */}, class:'status-buff'}) },
        mimic: { id: 'mimic', name: 'Mimetismo', icon: '<img src="icons/spell_mimic.png" alt="Mimetismo">', icon_type:'html', type:'utility', targetType:'self', manaCost: 40, cooldown: 120000, castTime: 1200, duration: 45, requiredSkillLevel: { magic: 26 }, words:'MIMIC', description:'Permite adoptar la forma de algunas criaturas (45s).', cast:(caster)=>{ /* Lógica de transformación */ }},
        summon_elemental: { id: 'summon_elemental', name: 'Invocar Elemental', icon: '<img src="icons/spell_summon_elemental.png" alt="Invocar Elem">', type: 'summon', manaCost: 60, cooldown: 120000, castTime: 2000, summonType: 'elemental_fire', summonCount: 1, summonDuration: 90, requiredSkillLevel: { magic: 28 }, words: 'ZAB', description: 'Invoca un elemental aliado por 90s.', cast: (caster, targetPos) => summonCreature('elemental_fire', 1, 90, caster) },
        summon_pet: { id: 'summon_pet', name: 'Invocar Mascota', icon: '<img src="icons/spell_summon_pet.png" alt="Invocar Mascota">', icon_type:'html', type: 'summon', manaCost: 50, cooldown: 150000, castTime: 1800, requiredSkillLevel: { taming: 50 }, words:'SUMMON_PET', description:'Invoca a tu mascota domada actual.', cast:(caster)=>{ /* Lógica invocar mascota domada */ }},
        apocalypse: { id: 'apocalypse', name: 'Apocalipsis', icon: '<img src="icons/spell_apocalypse.png" alt="Apocalipsis">', type: 'area_effect', element: 'shadow', manaCost: 80, cooldown: 180000, castTime: 2500, radius: 8, damageMin: 40, damageMax: 60, requiredSkillLevel: { magic: 35 }, words: 'CDE', description: 'Desata energía oscura en un área amplia.', cast: (caster, targetPos) => createAOE(caster, targetPos, 'apocalypse', true)},
    };
    Object.values(spellDefinitions).forEach(def => { if(!def.icon || def.icon.length < 3 || !def.icon.startsWith('<img')) def.icon_type = 'text'; else def.icon_type = 'html'; });

    // --- NPCS --- (Completo)
    npcDefinitions = {
        // Mercaderes Generales
        merchant: { id: 'merchant', name: 'Aldric', title:'<Mercader>', icon: 'fa-store', modelPath: 'models/npcs/merchant_male.glb', buyInterest: ['material', 'weapon', 'armor', 'consumable', 'junk'], shopItems: [ 'health_potion', 'mana_potion', 'empty_flask', 'iron_sword', 'short_bow', 'iron_mace', 'leather_armor', 'leather_pants', 'leather_boots', 'leather_cap', 'pickaxe', 'wood_axe', 'fishing_rod', 'fishing_thread' ], dialogues: { greeting: { text: "¡Saludos! ¿Buscas algo en particular? Mis mercancías son confiables.", options:[{text:"Mostrar mercancías.", action:"openShop"}, {text:"¿Algún rumor?", action:"nextDialog", nextDialog: "rumors"}, {text:"Adiós", action:"close"}] }, rumors: { text: "Dicen que los lobos andan más agresivos al norte. Y cuidado con los caminos poco transitados, los bandidos acechan.", options:[{text:"Gracias.", action:"close"}]} } },
        generic_merchant: { id: 'generic_merchant', name: 'Elara', title:'<Comerciante>', icon: 'fa-cash-register', modelPath: 'models/npcs/merchant_female.glb', buyInterest: ['material', 'consumable', 'junk'], shopItems: [ 'health_potion', 'mana_potion', 'empty_flask', 'bandages', 'coal', 'wood_log' ], dialogues:{greeting:{text:"¿Buscas algo?", options:[{text:"Mostrar mercancías.", action:"openShop"}, {text:"Adiós", action:"close"}]}} },
        general_merchant: { id: 'general_merchant', name: 'Bartholomew', title:'<Mercader General>', icon: 'fa-balance-scale', modelPath: 'models/npcs/merchant_rich.glb', buyInterest: ['material', 'weapon', 'armor', 'consumable', 'junk', 'tool'], shopItems: [ 'health_potion', 'mana_potion', 'antidote_potion', 'potion_energy', 'iron_sword', 'steel_axe', 'short_bow', 'chainmail_vest', 'chainmail_leggings', 'iron_helm', 'iron_shield', 'empty_flask', 'coal', 'iron_ore', 'wood_log', 'pickaxe', 'wood_axe', 'blacksmith_hammer', 'saw', 'fishing_rod' ], dialogues:{greeting:{text:"Calidad garantizada, ciudadano.", options:[{text:"Mostrar mercancías.", action:"openShop"}, {text:"Adiós", action:"close"}]}} },
        rare_goods_merchant: { id: 'rare_goods_merchant', name: 'Zara', title:'<Mercader Exótico>', icon: 'fa-gem', modelPath: 'models/npcs/merchant_exotic.glb', buyInterest: ['material_rare', 'gem', 'artifact'], shopItems: [ 'magic_crystal', 'silver_ingot', 'gold_ingot', 'elfic_wood_log', 'potion_agility', 'potion_strength', 'plus1_quiver' ], dialogues:{greeting:{text:"Solo lo más selecto...", options:[{text:"Mostrar mercancías.", action:"openShop"}, {text:"Adiós", action:"close"}]}} },
        goblin_merchant: { id: 'goblin_merchant', name: 'Griznak', title:'<Chatarrero>', icon: 'fa-recycle', modelPath: 'models/npcs/goblin_trader.glb', buyInterest: ['junk', 'bone', 'rat_tail'], shopItems: [ 'rat_tail', 'bone', 'spider_silk' ], dialogues:{greeting:{text:"¿Basura? ¡Tú basura, mi tesoro!", options:[{text:"Mostrar mercancías.", action:"openShop"}, {text:"Adiós", action:"close"}]}} },

        // Vendedores Especializados
        priest: { id: 'priest', name: 'Padre Elian', title:'<Sacerdote>', icon: 'fa-cross', modelPath: 'models/npcs/priest.glb', dialogues: { greeting: { text: "La luz te guíe, hijo mío. ¿Buscas sanación o redención?", options: [ { text: "(Revivir) Mi espíritu vaga...", action: "revivePlayer", condition: () => gameState.isGhost }, { text: "Curar mis heridas (10 Oro).", action: "customAction", functionName: "healPlayerForGold", condition: () => !gameState.isGhost }, { text: "¿Puedes contarme sobre Eldravar?", action: "nextDialog", nextDialog: "lore" }, { text: "Bendíceme, padre.", action: "close" } ]}, lore: { text: "Este reino conoció la gloria bajo el Rey perdido... Ahora, las sombras se alargan. Debemos mantener la fe.", options: [{ text: "Rezaré.", action: "close" }] }, noGoldHeal: { text: "La caridad es una virtud, pero los ungüentos cuestan 10 monedas de oro.", options: [{ text: "Volveré.", action:"close"}] }, fullHealth: { text: "Ya estás completamente sano. Ve con cuidado.", options: [{ text: "Gracias.", action:"close" }] } } },
        high_priest: { id: 'high_priest', name: 'Sumo Sacerdote Theron', title:'<Sumo Sacerdote>', icon: 'fa-ankh', modelPath: 'models/npcs/priest_high.glb', dialogues: { greeting:{text:"Que la luz ilumine tu camino.", options:[ {text:"(Revivir) Mi espíritu busca regresar.", action:"revivePlayer", condition:()=>gameState.isGhost}, {text:"Bendíceme.", action:"close"} ]}}},
        blacksmith: { id: 'blacksmith', name: 'Borin el Fuerte', title:'<Herrero>', icon: 'fa-hammer', modelPath: 'models/npcs/blacksmith.glb', buyInterest: ['ore', 'ingot', 'weapon_metal', 'armor_metal'], shopItems: ['iron_ingot', 'iron_sword', 'iron_mace', 'iron_shield', 'iron_helm', 'blacksmith_hammer'], dialogues:{greeting:{text:"El acero espera ser moldeado.", options:[{text:"Mostrar mercancías.", action:"openShop"}, {text:"¿Puedes enseñarme algo?", action:"nextDialog", nextDialog:"offer_blacksmith_quest"}, {text:"Adiós", action:"close"}], offer_blacksmith_quest:{text:"La forja requiere práctica. Tráeme 5 Lingotes de Hierro y te mostraré.", options:[{text:"Acepto.", action:"acceptQuest", questId:"blacksmith_basics"},{text:"No ahora.", action:"close"}]}}}},
        master_blacksmith: { id: 'master_blacksmith', name: 'Maestro Herrero Durgon', title:'<Maestro Herrero>', icon: 'fa-fire', modelPath: 'models/npcs/blacksmith_master.glb', buyInterest: ['ore_rare', 'ingot_rare', 'weapon_epic', 'armor_plate'], shopItems: ['gold_ingot', 'steel_plate_armor' ], dialogues:{greeting:{text:"Solo trabajo con los mejores materiales.", options:[{text:"Mostrar mercancías.", action:"openShop"},{text:"Adiós", action:"close"}]}}},
        master_carpenter: { id: 'master_carpenter', name: 'Maestro Ebanista Elmsworth', title:'<Maestro Carpintero>', icon: 'fa-tree', modelPath: 'models/npcs/carpenter_master.glb', buyInterest: ['wood_log', 'wood_rare', 'bow', 'staff'], shopItems: ['elfic_wood_log', 'plank', 'wagon_wheel' ], dialogues:{greeting:{text:"La madera tiene secretos...", options:[{text:"Mostrar mercancías.", action:"openShop"},{text:"Adiós", action:"close"}]}}},
        master_tailor: { id: 'master_tailor', name: 'Maestra Sastre Lyra', title:'<Maestra Sastre>', icon: 'fa-cut', modelPath: 'models/npcs/tailor_master.glb', buyInterest: ['pelt', 'silk', 'cloth', 'armor_light'], shopItems: ['bear_pelt', 'spider_silk', 'plus2_quiver' ], dialogues:{greeting:{text:"Hilos finos para gente fina.", options:[{text:"Mostrar mercancías.", action:"openShop"},{text:"Adiós", action:"close"}]}}},
        fish_vendor: { id: 'fish_vendor', name: 'Viejo Finn', title:'<Pescadero>', icon: 'fa-fish', modelPath: 'models/npcs/fisherman.glb', buyInterest: ['fish'], shopItems: [ ], dialogues:{greeting:{text:"¡Pescado fresco!", options:[{text:"Mostrar mercancías.", action:"openShop"},{text:"Adiós", action:"close"}]}}},
        tool_merchant: { id: 'tool_merchant', name: 'Gruk', title:'<Vendedor Herramientas>', icon: 'fa-tools', modelPath: 'models/npcs/merchant_orc.glb', buyInterest: ['tool'], shopItems: ['pickaxe', 'wood_axe', 'blacksmith_hammer', 'saw', 'coal'], dialogues:{greeting:{text:"Herramientas para trabajo duro.", options:[{text:"Mostrar mercancías.", action:"openShop"},{text:"Adiós", action:"close"}]}}},
        alchemist_vendor: { id: 'alchemist_vendor', name: 'Maestro Fenris', title:'<Alquimista>', icon: 'fa-vial', modelPath: 'models/npcs/alchemist_master.glb', buyInterest: ['herb', 'potion', 'reagent'], shopItems: ['healing_herb', 'mana_herb', 'empty_flask', 'mortar_pestle', 'alchemy_pot', 'potion_agility', 'potion_strength'], dialogues:{greeting:{text:"La esencia de la vida... y la muerte.", options:[{text:"Mostrar mercancías.", action:"openShop"},{text:"Adiós", action:"close"}]}}},

        // Vendedores Hechizos
        spell_vendor_basic_ullathorpe: { id: 'spell_vendor_basic_ullathorpe', name: 'Erudito Lyra', title:'<Vendedora Pergaminos>', icon: 'fa-book', modelPath: 'models/npcs/scholar_female.glb', buyInterest: [], shopItems:[ 'spellscroll_magic_arrow', 'spellscroll_heal_light', 'spellscroll_strength_buff', 'spellscroll_cure_poison' ], dialogues:{greeting:{text:"El conocimiento arcano tiene un precio...", options:[{text:"Ver pergaminos", action:"openShop"},{text:"Adiós",action:"close"}]}} },
        spell_vendor_intermediate_nix: { id: 'spell_vendor_intermediate_nix', name: 'Maestro Soren', title:'<Hechicero>', icon: 'fa-scroll', modelPath: 'models/npcs/mage.glb', buyInterest: [], shopItems:[ 'spellscroll_fireball', 'spellscroll_ice_shard', /*'spellscroll_magic_shield',*/ 'spellscroll_paralyze', 'spellscroll_immobilize' ], dialogues:{greeting:{text:"La magia requiere disciplina... y oro.", options:[{text:"Muéstrame tus hechizos.", action:"openShop"},{text:"Adiós",action:"close"}]}} },
        // Añadir vendedores para Arghal, Forgat, Penthar, Banderbill, Arkhein, Lindos, Eldoria, Eleusis...

        // NPCs de Quest/Lore
        guard_start: { id: 'guard_start', name: 'Guardia Novato', title:'<Guardia>', icon: 'fa-shield-alt', modelPath: 'models/npcs/guard.glb', dialogues: { greeting: { condition: () => !hasQuest('first_steps') && !isQuestCompleted('first_steps'), text: "¡Alto ahí! ¿Nuevo por aquí? Antes de adentrarte, demuestra que puedes manejarte.", options: [{ text: "¿Qué debo hacer?", action: "nextDialog", nextDialog: "offer_first_steps" }] }, offer_first_steps: { text: "Las afueras están infestadas. Mata 5 Hormigas, 7 Murciélagos, 10 Serpientes y 8 Gallos. Vuelve cuando lo hayas hecho. Hay una pequeña recompensa.", options: [{ text: "Acepto (Nvl 1: Primeros Pasos).", action: "acceptQuest", questId: 'first_steps' }, { text: "Quizás luego.", action: "close" }] }, greeting_hasQuest: { condition: () => hasQuest('first_steps') && !canCompleteQuest('first_steps'), text: "¿Cómo va esa limpieza? No te entretengas.", options: [{text:"Estoy en ello.", action:"close"}] }, greeting_canComplete: { condition: () => canCompleteQuest('first_steps'), text: "¿Has terminado con esas plagas?", options: [{ text: "(Completar Misión)", action: "completeQuest", questId: 'first_steps' }, { text: "Un momento.", action: "close" }] }, greeting_completed: { condition: () => isQuestCompleted('first_steps'), text: "Buen trabajo, recluta. Sigue así y quizás sobrevivas.", options: [{text:"Gracias.", action:"close"}] } } },
        hunter_npc: { id: 'hunter_npc', name: 'Borin', title:'<Cazador>', icon: 'fa-paw', modelPath: 'models/npcs/hunter.glb', dialogues: { greeting: { condition: () => !hasQuest('wolfang_hunt') && !isQuestCompleted('wolfang_hunt'), text: "He oído rumores de un lobo enorme, Wolfang lo llaman. Una bestia temible.", options: [{ text: "¿Qué pasa con él?", action: "nextDialog", nextDialog: "offer_wolfang" }] }, offer_wolfang: { text: "Si eres lo bastante valiente -o loco- para cazarlo, tráeme su piel. Te pagaré bien por la prueba.", options: [{ text: "Acepto el desafío (Nvl 3).", action: "acceptQuest", questId: 'wolfang_hunt' }, { text: "Demasiado peligroso por ahora.", action: "close" }] }, greeting_hasQuest: { condition: () => hasQuest('wolfang_hunt') && !canCompleteQuest('wolfang_hunt'), text: "¿Alguna señal de Wolfang? Ten cuidado, muerde fuerte.", options: [{text:"Estoy buscándolo.", action:"close"}] }, greeting_canComplete: { condition: () => canCompleteQuest('wolfang_hunt'), text: "¡Increíble! ¿De verdad lo conseguiste? ¡Esa es la piel!", options: [{ text: "(Entregar Piel)", action: "completeQuest", questId: 'wolfang_hunt'}]}, greeting_completed: { condition: () => isQuestCompleted('wolfang_hunt'), text: "Gracias de nuevo por encargarte de esa bestia. Hacía falta.", options: [{text:"Un placer.", action:"close"}] } } },
        seraphia: { id: 'seraphia', name: 'Seraphia', title: '<Alquimista>', icon: 'fa-flask', modelPath: 'models/npcs/alchemist.glb', classRequirement: ['worker'], dialogues: { greeting: { condition: () => playerState.class === 'worker' && !playerState.knownRecipes.includes('health_potion_craft'), text: "Saludos, joven aprendiz. La alquimia es un arte delicado. Tráeme 3 Hierbas Curativas y te iniciaré.", options: [{ text: "Las buscaré, maestra.", action: "acceptQuest", questId: 'alchemy_intro' }] }, greeting_hasQuest: { condition: () => hasQuest('alchemy_intro') && !canCompleteQuest('alchemy_intro'), text: "¿Ya tienes esas Hierbas?", options:[{text:"Aún no.", action:"close"}] }, greeting_canComplete:{ condition: () => canCompleteQuest('alchemy_intro'), text:"Perfecto. Con esto podemos comenzar tu entrenamiento.", options:[{text:"(Entregar Hierbas)", action:"completeQuest", questId:'alchemy_intro'}]}, greeting_learned:{ condition: () => playerState.class === 'worker' && playerState.knownRecipes.includes('health_potion_craft'), text:"La práctica hace al maestro alquimista. No dejes de experimentar.", options:[{text:"Adiós.", action:"close"}]}, greeting_notWorker: { condition: () => playerState.class !== 'worker', text: "La alquimia requiere una mano firme y conocimiento profundo... busca a los maestros de tu propia senda.", options: [{ text: "Entiendo.", action: "close" }] } } },
        captain_gate: { id: 'captain_gate', name: 'Capitán Valerius', title:'<Capitán Guardia>', icon: 'fa-user-shield', modelPath: 'models/npcs/captain.glb', dialogues: { greeting: { condition: () => !hasQuest('north_gate') && !isQuestCompleted('north_gate'), text: "Ciudadano, los caminos del norte no son seguros. Los bandidos campan a sus anchas.", options: [{ text: "¿Qué se puede hacer?", action: "nextDialog", nextDialog: "offer_north_gate" }] }, offer_north_gate: { text: "Necesitamos valientes que limpien esa ruta. Si eliminas a 20 de esos malnacidos, la guardia te recompensará generosamente.", options: [{ text: "Acepto (Nvl 5: Entrada Norte).", action: "acceptQuest", questId: 'north_gate' }, { text: "Es trabajo para la guardia.", action: "close" }] }, greeting_hasQuest: { condition: () => hasQuest('north_gate') && !canCompleteQuest('north_gate'), text: "¿Algún progreso con los bandidos? Siguen siendo una espina clavada.", options: [{text:"Estoy en ello.", action:"close"}] }, greeting_canComplete: { condition: () => canCompleteQuest('north_gate'), text: "¡Excelente! ¿Has diezmado a esa escoria?", options: [{ text: "(Completar Misión)", action: "completeQuest", questId: 'north_gate' }, { text: "Aún no.", action: "close" }] }, greeting_completed: { condition: () => isQuestCompleted('north_gate'), text: "El camino norte es más seguro gracias a ti. Buen trabajo.", options: [{text:"A mandar.", action:"close"}] } } },
        traveler_npc: { id: 'traveler_npc', name: 'Viajero Asustado', title:'', icon: 'fa-hiking', modelPath: 'models/npcs/traveler.glb', dialogues: { greeting: { condition: () => !hasQuest('penthar_road') && !isQuestCompleted('penthar_road'), text: "¡Ayuda! ¡Los muertos caminan! El camino a Penthar está bloqueado por esqueletos...", options: [{ text: "¿Esqueletos?", action: "nextDialog", nextDialog: "offer_penthar_road" }] }, offer_penthar_road: { text: "¡Decenas de ellos! Si pudieras despejar el camino... eliminar 25 de esas abominaciones... quizás podría continuar mi viaje.", options: [{ text: "Me encargaré (Nvl 5: Camino a Penthar).", action: "acceptQuest", questId: 'penthar_road' }, { text: "Busca otra ruta.", action: "close" }] }, greeting_hasQuest: { condition: () => hasQuest('penthar_road') && !canCompleteQuest('penthar_road'), text: "¡Date prisa! ¡No quiero quedarme aquí!", options: [{text:"Calma, estoy en ello.", action:"close"}] }, greeting_canComplete: { condition: () => canCompleteQuest('penthar_road'), text: "¿Lo hiciste? ¿El camino está libre?", options: [{ text: "(Completar Misión)", action: "completeQuest", questId: 'penthar_road'}]}, greeting_completed: { condition: () => isQuestCompleted('penthar_road'), text: "¡Gracias, gracias! ¡Puedo seguir mi camino!", options: [{text:"Ve con cuidado.", action:"close"}] } } },
        farmer_npc: { id: 'farmer_npc', name: 'Granjero Giles', title:'<Granjero>', icon: 'fa-tractor', modelPath: 'models/npcs/farmer.glb', dialogues: { greeting_hungry: { condition: () => !hasQuest('hungry_orcs') && !isQuestCompleted('hungry_orcs') && !isQuestCompleted('farm_alert'), text: "¡Malditos orcos! ¡Se llevan mis cosechas y mi ganado!", options: [{ text: "¿Qué sucede?", action: "nextDialog", nextDialog: "offer_hungry_orcs" }] }, offer_hungry_orcs: { text: "Esos brutos cazadores orcos... ¡son una plaga! Si acabaras con 25 de ellos, te pagaría lo que pudiera.", options: [{ text: "Consideralo hecho (Nvl 5: Orcos Hambrientos).", action: "acceptQuest", questId: 'hungry_orcs' }, { text: "Lo siento, granjero.", action: "close" }] }, greeting_hungry_has: { condition: () => hasQuest('hungry_orcs') && !canCompleteQuest('hungry_orcs'), text: "¿Has ahuyentado a esos orcos?", options: [{text:"Poco a poco.", action:"close"}] }, greeting_hungry_complete: { condition: () => canCompleteQuest('hungry_orcs'), text: "¡Gracias! ¡Quizás ahora pueda salvar algo de la cosecha!", options: [{ text: "(Completar)", action: "completeQuest", questId: 'hungry_orcs'}]}, greeting_alert: { condition: () => !hasQuest('farm_alert') && !isQuestCompleted('farm_alert') && isQuestCompleted('hungry_orcs'), text: "¡No puede ser! ¡Ahora atacan la granja directamente! ¡Esqueletos, orcos hechiceros...!", options: [{ text: "¡Defenderé tu granja!", action: "acceptQuest", questId: 'farm_alert' }, {text:"Esto es demasiado.", action:"close"}] }, greeting_alert_has: { condition: () => hasQuest('farm_alert') && !canCompleteQuest('farm_alert'), text: "¡Rápido, antes de que destruyan todo!", options:[{text:"Resiste!", action:"close"}] }, greeting_alert_complete: { condition: () => canCompleteQuest('farm_alert'), text: "¡Lo lograste! ¡Has salvado mi granja!", options:[{text:"(Completar)", action:"completeQuest", questId:'farm_alert'}]}, greeting_final: { condition: () => isQuestCompleted('farm_alert'), text:"Espero que ahora tengamos paz.", options:[{text:"Esperemos.", action:"close"}]} } },
        noble_npc: { id: 'noble_npc', name: 'Lord Harrington', title:'<Noble Preocupado>', icon: 'fa-user-tie', modelPath: 'models/npcs/noble.glb', dialogues: { greeting: { condition: () => !hasQuest('damned_assassins') && !isQuestCompleted('damned_assassins'), text: "¡Ciudadano! Estos tiempos son oscuros... una plaga de asesinos se cierne sobre nosotros. Se esconden como ratas y atacan sin piedad.", options: [ { text: "¿Asesinos?", action: "nextDialog", nextDialog: "offer_assassins" }, { text: "Lamentable, pero debo irme.", action: "close" } ] }, offer_assassins: { text: "Sí, una banda despiadada. Han causado mucho dolor. Si tuvieras el coraje de eliminar a 22 de ellos, mi gratitud, y mi bolsa, serían considerables.", options: [ { text: "La justicia prevalecerá (Nvl 6: Malditos Asesinos).", action: "acceptQuest", questId: 'damned_assassins' }, { text: "Ese es un trabajo peligroso.", action: "close" } ] }, greeting_hasQuest: { condition: () => hasQuest('damned_assassins') && !canCompleteQuest('damned_assassins'), text: "¿Has hecho progresos contra esa escoria? Cada uno que elimines es una vida salvada.", options: [{text:"Estoy trabajando en ello.", action:"close"}] }, greeting_canComplete: { condition: () => canCompleteQuest('damned_assassins'), text: "¡Has vuelto! ¿Significa eso que has terminado con esos viles asesinos?", options: [ { text: "(Completar Misión) Han pagado por sus crímenes.", action: "completeQuest", questId: 'damned_assassins' }, { text: "Todavía no.", action: "close" } ] }, greeting_completed: { condition: () => isQuestCompleted('damned_assassins'), text: "Respiro más tranquilo sabiendo que has lidiado con esos asesinos. Gracias de nuevo.", options: [{text:"Fue un honor.", action:"close"}] } } },
        mage_npc: { id: 'mage_npc', name: 'Archimago Eldrin', title:'<Archimago>', icon: 'fa-hat-wizard', modelPath: 'models/npcs/mage_elder.glb', dialogues: { greeting: { condition: () => !hasQuest('magic_horde') && !isQuestCompleted('magic_horde'), text: "Noto una perturbación en el flujo arcano... esos Lord Duendes están jugando con fuerzas que no comprenden. ¡Su magia salvaje es peligrosa!", options: [ { text: "¿Qué se puede hacer al respecto?", action: "nextDialog", nextDialog: "offer_magic_horde" }, { text: "Interesante, pero debo irme.", action: "close" } ] }, offer_magic_horde: { text: "Su número debe ser reducido antes de que causen un cataclismo. Si puedes eliminar a 20 de esos Lord Duendes, contribuirás a restaurar el equilibrio... y te recompensaré.", options: [ { text: "Contribuiré al equilibrio (Nvl 6: Horda Mágica).", action: "acceptQuest", questId: 'magic_horde' }, { text: "No me enfrento a hordas mágicas.", action: "close" } ] }, greeting_hasQuest: { condition: () => hasQuest('magic_horde') && !canCompleteQuest('magic_horde'), text: "Siento la energía caótica disminuir, pero aún queda trabajo. ¡Acaba con esos Lord Duendes!", options: [{text:"Estoy en ello.", action:"close"}] }, greeting_canComplete: { condition: () => canCompleteQuest('magic_horde'), text: "¡Ah, mucho mejor! El flujo arcano se siente más estable. ¿Has eliminado a la horda?", options: [ { text: "(Completar Misión) La amenaza ha sido contenida.", action: "completeQuest", questId: 'magic_horde' }, { text: "Casi.", action: "close" } ] }, greeting_completed: { condition: () => isQuestCompleted('magic_horde'), text: "El equilibrio arcano te agradece tu esfuerzo, joven... mago? Bueno, quienquiera que seas.", options: [{text:"De nada.", action:"close"}] } } },
        innkeeper: { id: 'innkeeper', name: 'Barnaby', title:'<Posadero>', icon: 'fa-bed', modelPath: 'models/npcs/innkeeper.glb', dialogues:{greeting:{text:"Bienvenido a mi humilde posada. ¿Una cama o una bebida?", options:[{text:"Una bebida.", action:"close"},{text:"Adiós.", action:"close"}]}}},
        sailor_npc: { id: 'sailor_npc', name: 'Marinero Finn', title:'<Marinero>', icon: 'fa-anchor', modelPath: 'models/npcs/sailor.glb', dialogues:{greeting:{text:"¡Ah del barco! ¿Necesitas pasaje o historias del mar?", options:[{text:"Historias.", action:"close"},{text:"Adiós.", action:"close"}]}}},
        librarian: { id: 'librarian', name: 'Maestro Alatar', title:'<Bibliotecario>', icon: 'fa-book-open', modelPath: 'models/npcs/scholar_male.glb', dialogues:{greeting:{text:"El silencio es oro, el conocimiento un tesoro.", options:[{text:"Busco un libro.", action:"close"},{text:"Adiós.", action:"close"}]}}},
        mining_guildmaster: { id: 'mining_guildmaster', name: 'Capataz Borin', title:'<Jefe Gremio Minero>', icon: 'fa-gem', modelPath: 'models/npcs/dwarf_miner.glb', dialogues:{greeting:{text:"¿Listo para ensuciarte las manos?", options:[{text:"Sobre las minas...", action:"close"},{text:"Adiós.", action:"close"}]}}},
        king_placeholder: { id: 'king_placeholder', name: 'Rey Theodore III', title:'<Rey de Eldoria>', icon: 'fa-crown', modelPath: 'models/npcs/king.glb', dialogues:{greeting:{text:"El reino perdura.", options:[{text:"Larga vida al Rey.", action:"close"}]}}},
        royal_guard: { id: 'royal_guard', name: 'Guardia Real', title:'<Guardia Real>', icon: 'fa-shield-alt', modelPath: 'models/npcs/guard_royal.glb', dialogues:{greeting:{text:"Por el Rey y el Reino.", options:[{text:"Saludos.", action:"close"}]}}},
        ghost_npc: { id: 'ghost_npc', name: 'Espíritu Atormentado', title:'', icon: 'fa-ghost', modelPath: 'models/npcs/ghost_npc.glb', dialogues:{greeting:{text:"...Ayuda...", options:[{text:"¿Qué ocurre?", action:"close"}]}}},
        necromancer_npc: { id: 'necromancer_npc', name: 'Sectario Oscuro', title:'<Sectario>', icon: 'fa-skull', modelPath: 'models/npcs/necromancer.glb', dialogues:{greeting:{text:"La muerte es solo el principio...", options:[{text:"Apártate.", action:"close"}]}}},
        // Añadir más NPCs...
    };

    // --- HABILIDADES ---
    skillDefinitions = {
        magic: { id: 'magic', name: 'Magia', description: 'Permite lanzar mejores hechizos.', bonuses: [{level: 10, stat:'mpRegen', value:0.1}, {level:25, stat:'magicDmgMin', value:5}, {level: 50, stat:'manaCostReduction', value:0.05}] },
        meditate: { id: 'meditate', name: 'Meditar', description: 'Aumenta la recuperación de maná al meditar.' },
        magic_resistance: { id: 'magic_resistance', name: 'Resistencia Mágica', description: 'Reduce el daño mágico recibido.', bonuses: [{level:20, stat:'magicResist', value:2}, {level:40, stat:'magicResist', value:5},{level:70, stat:'magicResist', value:10}] },
        combat_dexterity: { id: 'combat_dexterity', name: 'Destreza en combate', description: 'Aumenta la probabilidad de evadir ataques físicos.', bonuses: [{level:30, stat:'evasionChance', value:1},{level:60, stat:'evasionChance', value:2},{level:90, stat:'evasionChance', value:3}] },
        unarmed_combat: { id: 'unarmed_combat', name: 'Combate sin armas', description: 'Mejora la efectividad del combate con puños/nudillos.', bonuses:[{level:20, stat:'physDmgMin', value:2, filter:'unarmed'}, {level:50, stat:'critChance', value:1, filter:'unarmed'}] },
        weapon_combat: { id: 'weapon_combat', name: 'Combate con armas', description: 'Mejora la efectividad con armas cuerpo a cuerpo.', bonuses:[{level:15, stat:'hitChance', value:2, filter:'melee'}, {level:40, stat:'physDmgMax', value:5, filter:'melee'}]},
        shield_defense: { id: 'shield_defense', name: 'Defensa con escudo', description: 'Aumenta la efectividad al bloquear con escudo.', bonuses:[{level:25, stat:'blockChance', value:3},{level:55, stat:'blockReduction', value:0.05}]},
        ranged_weapons: { id: 'ranged_weapons', name: 'Armas de distancia', description: 'Mejora la efectividad con arcos y otras armas a distancia.', bonuses:[{level:18, stat:'hitChance', value:3, filter:'ranged'},{level:45, stat:'physDmgMax', value:4, filter:'ranged'}]},
        stab: { id: 'stab', name: 'Apuñalar', description: 'Aumenta daño/crítico con dagas/espadas cortas.', initialAssignReq: { points: 10, classExclude: ['assassin'] }, bonuses:[{level:30, stat:'critChance', value:2, filter:'dagger'}, {level:60, stat:'physDmgMin', value:4, filter:'dagger'}]},
        steal: { id: 'steal', name: 'Robar', description: 'Permite intentar robar oro/objetos (acción criminal).' },
        alchemy: { id: 'alchemy', name: 'Alquimia', description: 'Permite crear pociones.', classRequirement: ['worker'], bonuses:[{level:20, stat:'potionEffectiveness', value:0.1}, {level:50, stat:'potionDuration', value:0.15}]},
        woodcutting: { id: 'woodcutting', name: 'Talar', description: 'Permite talar árboles y obtener más madera.', bonuses:[{level:25, stat:'woodYieldBonus', value:1}, {level:75, stat:'rareWoodFindChance', value: 0.02}]},
        fishing: { id: 'fishing', name: 'Pescar', description: 'Permite pescar peces y obtener más cantidad.', bonuses:[{level:30, stat:'fishYieldBonus', value:1}, {level:80, stat:'rareFishChance', value:0.03}]},
        mining: { id: 'mining', name: 'Minería', description: 'Permite minar vetas y obtener más minerales.', bonuses:[{level:25, stat:'oreYieldBonus', value:1}, {level:75, stat:'rareMineralFindChance', value: 0.02}]},
        carpentry: { id: 'carpentry', name: 'Carpintería', description: 'Permite crear objetos de madera.' },
        blacksmithing: { id: 'blacksmithing', name: 'Herrería', description: 'Permite crear armas, armaduras y herramientas de metal.' },
        hide: { id: 'hide', name: 'Ocultarse', description: 'Permite intentar pasar desapercibido.' },
        survival: { id: 'survival', name: 'Supervivencia', description: 'Permite usar monturas y ver información detallada de criaturas.' },
        trade: { id: 'trade', name: 'Comercio', description: 'Mejora los precios al comprar/vender.', bonuses:[{level:35, stat:'sellPriceBonus', value:0.05}, {level:70, stat:'buyPriceReduction', value:0.05}]},
        leadership: { id: 'leadership', name: 'Liderazgo', description: 'Permite crear party (8pt) o clan (35pt).', requiresAssign: true, assignCost: { party: 8, clan: 35 } },
        taming: { id: 'taming', name: 'Domar animales', description: 'Permite intentar domar animales como mascotas.' },
        navigation: { id: 'navigation', name: 'Navegación', description: 'Permite utilizar embarcaciones (70pt / 35pt Trabajador).', requiresAssign: true, assignCost: { normal: 70, worker: 35 } },
        tailoring: { id: 'tailoring', name: 'Sastrería', description: 'Permite crear armaduras de tela/cuero y otros objetos.' },
    };

    // --- RECETAS ---
    recipeDefinitions = {
        // Carpintería
        spoon_craft: { id: 'spoon_craft', name: 'Cuchara de Madera', result: 'wooden_spoon', count: 1, materials: [{ id: 'wood_log', count: 1 }], skillReq: { skill: 'carpentry', level: 1 }, xpGain: { skill: 'carpentry', amount: 2 }, requiredStation: 'workbench' },
        arrow_common_craft: { id: 'arrow_common_craft', name: 'Flechas Comunes (x10)', result: 'arrow_common', count: 10, materials: [{ id: 'wood_log', count: 1 }, {id:'feather', count: 1}], skillReq: { skill: 'carpentry', level: 5 }, xpGain: { skill: 'carpentry', amount: 5 }, requiredStation: 'workbench' },
        arrow_plus1_craft: { id: 'arrow_plus1_craft', name: 'Flechas +1 (x10)', result: 'arrow_plus1', count: 10, materials: [{ id: 'wood_log', count: 1 }, {id:'iron_ingot', count: 1}, {id:'feather', count: 1}], skillReq: { skill: 'carpentry', level: 15 }, xpGain: { skill: 'carpentry', amount: 10 }, requiredStation: 'workbench' },
        arrow_plus2_craft: { id: 'arrow_plus2_craft', name: 'Flechas +2 (x10)', result: 'arrow_plus2', count: 10, materials: [{ id: 'elfic_wood_log', count: 1 }, {id:'silver_ingot', count: 1}, {id:'harpy_feather', count: 1}], skillReq: { skill: 'carpentry', level: 30 }, xpGain: { skill: 'carpentry', amount: 20 }, requiredStation: 'workbench' },
        arrow_elfic_craft: { id: 'arrow_elfic_craft', name: 'Flechas Élficas (x5)', result: 'arrow_elfic', count: 5, materials: [{ id: 'elfic_wood_log', count: 2 }, {id:'magic_crystal', count: 1}, {id:'harpy_feather', count: 2}], skillReq: { skill: 'carpentry', level: 40 }, xpGain: { skill: 'carpentry', amount: 30 }, requiredStation: 'workbench' },
        common_quiver_craft: { id: 'common_quiver_craft', name: 'Carcaj Común', result: 'common_quiver', count: 1, materials: [{ id: 'wood_log', count: 5 }, {id:'wolf_pelt', count: 2}], skillReq: { skill: 'carpentry', level: 15 }, xpGain: { skill: 'carpentry', amount: 20 }, requiredStation: 'workbench' },
        plus1_quiver_craft: { id: 'plus1_quiver_craft', name: 'Carcaj +1', result: 'plus1_quiver', count: 1, materials: [{ id: 'wood_log', count: 8 }, {id:'bear_pelt', count: 1}], skillReq: { skill: 'carpentry', level: 25 }, xpGain: { skill: 'carpentry', amount: 35 }, requiredStation: 'workbench' },
        plus2_quiver_craft: { id: 'plus2_quiver_craft', name: 'Carcaj +2', result: 'plus2_quiver', count: 1, materials: [{ id: 'elfic_wood_log', count: 4 }, {id:'troll_hide', count: 1}], skillReq: { skill: 'carpentry', level: 45 }, xpGain: { skill: 'carpentry', amount: 60 }, requiredStation: 'workbench' },
        wooden_shield_craft: { id: 'wooden_shield_craft', name: 'Escudo Madera', result: 'wooden_shield', count: 1, materials: [{ id: 'wood_log', count: 4 }], skillReq: { skill: 'carpentry', level: 8 }, xpGain: { skill: 'carpentry', amount: 10 }, requiredStation: 'workbench' },
        oak_shield_craft: { id: 'oak_shield_craft', name: 'Escudo Roble', result: 'oak_shield', count: 1, materials: [{ id: 'wood_log', count: 6 }], skillReq: { skill: 'carpentry', level: 18 }, xpGain: { skill: 'carpentry', amount: 25 }, requiredStation: 'workbench' },
        plank_craft: { id: 'plank_craft', name: 'Tablón (x2)', result: 'plank', count: 2, materials: [{ id: 'wood_log', count: 1 }], skillReq: { skill: 'carpentry', level: 1 }, xpGain: { skill: 'carpentry', amount: 1 }, requiredStation: 'workbench' },
        wagon_wheel_craft: { id: 'wagon_wheel_craft', name: 'Rueda Carro', result: 'wagon_wheel', count: 1, materials: [{ id: 'plank', count: 4 }, {id:'iron_ingot', count: 1}], skillReq: { skill: 'carpentry', level: 20 }, xpGain: { skill: 'carpentry', amount: 30 }, requiredStation: 'workbench' },
        barca_craft: { id: 'barca_craft', name: 'Barca', result: 'barca', count: 1, materials: [{ id: 'plank', count: 20 }, {id:'iron_ingot', count: 5}, {id:'spider_silk', count: 10}], skillReq: { skill: 'carpentry', level: 35 }, xpGain: { skill: 'carpentry', amount: 100 }, requiredStation: 'workbench' },
        galera_craft: { id: 'galera_craft', name: 'Galera', result: 'galera', count: 1, materials: [{ id: 'plank', count: 50 }, {id:'iron_ingot', count: 15}, {id:'spider_silk', count: 25}, {id:'elfic_wood_log', count: 10}], skillReq: { skill: 'carpentry', level: 60 }, xpGain: { skill: 'carpentry', amount: 250 }, requiredStation: 'workbench', classRequirement:['worker'] },
        lute_craft: { id: 'lute_craft', name: 'Laúd', result: 'lute', count: 1, materials: [{ id: 'elfic_wood_log', count: 5 }, {id:'spider_silk', count: 8}], skillReq: { skill: 'carpentry', level: 30 }, xpGain: { skill: 'carpentry', amount: 50 }, requiredStation: 'workbench' },
        flute_craft: { id: 'flute_craft', name: 'Flauta', result: 'flute', count: 1, materials: [{ id: 'wood_log', count: 3 }, {id:'silver_ingot', count: 1}], skillReq: { skill: 'carpentry', level: 28 }, xpGain: { skill: 'carpentry', amount: 45 }, requiredStation: 'workbench' },

        // Herrería
        stone_bullet_craft: { id: 'stone_bullet_craft', name: 'Balas de Piedra (x5)', result: 'stone_bullet', count: 5, materials: [{ id: 'coal', count: 1 }], skillReq: { skill: 'blacksmithing', level: 1 }, xpGain: { skill: 'blacksmithing', amount: 1 }, requiredStation: 'forge'},
        iron_ingot_craft: { id: 'iron_ingot_craft', name: 'Lingote de Hierro', result: 'iron_ingot', count: 1, materials: [{ id: 'iron_ore', count: 2 }, {id:'coal', count:1}], skillReq: { skill: 'blacksmithing', level: 3 }, xpGain: { skill: 'blacksmithing', amount: 3 }, requiredStation: 'forge' },
        silver_ingot_craft: { id: 'silver_ingot_craft', name: 'Lingote de Plata', result: 'silver_ingot', count: 1, materials: [{ id: 'silver_ore', count: 2 }, {id:'coal', count:1}], skillReq: { skill: 'blacksmithing', level: 50 }, xpGain: { skill: 'blacksmithing', amount: 15 }, requiredStation: 'forge' },
        gold_ingot_craft: { id: 'gold_ingot_craft', name: 'Lingote de Oro', result: 'gold_ingot', count: 1, materials: [{ id: 'gold_ore', count: 2 }, {id:'coal', count:1}], skillReq: { skill: 'blacksmithing', level: 100 }, xpGain: { skill: 'blacksmithing', amount: 40 }, requiredStation: 'forge' },
        iron_sword_craft: { id: 'iron_sword_craft', name: 'Espada Hierro', result: 'iron_sword', count: 1, materials: [{ id: 'iron_ingot', count: 3 }], skillReq: { skill: 'blacksmithing', level: 5 }, xpGain: { skill: 'blacksmithing', amount: 15 }, requiredStation: 'forge' },
        iron_dagger_craft: { id: 'iron_dagger_craft', name: 'Daga Hierro', result: 'iron_dagger', count: 1, materials: [{ id: 'iron_ingot', count: 2 }], skillReq: { skill: 'blacksmithing', level: 3 }, xpGain: { skill: 'blacksmithing', amount: 10 }, requiredStation: 'forge' },
        iron_mace_craft: { id: 'iron_mace_craft', name: 'Maza Hierro', result: 'iron_mace', count: 1, materials: [{ id: 'iron_ingot', count: 4 }], skillReq: { skill: 'blacksmithing', level: 7 }, xpGain: { skill: 'blacksmithing', amount: 18 }, requiredStation: 'forge' },
        steel_axe_craft: { id: 'steel_axe_craft', name: 'Hacha Acero', result: 'steel_axe', count: 1, materials: [{ id: 'iron_ingot', count: 5 }, {id:'coal', count: 3}], skillReq: { skill: 'blacksmithing', level: 12 }, xpGain: { skill: 'blacksmithing', amount: 25 }, requiredStation: 'forge' },
        iron_helm_craft: { id: 'iron_helm_craft', name: 'Yelmo Hierro', result: 'iron_helm', count: 1, materials: [{ id: 'iron_ingot', count: 2 }], skillReq: { skill: 'blacksmithing', level: 4 }, xpGain: { skill: 'blacksmithing', amount: 12 }, requiredStation: 'forge' },
        iron_shield_craft: { id: 'iron_shield_craft', name: 'Escudo Hierro', result: 'iron_shield', count: 1, materials: [{ id: 'iron_ingot', count: 4 }], skillReq: { skill: 'blacksmithing', level: 6 }, xpGain: { skill: 'blacksmithing', amount: 16 }, requiredStation: 'forge' },
        chainmail_vest_craft: { id: 'chainmail_vest_craft', name: 'Cota Malla', result: 'chainmail_vest', count: 1, materials: [{ id: 'iron_ingot', count: 6 }], skillReq: { skill: 'blacksmithing', level: 15 }, xpGain: { skill: 'blacksmithing', amount: 30 }, requiredStation: 'forge' },
        chainmail_leggings_craft: { id: 'chainmail_leggings_craft', name: 'Musleras Malla', result: 'chainmail_leggings', count: 1, materials: [{ id: 'iron_ingot', count: 5 }], skillReq: { skill: 'blacksmithing', level: 14 }, xpGain: { skill: 'blacksmithing', amount: 28 }, requiredStation: 'forge' },
        silver_shield_craft: { id: 'silver_shield_craft', name: 'Escudo Plata', result: 'silver_shield', count: 1, materials: [{ id: 'silver_ingot', count: 3 }, {id:'wood_log', count: 1}], skillReq: { skill: 'blacksmithing', level: 25 }, xpGain: { skill: 'blacksmithing', amount: 50 }, requiredStation: 'forge' },
        steel_plate_armor_craft: { id: 'steel_plate_armor_craft', name: 'Armadura Placas Acero', result: 'steel_plate_armor', count: 1, materials: [{ id: 'iron_ingot', count: 10 }, {id:'coal', count:5}], skillReq: { skill: 'blacksmithing', level: 30 }, xpGain: { skill: 'blacksmithing', amount: 70 }, requiredStation: 'forge' },
        ring_magic_resist_craft: { id: 'ring_magic_resist_craft', name: 'Anillo Res. Mágica', result: 'ring_magic_resist', count: 1, materials: [{ id: 'silver_ingot', count: 1 }, {id:'magic_crystal', count: 1}], skillReq: { skill: 'blacksmithing', level: 20 }, xpGain: { skill: 'blacksmithing', amount: 40 }, requiredStation: 'forge' },
        herradura_craft: {id: 'herradura_craft', name:'Herradura', result:'herradura', count:1, materials:[{id:'iron_ingot', count:1}], skillReq:{skill:'blacksmithing', level:10}, xpGain:{skill:'blacksmithing', amount:8}, requiredStation:'forge'},

        // Sastrería
        leather_armor_craft: { id: 'leather_armor_craft', name: 'Armadura Cuero', result: 'leather_armor', count: 1, materials: [{ id: 'wolf_pelt', count: 4 }], skillReq: { skill: 'tailoring', level: 10 }, xpGain: { skill: 'tailoring', amount: 12 }, requiredStation: 'workbench' },
        leather_pants_craft: { id: 'leather_pants_craft', name: 'Pantalones Cuero', result: 'leather_pants', count: 1, materials: [{ id: 'wolf_pelt', count: 3 }], skillReq: { skill: 'tailoring', level: 8 }, xpGain: { skill: 'tailoring', amount: 10 }, requiredStation: 'workbench' },
        leather_boots_craft: { id: 'leather_boots_craft', name: 'Botas Cuero', result: 'leather_boots', count: 1, materials: [{ id: 'wolf_pelt', count: 2 }], skillReq: { skill: 'tailoring', level: 5 }, xpGain: { skill: 'tailoring', amount: 8 }, requiredStation: 'workbench' },
        leather_cap_craft: { id: 'leather_cap_craft', name: 'Gorro Cuero', result: 'leather_cap', count: 1, materials: [{ id: 'rat_tail', count: 3 }, {id:'wolf_pelt', count: 1}], skillReq: { skill: 'tailoring', level: 3 }, xpGain: { skill: 'tailoring', amount: 5 }, requiredStation: 'workbench' },
        hunter_tunic_craft: { id: 'hunter_tunic_craft', name: 'Túnica Cazador', result: 'hunter_tunic', count: 1, materials: [{ id: 'bear_pelt', count: 2 }, {id:'wolf_pelt', count: 3}], skillReq: { skill: 'tailoring', level: 20 }, xpGain: { skill: 'tailoring', amount: 25 }, requiredStation: 'workbench' },
        rogue_vest_craft: { id: 'rogue_vest_craft', name: 'Chaleco Pícaro', result: 'rogue_vest', count: 1, materials: [{ id: 'spider_silk', count: 5 }, {id:'wolf_pelt', count: 2}], skillReq: { skill: 'tailoring', level: 22 }, xpGain: { skill: 'tailoring', amount: 28 }, requiredStation: 'workbench' },
        mage_robe_craft: { id: 'mage_robe_craft', name: 'Túnica Mago', result: 'mage_robe', count: 1, materials: [{ id: 'spider_silk', count: 10 }, {id:'magic_crystal', count: 1}], skillReq: { skill: 'tailoring', level: 18 }, xpGain: { skill: 'tailoring', amount: 35 }, requiredStation: 'loom' },

        // Alquimia (Trabajador)
        health_potion_craft: { id: 'health_potion_craft', name: 'Poción de Salud', result: 'health_potion', count: 1, materials: [{ id: 'healing_herb', count: 2 }, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 1 }, xpGain: { skill: 'alchemy', amount: 5 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot'},
        mana_potion_craft: { id: 'mana_potion_craft', name: 'Poción de Maná', result: 'mana_potion', count: 1, materials: [{ id: 'mana_herb', count: 2 }, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 5 }, xpGain: { skill: 'alchemy', amount: 8 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
        antidote_potion_craft: { id: 'antidote_potion_craft', name: 'Antídoto', result: 'antidote_potion', count: 1, materials: [{ id: 'healing_herb', count: 1 }, {id: 'mana_herb', count: 1}, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 8 }, xpGain: { skill: 'alchemy', amount: 10 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
        potion_energy_craft: { id: 'potion_energy_craft', name: 'Poción Energía', result: 'potion_energy', count: 1, materials: [{ id: 'rat_tail', count: 2 }, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 12 }, xpGain: { skill: 'alchemy', amount: 12 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
        potion_agility_craft: { id: 'potion_agility_craft', name: 'Poción Agilidad', result: 'potion_agility', count: 1, materials: [{ id: 'feather', count: 3 }, {id:'mana_herb', count: 1}, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 15 }, xpGain: { skill: 'alchemy', amount: 15 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
        potion_strength_craft: { id: 'potion_strength_craft', name: 'Poción Fuerza', result: 'potion_strength', count: 1, materials: [{ id: 'orc_tooth', count: 1 }, {id:'healing_herb', count: 1}, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 16 }, xpGain: { skill: 'alchemy', amount: 16 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
        potion_major_heal_craft: { id: 'potion_major_heal_craft', name: 'Poción Curación Mayor', result: 'potion_major_heal', count: 1, materials: [{ id: 'healing_herb', count: 5 }, {id:'magic_crystal', count: 1}, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 25 }, xpGain: { skill: 'alchemy', amount: 25 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
        potion_major_mana_craft: { id: 'potion_major_mana_craft', name: 'Poción Maná Mayor', result: 'potion_major_mana', count: 1, materials: [{ id: 'mana_herb', count: 5 }, {id:'magic_crystal', count: 1}, {id: 'empty_flask', count: 1}], skillReq: { skill: 'alchemy', level: 30 }, xpGain: { skill: 'alchemy', amount: 30 }, classRequirement: ['worker'], requiredStation: 'alchemy_pot' },
    };

    // --- RECURSOS ---
    resourceDefinitions = {
        coal_vein: { id: 'coal_vein', name: 'Veta de Carbón', resourceType: 'ore', baseItemId: 'coal', baseItemMinAmount: 3, baseItemMaxAmount: 7, requiredSkill: 'mining', requiredLevel: 1, requiredToolId: 'pickaxe', baseHarvestTime: 2000, skillXpBase: 4, skillYieldDivisor: 8, respawnTime: 90000, harvestSound: 'harvest_stone', biomes:['hills','mountains', 'dungeon'], spawnChance: 0.04 },
        iron_vein: { id: 'iron_vein', name: 'Veta de Hierro', resourceType: 'ore', baseItemId: 'iron_ore', baseItemMinAmount: 1, baseItemMaxAmount: 3, rareItemId: 'magic_crystal', rareItemChance: 0.03, requiredSkill: 'mining', requiredLevel: 13, requiredToolId: 'pickaxe', baseHarvestTime: 2800, skillXpBase: 10, skillYieldDivisor: 15, respawnTime: 180000, harvestSound: 'harvest_stone', biomes:['hills','mountains','ruin','dungeon'], spawnChance: 0.03 },
        silver_vein: { id: 'silver_vein', name: 'Veta de Plata', resourceType: 'ore', baseItemId: 'silver_ore', baseItemMinAmount: 1, baseItemMaxAmount: 2, rareItemId: 'magic_crystal', rareItemChance: 0.06, requiredSkill: 'mining', requiredLevel: 50, requiredToolId: 'pickaxe', baseHarvestTime: 3500, skillXpBase: 20, skillYieldDivisor: 12, respawnTime: 300000, harvestSound: 'harvest_stone', biomes:['mountains', 'ruin', 'dungeon', 'mountains_deep'], spawnChance: 0.015 },
        gold_vein: { id: 'gold_vein', name: 'Veta de Oro', resourceType: 'ore', baseItemId: 'gold_ore', baseItemMinAmount: 1, baseItemMaxAmount: 1, rareItemId: 'magic_crystal', rareItemChance: 0.1, requiredSkill: 'mining', requiredLevel: 100, requiredToolId: 'gold_pickaxe', baseHarvestTime: 5000, skillXpBase: 50, skillYieldDivisor: 10, respawnTime: 360000, harvestSound: 'harvest_stone', biomes:['dungeon', 'mountains_deep'], spawnChance: 0.005 },
        magic_crystal_node: { id: 'magic_crystal_node', name: 'Nodo Cristal Mágico', resourceType: 'crystal', baseItemId: 'magic_crystal', baseItemMinAmount: 1, baseItemMaxAmount: 1, requiredSkill: 'mining', requiredLevel: 10, requiredToolId: 'pickaxe', baseHarvestTime: 4500, skillXpBase: 25, skillYieldDivisor: 1, respawnTime: 320000, harvestSound: 'harvest_crystal', biomes: ['mountains', 'ruin', 'dungeon', 'mountains_deep'], spawnChance: 0.01 },
        healing_herb_plant: { id: 'healing_herb_plant', name: 'Planta Curativa', resourceType: 'herb', baseItemId: 'healing_herb', baseItemMinAmount: 2, baseItemMaxAmount: 4, rareItemId: 'mana_herb', rareItemChance: 0.10, requiredSkill: 'alchemy', requiredLevel: 1, baseHarvestTime: 1200, skillXpBase: 5, skillYieldDivisor: 20, respawnTime: 60000, harvestSound: 'harvest_plant', biomes: ['forest', 'grassland', 'hills'], spawnChance: 0.04 },
        mana_herb_plant: { id: 'mana_herb_plant', name: 'Hierba de Maná', resourceType: 'herb', baseItemId: 'mana_herb', baseItemMinAmount: 1, baseItemMaxAmount: 3, requiredSkill: 'alchemy', requiredLevel: 3, baseHarvestTime: 1500, skillXpBase: 7, skillYieldDivisor: 18, respawnTime: 120000, harvestSound: 'harvest_plant_magic', biomes: ['forest', 'ruin', 'swamp', 'forest_elfic'], spawnChance: 0.02 },
        wood_tree_common: { id: 'wood_tree_common', name: 'Árbol Común', resourceType: 'wood', baseItemId: 'wood_log', baseItemMinAmount: 2, baseItemMaxAmount: 5, requiredSkill: 'woodcutting', requiredLevel: 13, requiredToolId: 'wood_axe', baseHarvestTime: 2500, skillXpBase: 8, skillYieldDivisor: 12, respawnTime: 120000, harvestSound: 'harvest_wood', biomes: ['forest', 'grassland', 'hills', 'taiga'], successSound: 'tree_fall' },
        elfic_wood_tree: { id: 'elfic_wood_tree', name: 'Árbol Élfico', resourceType: 'wood', baseItemId: 'elfic_wood_log', baseItemMinAmount: 1, baseItemMaxAmount: 3, requiredSkill: 'woodcutting', requiredLevel: 23, requiredToolId: 'elfic_axe', baseHarvestTime: 3800, skillXpBase: 30, skillYieldDivisor: 10, respawnTime: 300000, harvestSound: 'harvest_wood', biomes: ['forest_elfic', 'island_special'], successSound: 'tree_fall' },
    };

    // --- ENEMIGOS ---
    enemyDefinitions = {
        // Nivel Bajo (1-5)
        ant: { id: 'ant', name: 'Hormiga Roja', health: 10, damage: { min: 1, max: 2 }, xp: 2, goldMin: 0, goldMax: 1, modelPath: 'models/enemies/ant.glb', attackCooldown: 1200, scaleMultiplier: 0.5, loot:[], lootChance: 0.1 },
        bat: { id: 'bat', name: 'Murciélago', health: 12, damage: { min: 1, max: 3 }, xp: 3, goldMin: 0, goldMax: 1, modelPath: 'models/enemies/bat.glb', attackCooldown: 1500, scaleMultiplier: 0.6, heightOffset: 1.2, loot:[], lootChance: 0.15 },
        snake: { id: 'snake', name: 'Serpiente', health: 15, damage: { min: 2, max: 4 }, xp: 4, goldMin: 0, goldMax: 2, modelPath: 'models/enemies/snake.glb', attackCooldown: 1800, scaleMultiplier: 0.8, abilities: [{ id: 'poison_attack', chance: 0.15 }], loot:['snake_fang'], lootChance: 0.2 },
        rooster: { id: 'rooster', name: 'Gallo Salvaje', health: 18, damage: { min: 2, max: 4 }, xp: 3, goldMin: 0, goldMax: 1, modelPath: 'models/enemies/bird.glb', attackCooldown: 1400, scaleMultiplier: 0.7, loot:['feather'], lootChance: 0.3 },
        rat: { id: 'rat', name: 'Rata Gigante', health: 20, damage: { min: 2, max: 5 }, xp: 5, goldMin: 1, goldMax: 3, modelPath: 'models/enemies/rat.glb', attackCooldown: 1600, scaleMultiplier: 0.9, loot:['rat_tail'], lootChance: 0.25 },
        wolf: { id: 'wolf', name: 'Lobo Gris', health: 35, damage: { min: 4, max: 7 }, xp: 15, goldMin: 2, goldMax: 8, modelPath: 'models/enemies/wolf.glb', loot: ['wolf_pelt'], lootChance: 0.55, equipmentLoot: ['leather_armor'], equipmentLootChance: 0.02, attackCooldown: 1800, scaleMultiplier: 1.6 },
        goblin: { id: 'goblin', name: 'Duende Merodeador', health: 30, damage: { min: 3, max: 6 }, xp: 12, goldMin: 3, goldMax: 10, modelPath: 'models/enemies/goblin.glb', loot: ['health_potion'], lootChance: 0.60, equipmentLoot: ['iron_dagger', 'short_bow'], equipmentLootChance: 0.08, attackCooldown: 1500, scaleMultiplier: 1.4, abilities: [{ id: 'poison_attack', chance: 0.25 }] },
        wolfang: { id: 'wolfang', name: 'Wolfang', health: 80, damage: { min: 8, max: 15 }, xp: 75, goldMin: 20, goldMax: 50, loot: ['wolfang_pelt_quest'], lootChance: 1.0, isUnique: true, respawnTime: 300000, modelPath: 'models/enemies/wolf_large.glb', scaleMultiplier: 2.2, attackCooldown: 1600 },
        spider: { id: 'spider', name: 'Araña Tejedora', health: 55, damage: { min: 12, max: 20 }, xp: 25, goldMin: 60, goldMax: 75, modelPath: 'models/enemies/spider.glb', attackCooldown: 1600, scaleMultiplier: 1.2, loot:['spider_silk'], lootChance: 0.4, abilities: [{id:'poison_attack', chance: 0.3}]},

        // Nivel Medio-Bajo (6-12)
        bandit: { id: 'bandit', name: 'Bandido', health: 45, damage: { min: 5, max: 9 }, xp: 25, goldMin: 8, goldMax: 20, loot: ['health_potion'], lootChance: 0.6, equipmentLoot: ['iron_sword', 'leather_armor'], equipmentLootChance: 0.1, modelPath: 'models/enemies/bandit.glb', attackCooldown: 1800, scaleMultiplier: 1.8 },
        skeleton: { id: 'skeleton', name: 'Esqueleto Agresor', health: 50, damage: { min: 6, max: 10 }, xp: 28, goldMin: 5, goldMax: 15, modelPath: 'models/enemies/skeleton.glb', loot: ['bone'], lootChance: 0.45, equipmentLoot: ['iron_sword', 'iron_helm'], equipmentLootChance: 0.10, resistances: { physical: 0.25, ice: 0.1 }, attackCooldown: 2000, scaleMultiplier: 1.7 },
        orc_hunter: { id: 'orc_hunter', name: 'Orco Cazador', health: 60, damage: { min: 7, max: 12 }, xp: 35, goldMin: 10, goldMax: 25, loot: ['orc_tooth'], lootChance: 0.5, equipmentLoot: ['steel_axe'], equipmentLootChance: 0.08, modelPath: 'models/enemies/orc.glb', attackCooldown: 2200, scaleMultiplier: 2.0 },
        assassin: { id: 'assassin', name: 'Asesino', health: 55, damage: { min: 8, max: 13 }, xp: 45, goldMin: 15, goldMax: 35, loot: ['mana_potion', 'iron_dagger'], lootChance: 0.7, equipmentLoot: ['rogue_vest'], equipmentLootChance: 0.15, modelPath: 'models/enemies/rogue.glb', attackCooldown: 1400, scaleMultiplier: 1.7, abilities: [{id:'poison_attack', chance: 0.4}]},
        lord_goblin: { id: 'lord_goblin', name: 'Lord Duende', health: 70, damage: { min: 5, max: 8, type:'magic' }, xp: 50, goldMin: 18, goldMax: 40, loot: ['mana_potion'], lootChance: 0.6, equipmentLoot: ['wizard_staff'], equipmentLootChance: 0.1, modelPath: 'models/enemies/goblin_mage.glb', attackCooldown: 2500, scaleMultiplier: 1.6, abilities: [{id:'cast_magic_arrow', chance: 0.5, cooldown: 3000}]},
        orc_bewitched: { id: 'orc_bewitched', name: 'Orco Embrujado', health: 75, damage: { min: 8, max: 14, type:'magic' }, xp: 48, goldMin: 12, goldMax: 30, loot: ['mana_herb'], lootChance: 0.55, modelPath: 'models/enemies/orc_shaman.glb', attackCooldown: 2300, scaleMultiplier: 2.1, abilities: [{id:'cast_curse', chance: 0.3, cooldown: 8000}]},
        orc_farmer: { id: 'orc_farmer', name: 'Orca Granjera', health: 65, damage: { min: 6, max: 10 }, xp: 30, goldMin: 8, goldMax: 18, loot: [], lootChance: 0.4, modelPath: 'models/enemies/orc_female.glb', attackCooldown: 2000, scaleMultiplier: 1.9},
        orc_protector: { id: 'orc_protector', name: 'Orco Protector', health: 90, damage: { min: 10, max: 16 }, xp: 60, goldMin: 20, goldMax: 45, loot: ['orc_tooth'], lootChance: 0.6, equipmentLoot: ['iron_shield', 'iron_mace'], equipmentLootChance: 0.12, modelPath: 'models/enemies/orc_warrior.glb', attackCooldown: 2400, scaleMultiplier: 2.3 },
        bear: { id: 'bear', name: 'Oso Pardo', health: 90, damage: { min: 9, max: 16 }, xp: 55, goldMin: 15, goldMax: 38, modelPath: 'models/enemies/bear.glb', loot: ['health_potion', 'bear_pelt'], lootChance: 0.7, equipmentLoot: ['leather_armor', 'steel_axe'], equipmentLootChance: 0.04, attackCooldown: 2500, scaleMultiplier: 2.0 },
        giant_scorpion: { id: 'giant_scorpion', name: 'Escorpión Gigante', health: 60, damage: { min: 7, max: 11 }, xp: 40, goldMin: 10, goldMax: 28, modelPath: 'models/enemies/scorpion.glb', attackCooldown: 1900, scaleMultiplier: 1.8, abilities: [{id:'poison_attack', chance: 0.3}], loot:['scorpion_stinger'], lootChance: 0.3 },
        zombie: { id: 'zombie', name: 'Zombie', health: 70, damage: { min: 5, max: 8 }, xp: 20, goldMin: 2, goldMax: 10, modelPath: 'models/enemies/zombie.glb', attackCooldown: 2400, scaleMultiplier: 1.9, resistances:{poison: 0.5}, loot:['bandages'], lootChance: 0.2 },
        ghoul: { id: 'ghoul', name: 'Ghoul', health: 85, damage: { min: 7, max: 12 }, xp: 50, goldMin: 12, goldMax: 33, modelPath: 'models/enemies/ghoul.glb', attackCooldown: 1700, scaleMultiplier: 1.8, abilities: [{id:'paralyze_attack', chance: 0.1, duration: 2000}]},

        // Nivel Medio (13-25)
        skeleton_warrior: { id: 'skeleton_warrior', name: 'Guerrero Esqueleto', health: 110, damage: { min: 12, max: 18 }, xp: 80, goldMin: 25, goldMax: 55, modelPath: 'models/enemies/skeleton_warrior.glb', loot: ['iron_ingot'], lootChance: 0.5, equipmentLoot: ['steel_axe', 'chainmail_vest'], equipmentLootChance: 0.12, resistances: { physical: 0.3, ice: 0.2 }, attackCooldown: 2100, scaleMultiplier: 1.8 },
        orc_warrior: { id: 'orc_warrior', name: 'Guerrero Orco', health: 140, damage: { min: 15, max: 22 }, xp: 100, goldMin: 30, goldMax: 65, loot: ['orc_tooth', 'iron_ingot'], lootChance: 0.6, equipmentLoot: ['steel_plate_armor', 'orcish_axe'], equipmentLootChance: 0.1, modelPath: 'models/enemies/orc_warrior.glb', attackCooldown: 2300, scaleMultiplier: 2.4 },
        troll: { id: 'troll', name: 'Troll', health: 200, damage: { min: 18, max: 28 }, xp: 150, goldMin: 40, goldMax: 90, modelPath: 'models/enemies/troll.glb', loot: ['troll_hide'], lootChance: 0.7, stats: { hpRegen: 1.5 }, attackCooldown: 2800, scaleMultiplier: 2.8 },
        cyclops: { id: 'cyclops', name: 'Cíclope', health: 250, damage: { min: 20, max: 32 }, xp: 200, goldMin: 50, goldMax: 110, modelPath: 'models/enemies/cyclops.glb', loot: ['cyclops_eye'], lootChance: 0.6, equipmentLoot: ['giant_club'], equipmentLootChance: 0.08, attackCooldown: 3200, scaleMultiplier: 3.2 },
        harpy: { id: 'harpy', name: 'Arpía', health: 90, damage: { min: 10, max: 16 }, xp: 70, goldMin: 20, goldMax: 48, modelPath: 'models/enemies/harpy.glb', attackCooldown: 1700, scaleMultiplier: 1.6, heightOffset: 1.5, loot:['harpy_feather'], lootChance: 0.4 },
        lizardman: { id: 'lizardman', name: 'Hombre Lagarto', health: 100, damage: { min: 11, max: 17 }, xp: 85, goldMin: 28, goldMax: 60, modelPath: 'models/enemies/lizardman.glb', loot: ['lizard_scale'], lootChance: 0.55, equipmentLoot: ['tribal_spear'], equipmentLootChance: 0.1, attackCooldown: 1900, scaleMultiplier: 1.9 },
        mummy: { id: 'mummy', name: 'Momia', health: 120, damage: { min: 9, max: 15 }, xp: 90, goldMin: 30, goldMax: 70, modelPath: 'models/enemies/mummy.glb', resistances: {fire: -0.3, poison:0.8}, attackCooldown: 2600, scaleMultiplier: 1.8, abilities:[{id:'cast_curse', chance:0.2, cooldown:10000}], loot:['bandages'], lootChance:0.3 },
        golem_stone: { id: 'golem_stone', name: 'Golem de Piedra', health: 300, damage: { min: 15, max: 25 }, xp: 220, goldMin: 60, goldMax: 130, modelPath: 'models/enemies/golem_stone.glb', resistances:{physical: 0.6, magic: 0.2}, attackCooldown: 3500, scaleMultiplier: 2.6, loot:['magic_crystal', 'stone_heart'], lootChance: 0.4 },

        // Nivel Medio-Alto (26-40)
        drake: { id: 'drake', name: 'Draco Menor', health: 280, damage: { min: 22, max: 35, type:'fire' }, xp: 300, goldMin: 80, goldMax: 170, modelPath: 'models/enemies/drake.glb', resistances:{fire: 0.5}, attackCooldown: 2600, scaleMultiplier: 2.5, abilities:[{id:'fire_breath', chance: 0.3, cooldown: 7000}], loot:['drake_scale', 'gold_ingot'], lootChance: 0.6 },
        ogre: { id: 'ogre', name: 'Ogro', health: 350, damage: { min: 25, max: 40 }, xp: 350, goldMin: 100, goldMax: 200, modelPath: 'models/enemies/ogre.glb', attackCooldown: 3000, scaleMultiplier: 3.0, loot:['ogre_club'], lootChance: 0.5, equipmentLoot:['ogre_plate'], equipmentLootChance: 0.05 },
        meduza: { id: 'meduza', name: 'Meduza', health: 320, damage: { min: 20, max: 30 }, xp: 400, goldMin: 110, goldMax: 230, modelPath: 'models/enemies/meduza.glb', heightOffset: 2.5, attackCooldown: 2400, scaleMultiplier: 2.8, abilities:[{id:'poison_attack', chance: 0.3}], loot:['meduza_head', 'silver_ingot'], lootChance: 0.5 },
        elemental_ice: { id: 'elemental_ice', name: 'Elemental de Hielo', health: 200, damage: { min: 18, max: 28, type:'ice' }, xp: 280, goldMin: 70, goldMax: 150, modelPath: 'models/enemies/elemental_ice.glb', resistances:{ice: 1.0, fire: -0.5}, attackCooldown: 2200, scaleMultiplier: 2.2, abilities:[{id:'cast_ice_shard', chance: 0.6, cooldown: 4000}], loot:['magic_crystal', 'ice_core'], lootChance: 0.4 },
        ghost: { id: 'ghost', name: 'Fantasma Aterrador', health: 150, damage: { min: 15, max: 25, type:'magic' }, xp: 180, goldMin: 45, goldMax: 100, modelPath: 'models/enemies/ghost.glb', resistances:{physical:0.7, magic:0.3}, attackCooldown: 1900, scaleMultiplier: 1.8, heightOffset: 1.0, abilities:[{id:'fear_aura', chance: 0.1, radius:5, duration: 3000}]},
        lich: { id: 'lich', name: 'Liche', health: 400, damage: { min: 25, max: 40, type:'magic' }, xp: 600, goldMin: 200, goldMax: 400, modelPath: 'models/enemies/lich.glb', resistances:{ice:0.4, poison:1.0}, attackCooldown: 2800, scaleMultiplier: 2.0, abilities:[{id:'cast_drain_life', chance:0.3, cooldown:10000}, {id:'summon_skeleton', chance:0.2, cooldown:20000, count: 2}], loot:['lich_phylactery_shard', 'gold_ingot', 'spellscroll_paralyze'], lootChance: 0.8 },
        minotaur: { id: 'minotaur', name: 'Minotauro', health: 450, damage: { min: 30, max: 45 }, xp: 550, goldMin: 180, goldMax: 350, modelPath: 'models/enemies/minotaur.glb', attackCooldown: 2500, scaleMultiplier: 3.0, abilities:[{id:'charge', chance: 0.2, cooldown: 8000}], loot:['minotaur_horn', 'steel_axe'], lootChance: 0.6 },

        // Nivel Alto (41+)
        dragon_red: { id: 'dragon_red', name: 'Dragón Rojo Joven', health: 800, damage: { min: 40, max: 60, type:'fire' }, xp: 1000, goldMin: 500, goldMax: 1000, modelPath: 'models/enemies/dragon_red.glb', resistances:{fire:0.9}, attackCooldown: 3000, scaleMultiplier: 4.0, abilities:[{id:'fire_breath_large', chance:0.4, cooldown:10000}, {id:'wing_buffet', chance:0.2, cooldown: 15000, radius:5, knockback:5}], loot:['dragon_scale_red', 'gold_ingot', 'epic_weapon'], lootChance: 0.9, equipmentLootChance: 0.1 },
        golem_iron: { id: 'golem_iron', name: 'Golem de Hierro', health: 600, damage: { min: 35, max: 50 }, xp: 800, goldMin: 300, goldMax: 600, modelPath: 'models/enemies/golem_iron.glb', resistances:{physical: 0.8, magic: -0.2}, attackCooldown: 3800, scaleMultiplier: 3.0, loot:['iron_core', 'gold_ingot'], lootChance: 0.5 },
        beholder: { id: 'beholder', name: 'Contemplador', health: 500, damage: { min: 30, max: 45, type:'magic' }, xp: 900, goldMin: 400, goldMax: 800, modelPath: 'models/enemies/beholder.glb', heightOffset: 2.0, attackCooldown: 1500, scaleMultiplier: 2.5, abilities:[{id:'cast_ray_slow', chance:0.2, cooldown:5000},{id:'cast_ray_disintegrate', chance:0.1, cooldown:12000},{id:'cast_antimagic_field', chance:0.05, cooldown:30000}], loot:['beholder_eye', 'magic_crystal'], lootChance: 0.7 },
        demon: { id: 'demon', name: 'Demonio Mayor', health: 700, damage: { min: 45, max: 65, type:'fire' }, xp: 1200, goldMin: 600, goldMax: 1200, modelPath: 'models/enemies/demon.glb', resistances:{fire:0.6, holy:-0.4}, attackCooldown: 2200, scaleMultiplier: 2.8, abilities:[{id:'summon_imp', chance:0.2, cooldown:15000}, {id:'cast_fireball', chance:0.4, cooldown:4000}], loot:['demon_heart', 'legendary_amulet'], lootChance: 0.6, equipmentLootChance: 0.05 },
        // ... (Añadir más enemigos según tu lista completa)
    };


    questDefinitions = {
        // === Quests Generales / Introductorias (Nivel 1-6) ===
        first_steps: {
            id: 'first_steps', name: 'Primeros Pasos', level: 1, giver: 'guard_start',
            description: 'Demuestra tu valía eliminando algunas de las alimañas que acechan en las afueras.',
            objectives: [
                { type: 'kill', target: 'ant', count: 5, description: "Elimina Hormigas Rojas" },
                { type: 'kill', target: 'bat', count: 7, description: "Elimina Murciélagos" },
                { type: 'kill', target: 'snake', count: 10, description: "Elimina Serpientes" },
                { type: 'kill', target: 'rooster', count: 8, description: "Elimina Gallos Salvajes" }
            ],
            rewards: { xp: 200, gold: 55 },
            completeDialog: 'greeting_completed' // Nodo genérico de completado
        },
        wolfang_hunt: {
            id: 'wolfang_hunt', name: 'El Gran Lobo Feroz', level: 3, giver: 'hunter_npc',
            description: 'Un enorme lobo llamado Wolfang aterroriza la zona. Cázalo y trae su piel como prueba.',
            objectives: [
                { type: 'kill', target: 'wolfang', count: 1, description: "Caza a Wolfang" },
                { type: 'collect', target: 'wolfang_pelt_quest', count: 1, description: "Consigue la Piel de Wolfang" }
            ],
            rewards: { xp: 300, gold: 80, items: ['leather_armor:1'] },
            completeDialog: 'greeting_completed'
        },
        north_gate: {
            id: 'north_gate', name: 'Entrada Norte', level: 5, giver: 'captain_gate',
            description: 'Los bandidos bloquean el camino norte hacia Nix. Elimina suficientes para asegurar la ruta.',
            objectives: [ { type: 'kill', target: 'bandit', count: 20, description: "Elimina Bandidos" } ],
            rewards: { xp: 475, gold: 235, items: ['potion_agility:15', 'potion_strength:15'] },
            completeDialog: 'greeting_completed'
        },
        penthar_road: {
            id: 'penthar_road', name: 'Camino a Penthar', level: 5, giver: 'traveler_npc',
            description: 'Un viajero asustado te pide que despejes el camino a Penthar de una plaga de esqueletos.',
            objectives: [ { type: 'kill', target: 'skeleton', count: 25, description: "Elimina Esqueletos Agresores" } ],
            rewards: { xp: 725, gold: 250, items: ['health_potion:20'] },
            completeDialog: 'greeting_completed'
        },
        hungry_orcs: {
            id: 'hungry_orcs', name: 'Orcos Hambrientos', level: 5, giver: 'farmer_npc',
            description: 'Un granjero local está desesperado porque los Orcos Cazadores están robando sus provisiones.',
            objectives: [ { type: 'kill', target: 'orc_hunter', count: 25, description: "Elimina Orcos Cazadores" } ],
            rewards: { xp: 400, gold: 180, items: ['potion_agility:5', 'potion_strength:5', 'health_potion:10'] },
            completeDialog: 'greeting_hungry_complete' // Nodo específico si existe
        },
        damned_assassins: {
            id: 'damned_assassins', name: 'Malditos Asesinos', level: 6, giver: 'noble_npc',
            description: 'Un noble preocupado te pide ayuda para lidiar con una banda de asesinos que opera en la región.',
            objectives: [ { type: 'kill', target: 'assassin', count: 22, description: "Elimina Asesinos" } ],
            rewards: { xp: 1310, gold: 325, items: ['potion_agility:15', 'potion_strength:15'] },
            completeDialog: 'greeting_completed'
        },
        magic_horde: {
            id: 'magic_horde', name: 'Horda Mágica', level: 6, giver: 'mage_npc',
            description: 'Un archimago te advierte sobre el peligro de los Lord Duendes y su magia caótica. Pide que reduzcas su número.',
            objectives: [ { type: 'kill', target: 'lord_goblin', count: 20, description: "Elimina Lord Duendes" } ],
            rewards: { xp: 1150, gold: 115, items: ['mana_potion:30', 'health_potion:15'] },
            completeDialog: 'greeting_completed'
        },
        farm_alert: {
            id: 'farm_alert', name: 'Granja en Alerta', level: 6, giver: 'farmer_npc',
            description: '¡La granja de Giles está bajo ataque directo de no-muertos y orcos hechiceros!',
            objectives: [
                { type: 'kill', target: 'skeleton', count: 10, description: "Elimina Esqueletos" },
                { type: 'kill', target: 'orc_bewitched', count: 4, description: "Elimina Orcos Embrujados" },
                { type: 'kill', target: 'orc_farmer', count: 4, description: "Elimina Orcas Granjeras" },
                { type: 'kill', target: 'orc_protector', count: 2, description: "Elimina Orcos Protectores" }
            ],
            rewards: { xp: 250, gold: 75, items: ['farmer_gratitude_pie:1'] }, // Item inventado
            completeDialog: 'greeting_alert_complete'
        },

        // === Quests de Profesión (Requieren Trabajador o Skill) ===
        alchemy_intro: {
            id: 'alchemy_intro', name: 'Iniciación a la Alquimia', level: 3, giver: 'seraphia', classRequirement: ['worker'],
            description: 'Seraphia te enseñará los conceptos básicos de la alquimia si le llevas los ingredientes iniciales.',
            objectives: [{ type: 'collect', target: 'healing_herb', count: 3, description: "Recolecta Hierbas Curativas" }],
            rewards: { xp: 50, recipes: ['health_potion_craft', 'mana_potion_craft', 'antidote_potion_craft'], items: ['alchemy_pot:1', 'mortar_pestle:1', 'empty_flask:5'] },
            onCompleteGrantRecipes: true, completeDialog: 'greeting_learned'
        },
        blacksmith_basics: {
            id: 'blacksmith_basics', name: 'Fundamentos de la Forja', level: 5, giver: 'blacksmith', // Borin
            classRequirement: ['worker'],
            description: 'Borin el Fuerte te enseñará a trabajar el metal si le proporcionas material.',
            objectives: [{ type: 'collect', target: 'iron_ingot', count: 5, description: "Consigue Lingotes de Hierro"}],
            rewards: { xp: 100, gold: 20, recipes: ['iron_sword_craft', 'iron_dagger_craft', 'iron_mace_craft', 'iron_helm_craft', 'iron_shield_craft'] },
            onCompleteGrantRecipes: true, completeDialog: 'greeting_blacksmith_learned'
        },
        carpentry_start: {
            id: 'carpentry_start', name: 'El Arte de la Madera', level: 2, giver: 'master_carpenter', // Elmsworth
            classRequirement: ['worker'],
            description: 'El maestro carpintero te pide que le demuestres tu habilidad creando algo simple.',
            objectives: [{ type: 'craft', target: 'wooden_spoon', count: 5, description: "Fabrica Cucharas de Madera" }],
            rewards: { xp: 60, gold: 15, recipes: ['arrow_common_craft', 'plank_craft', 'wooden_shield_craft'] },
            onCompleteGrantRecipes: true, completeDialog: 'greeting_carpenter_learned' // Nodo inventado
        },
        tailoring_intro: {
            id: 'tailoring_intro', name: 'Hilos y Agujas', level: 4, giver: 'master_tailor', // Lyra (Sastre)
            classRequirement: ['worker'],
            description: 'Consigue pieles para que la maestra sastre te enseñe lo básico.',
            objectives: [{ type: 'collect', target: 'wolf_pelt', count: 8, description: "Consigue Pieles de Lobo" }],
            rewards: { xp: 80, gold: 25, recipes: ['leather_boots_craft', 'leather_cap_craft', 'bandages_craft'] }, // Receta vendas?
            onCompleteGrantRecipes: true, completeDialog: 'greeting_tailor_learned' // Nodo inventado
        },
        fishing_test: {
            id: 'fishing_test', name:'Prueba de Pesca', level: 5, giver:'fish_vendor', // Finn
            description: 'El Viejo Finn quiere ver si tienes la paciencia de un pescador.',
            objectives: [{ type: 'fish', target: 'raw_fish_common', count: 15, description: "Pesca 15 peces comunes" }],
            rewards: { xp: 120, gold: 40, items: ['fishing_thread:10'] },
            completeDialog: 'greeting_fishing_learned' // Nodo inventado
        },
        mining_advanced: {
            id: 'mining_advanced', name: 'Minería Avanzada', level: 50, giver: 'mining_guildmaster', // Capataz Borin
            classRequirement: ['worker'], requiresSkill: {mining: 50}, // Requiere skill
            description: 'El gremio necesita plata. Demuestra tu maestría extrayendo este valioso metal.',
            objectives: [{ type: 'collect', target: 'silver_ore', count: 10, description: "Extrae Mena de Plata" }],
            rewards: { xp: 2000, gold: 500, items: ['gold_pickaxe:1'] }, // Recompensa piquete dorado?
            completeDialog: 'greeting_mining_mastered' // Nodo inventado
        },
        // Añadir quests para Herrería Avanzada, Carpintería Élfica, Sastrería Rara, Alquimia Mayor, etc.

        // === Quests de Nivel Medio (Ejemplos 10-25) ===
        clean_the_crypt: {
            id: 'clean_the_crypt', name: 'Limpiando la Cripta', level: 18, giver: 'priest', // Padre Elian
            description: 'La Cripta Ancestral al sureste está infestada de no-muertos. Purifica ese lugar.',
            objectives: [
                { type: 'kill', target: 'skeleton_warrior', count: 10, description:"Guerreros Esqueleto en Cripta"},
                { type: 'kill', target: 'ghoul', count: 8, description:"Ghouls en Cripta"},
                { type: 'kill', target: 'mummy', count: 5, description:"Momias en Cripta"},
                { type: 'interact', target: 'crypt_altar_cleanse', description: "Purifica el Altar Central"} // Necesita objeto altar en dungeon
            ],
            rewards: { xp: 1800, gold: 450, items: ['silver_shield:1', 'holy_water:3'] }, // Necesita item holy_water
            completeDialog: 'greeting_crypt_cleansed'
        },
        orc_invasion_plans: {
             id: 'orc_invasion_plans', name: 'Planes de Invasión Orcos', level: 15, giver: 'captain_gate', // Capitán Nix
             description: 'Se rumorea que los orcos de Arghal planean atacar Nix. Infíltrate, busca los planes y tráelos.',
             objectives: [
                  { type: 'reach', target: 'arghal_tribal_center', description:"Infiltrate en el centro de Arghal"},
                  { type: 'collect', target: 'orc_battle_plans', count: 1, description: "Consigue los Planes de Batalla Orcos"} // Item dropeado por Orc Chief?
             ],
             rewards: { xp: 1500, gold: 400, items: ['steel_plate_armor:1']},
             completeDialog: 'greeting_plans_secured'
        },
        troll_trouble: {
            id: 'troll_trouble', name: 'Problemas con Trolls', level: 20, giver: 'generic_merchant', // Mercader de Arkhein?
            description: 'Un troll enorme está bloqueando la ruta comercial al norte de Arghal. ¡Alguien tiene que detenerlo!',
            objectives: [{ type: 'kill', target: 'troll', count: 1, description: "Derrota al Troll de la ruta"}],
            rewards: { xp: 2500, gold: 600, items: ['troll_hide:1', 'potion_major_heal:3'] },
            completeDialog: 'greeting_troll_defeated'
        },
        lost_relic: {
            id: 'lost_relic', name: 'La Reliquia Perdida', level: 22, giver: 'librarian', // Maestro Alatar en Penthar
            description: 'Un antiguo artefacto fue robado de la biblioteca y llevado a las ruinas del Este. Recupéralo.',
            objectives: [
                { type: 'reach', target: 'wizard_tower_ruin', description:"Explora la Torre del Mago Caído"},
                { type: 'collect', target: 'ancient_relic_quest', count: 1, description: "Recupera la Reliquia Antigua"} // Item en un cofre o enemigo específico en la torre
            ],
            rewards: { xp: 2800, gold: 500, items: ['spellscroll_invisibility:1'] }, // Recompensa hechizo raro?
            completeDialog: 'greeting_relic_returned'
        },

        // === Quests de Nivel Alto (Ejemplos 25+) ===
        eleusis_secrets: {
            id: 'eleusis_secrets', name: 'Los Secretos de Eleusis', level: 30, giver: 'mage_npc', // Archimago Eldrin
            description: 'Las ruinas de Eleusis esconden secretos oscuros y un poder nigromántico creciente. Investiga y detén al Liche.',
            objectives: [
                { type: 'reach', target: 'eleusis_ruins_entrance', description:"Entra en las Ruinas de Eleusis"},
                { type: 'kill', target: 'necromancer_npc', count: 3, description:"Elimina a los Sectarios"}, // Asume NPC enemigo
                { type: 'kill', target: 'lich', count: 1, description:"Derrota al Liche"}
            ],
            rewards: { xp: 5000, gold: 1000, items: ['lich_phylactery_shard:1', 'ring_of_protection_major:1'] }, // Necesita ring
            completeDialog: 'greeting_eleusis_done'
        },
        dragon_threat: {
            id: 'dragon_threat', name: 'La Amenaza del Dragón', level: 40, giver: 'king_placeholder', // Rey Theodore III
            description: 'Un joven pero feroz dragón rojo ha establecido su guarida en las montañas del norte. ¡Debe ser detenido antes de que arrase Eldoria!',
            objectives: [
                { type: 'reach', target: 'dragon_lair_entrance', description:"Encuentra la Guarida del Dragón"},
                { type: 'kill', target: 'dragon_red', count: 1, description:"Derrota al Dragón Rojo"}
            ],
            rewards: { xp: 10000, gold: 2500, items: ['dragon_slayer_sword:1'] }, // Item legendario?
            completeDialog: 'greeting_dragon_slain'
        },
        demon_bane: {
             id: 'demon_bane', name: 'Azote de Demonios', level: 45, giver: 'high_priest', // Sumo Sacerdote Theron
             description: 'Una presencia demoníaca ha sido detectada cerca de las ruinas de Eleusis. Encuéntrala y destrúyela.',
             objectives: [
                  { type: 'kill', target: 'demon', count: 1, description: "Destruye al Demonio Mayor"}
             ],
             rewards: { xp: 8000, gold: 1500, items: ['holy_symbol_blessed:1', 'legendary_amulet:1'] }, // Item bendito?
             completeDialog: 'greeting_demon_banished'
        },

        // === Quests de Facción / Reputación (Ejemplos) ===
        imperial_patrol: {
            id: 'imperial_patrol', name: 'Patrulla Imperial', level: 10, giver: 'guard_captain', // Capitán en ciudad Imperial (Eldoria?)
            faction: 'imperial', // Requiere ser de la facción Imperial
            description: 'Patrulla la ruta comercial hacia el sur y elimina cualquier amenaza.',
            objectives: [
                 { type: 'kill', target: 'bandit', count: 15, zone: 'south_road'}, // Necesita zonas o filtrar por área
                 { type: 'kill', target: 'wolf', count: 10, zone: 'south_road'}
            ],
            rewards: { xp: 500, gold: 100, reputation: { imperial: 50 } }, // Gana reputación
            completeDialog: 'greeting_patrol_complete'
        },
        chaos_raid: {
            id: 'chaos_raid', name: 'Incursión del Caos', level: 12, giver: 'orc_chief', // Jefe Orco en Arghal
            faction: 'chaos', // Requiere ser de la facción Caos (Orcos?)
            description: '¡Demuestra tu valía! Ataca una caravana mercante cerca de Nix.',
            objectives: [
                 { type: 'kill', target: 'merchant_guard_npc', count: 5, zone: 'nix_road'}, // Necesita NPC guardia mercante y zona
                 { type: 'collect', target: 'stolen_goods_quest', count: 3, description:"Roba mercancías"} // Necesita item
            ],
            rewards: { xp: 600, gold: 150, reputation: { chaos: 75 } },
            completeDialog: 'greeting_raid_success'
        }
    };


// --- MAZMORRAS ---
    dungeonDefinitions = {
        // Cueva Goblin Simple (Nivel 5-10)
        "goblin_cave_1": {
            id: "goblin_cave_1",
            name: "Cueva Goblin Apestosa",
            // --- Layout y Estética ---
            layout: {
                type: 'box',
                size: [55, 7, 65], // Tamaño ajustado
                wallColor: 0x6b4f34, floorColor: 0x7d5f40, // Marrones tierra
                pillars: [ {x:-10, z:5}, {x:10, z:15}, {x:0, z:30} ] // Pocos pilares
            },
            bgColor: 0x1f1a10, fogNear: 6, fogFar: 25, // Niebla marrón/oscura
            music: 'music_dungeon_cave',
            // --- Contenido ---
            startPos: { x: 0, y: 0, z: -30 }, // Entrada al sur
            startRotY: 0, // Mirando al norte
            exitPosOffset: { x: 0, z: -1.5 }, // Salida justo detrás del start
            enemies: [
                { type: 'rat', count: 8 }, // Ratas primero
                { type: 'goblin', count: 15, pos: { x: 0, y:0, z: 10 }, radius: 20 }, // Goblins en área central/norte
                { type: 'spider', count: 6, pos: { x: -20, y:0, z: 20 }, radius: 15 }, // Arañas en una esquina
                { type: 'lord_goblin', count: 1, pos: { x: 0, y: 0, z: 28 }, isBoss: true } // Jefe al fondo
            ],
            interactables: [
                { type: 'chest', pos: { x: 20, y: 0, z: 20 }, level: 8 },
                { type: 'chest', pos: { x: -20, y: 0, z: 20 }, level: 8 },
                { type: 'resource', defId: 'coal_vein', pos: {x: 0, y: 0, z: 0}}
            ]
            // exitPos no necesita definirse aquí, se calcula desde startPos y offset
        },
        // Cripta No-Muertos (Nivel 15-20)
        "ancient_crypt_1": {
            id: "ancient_crypt_1", name: "Cripta Ancestral Nv.1",
            layout: {
                type: 'box', size: [75, 6, 105], // Ligeramente más grande
                wallColor: 0x5a5a6a, floorColor: 0x6b6b7b, // Piedra gris
                pillars: [
                    {x:-20, z:10}, {x:20, z:10}, {x:-20, z:40}, {x:20, z:40},
                    {x:-20, z:70}, {x:20, z:70}, {x:0, z:90} // Pilar central al fondo
                ]
            },
            bgColor: 0x1a1a20, fogNear: 4, fogFar: 22, // Niebla más cerrada, azulada/gris
            music: 'music_dungeon_crypt',
            startPos: { x: 0, y: 0, z: -50 }, // Entrada
            startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 }, // Salida
            enemies: [
                { type: 'skeleton', count: 15, radius: 40 }, // Esqueletos por todo el lugar
                { type: 'zombie', count: 10, pos: {x: 0, y:0, z: 20}, radius: 25 }, // Zombies más al centro/fondo
                { type: 'ghoul', count: 6, pos: {x: 0, y:0, z: 50}, radius: 20 }, // Ghouls en la parte trasera
                { type: 'mummy', count: 3, pos: { x: 0, y: 0, z: 85 } } // Momias cerca del fondo
            ],
            interactables: [
                { type: 'chest', pos: { x: 30, y: 0, z: 80 }, level: 18 },
                { type: 'chest', pos: { x: -30, y: 0, z: 80 }, level: 18, locked: true, lockLevel: 15 }, // Cofre cerrado
                { type: 'resource', defId: 'silver_vein', pos: { x: 0, y: 0, z: 95 } }, // Recurso al fondo
                { type: 'altar', defId: 'crypt_altar_cleanse', pos: { x: 0, y: 0, z: 40 }, name: "Altar Profanado" } // Altar para quest
            ]
        },
         // Minas Perdición Nv.1 (Nivel 10-15)
        "perdition_mines_1": {
            id: "perdition_mines_1", name: "Minas Perdición Nv.1",
            layout: {
                type: 'box', size: [80, 8, 100],
                wallColor: 0x3c3c42, floorColor: 0x4a4a52, // Tonos roca oscura
                pillars:[{x:10,z:10},{x:-15,z:5}, {x:20, z:-20}, {x:-25, z: 30},{x:0,z:50},{x:30,z:70},{x:-30,z:80},{x:5, z:90}]
            },
            bgColor: 0x100f0f, fogNear: 5, fogFar: 22, music: 'music_dungeon_cave',
            startPos: { x: 0, y: 0, z: -48 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type: 'bat', count: 10}, {type:'rat', count: 8},
                {type:'skeleton', count: 15, radius: 40},
                {type:'spider', count: 7, pos:{x:-20, y:0, z:60}, radius: 15},
                {type:'goblin', count: 6, pos:{x:20, y:0, z:70}, radius: 15}
            ],
            interactables: [
                {type: 'resource', defId:'coal_vein', pos:{x: -35, y:0, z: 15}},
                {type: 'resource', defId:'coal_vein', pos:{x: 25, y:0, z: 60}},
                {type: 'resource', defId:'iron_vein', pos:{x:-30,y:0,z:20}},
                {type: 'resource', defId:'iron_vein', pos:{x: 15, y:0, z: 80}},
                {type: 'chest', pos:{x:35,y:0,z:45}, level: 10},
                {type: 'chest', pos:{x:-20,y:0,z:85}, level: 12}
            ]
        },
        // Minas Perdición Nv.2 (Nivel 18-25)
        "perdition_mines_2": {
            id: "perdition_mines_2", name: "Minas Perdición Nv.2",
            layout: {
                type: 'box', size: [90, 7, 110],
                wallColor: 0x35353a, floorColor: 0x404045, // Más oscuro
                pillars:[{x:-30,z:-40},{x:30,z:-40},{x:0,z:0},{x:-40,z:40},{x:40,z:40}]
            },
            bgColor: 0x0c0b0b, fogNear: 4, fogFar: 20, music: 'music_dungeon_cave_deep',
            startPos: { x: 0, y: 0, z: -53 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type:'skeleton', count: 10, pos:{x:0, y:0, z:-20}, radius:25},
                {type:'goblin', count: 12, pos:{x:-20, y:0, z:20}, radius:20},
                {type:'spider', count: 5, pos:{x:20, y:0, z:20}, radius:15},
                {type:'skeleton_warrior', count: 6, pos:{x:0, y:0, z:60}, radius:25},
                {type:'lizardman', count: 4, pos:{x:0, y:0, z:90}} // Al fondo
            ],
            interactables: [
                {type: 'resource', defId:'iron_vein', pos:{x:-35, y:0, z:-20}},
                {type: 'resource', defId:'iron_vein', pos:{x:35, y:0, z:50}},
                {type: 'resource', defId:'silver_vein', pos:{x:0, y:0, z:80}}, // Plata
                {type: 'chest', pos:{x:40,y:0,z:95}, level: 20, locked: true, lockLevel: 10} // Cofre cerrado
            ]
        },
        // Cripta Ancestral Nv.2 (Nivel 25-32)
        "ancient_crypt_2": {
            id: "ancient_crypt_2", name: "Cripta Ancestral Nv.2",
            layout: {
                type: 'box', size: [80, 6, 120],
                wallColor: 0x505060, floorColor: 0x606070, // Piedra aún más oscura
                pillars: [{x:0, z: -40}, {x:0, z:0}, {x:0, z:40}, {x:0, z:80}] // Pilares centrales
            },
            bgColor: 0x15151a, fogNear: 3, fogFar: 18, music: 'music_dungeon_crypt_deep',
            startPos: { x: 0, y: 0, z: -58 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type:'ghoul', count: 12, radius: 45},
                {type:'mummy', count: 8, pos:{x:0, y:0, z:50}, radius: 25},
                {type:'skeleton_warrior', count: 10, pos:{x:0, y:0, z:80}, radius: 20},
                {type:'ghost', count: 5, pos:{x:0, y:0, z:100}} // Fantasmas al final
            ],
            interactables: [
                {type: 'chest', pos:{x:30,y:0,z:105}, level: 28, locked: true, lockLevel: 20},
                {type: 'chest', pos:{x:-30,y:0,z:105}, level: 28},
                {type:'resource', defId:'silver_vein', pos:{x:-35,y:0,z:90}},
                {type:'resource', defId:'magic_crystal_node', pos:{x:35, y:0, z:90}}
            ]
        },
        // Guarida del Dragón (Nivel 40+)
        "dragon_lair_1": {
            id: "dragon_lair_1", name: "Guarida del Dragón",
            layout: {
                type: 'box', size: [120, 20, 150], // Mucho más grande y alto
                wallColor: 0x442222, floorColor: 0x553333, // Roca volcánica/quemada
                // Sin pilares? O muy grandes y pocos
            },
            bgColor: 0x201010, fogNear: 15, fogFar: 70, fogColor: 0x441111, // Niebla roja/caliente
            music: 'music_dungeon_boss',
            startPos: { x: 0, y: 1, z: -70 }, startRotY: 0, // Entra desde el sur
            exitPosOffset: { x: 0, z: -2.5 }, // Salida más atrás
            enemies: [
                {type: 'drake', count: 4, pos:{x:0, y:1, z:-20}, radius: 40}, // Dracos patrullando
                {type:'golem_stone', count: 2, pos:{x:-40, y:1, z:30}, radius: 15}, // Golems guardianes
                {type:'golem_stone', count: 2, pos:{x:40, y:1, z:30}, radius: 15},
                {type:'dragon_red', count: 1, pos: {x: 0, y: 2, z: 60}, isBoss: true} // El Dragón JEFE al fondo
            ],
            interactables: [
                {type: 'chest', pos:{x:0, y:1, z:68}, level: 45, locked: true, lockLevel: 30}, // Cofre del tesoro
                {type:'resource', defId:'gold_vein', pos:{x:50, y:0, z:50}}, // Vetas de oro
                {type:'resource', defId:'gold_vein', pos:{x:-50, y:0, z:50}},
                {type:'resource', defId:'magic_crystal_node', pos:{x:0, y:0, z:0}} // Cristal cerca de la entrada?
            ]
        },
        // Caverna de Entrenamiento Orca (Nivel 12-18)
        "orc_training_cave_1": {
            id: "orc_training_cave_1", name: "Caverna Entrenamiento Orca",
            layout: {
                type: 'box', size: [65, 9, 80],
                wallColor: 0x5d4a3c, floorColor: 0x6f5a4c, // Tierra/roca
                pillars:[{x:0, z:0}, {x:20, z:20}, {x:-20, z:20}, {x:0, z:40}, {x:20, z:60}, {x:-20, z:60}]
            },
            bgColor: 0x1f1a15, fogNear: 7, fogFar: 30, music: 'music_dungeon_cave',
            startPos: { x: 0, y: 0, z: -38 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type: 'orc_hunter', count: 8, radius: 30},
                {type: 'orc_warrior', count: 5, pos:{x:0, y:0, z:20}, radius: 20},
                {type: 'orc_protector', count: 3, pos:{x:0, y:0, z:50}}, // Protectores al fondo
                {type: 'troll', count: 1, pos:{x:0, y:0, z:35}, isBoss: false} // Mini-jefe troll
            ],
            interactables: [
                {type: 'chest', pos:{x:25, y:0, z:65}, level: 15}, // Cofre al fondo
                {type: 'resource', defId:'iron_vein', pos:{x:-25,y:0,z:55}},
                {type: 'training_dummy', pos:{x:-15,y:0,z:-10}}, // Maniquíes
                {type: 'training_dummy', pos:{x:15,y:0,z:-10}},
                {type: 'weapon_rack', pos:{x:0,y:0,z:-15}}      // Rack armas
            ]
        },
        // Alcantarillas Olvidadas (Nivel 20-30)
        "abandoned_city_sewers_1": {
            id: "abandoned_city_sewers_1", name: "Alcantarillas Olvidadas",
            layout: {
                type: 'box', size: [110, 5, 130], // Anchas y largas, pero bajas
                wallColor: 0x445544, floorColor: 0x556655, // Verde/Gris húmedo
                // Sin pilares, quizás añadir tuberías como objetos?
            },
            bgColor: 0x101810, fogNear: 5, fogFar: 18, // Niebla verdosa muy densa
            music: 'music_dungeon_sewer',
            startPos: { x: 0, y: 0, z: -63 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type: 'rat', count: 20, radius: 50},
                {type: 'giant_scorpion', count: 8, pos:{x:0, y:0, z:20}, radius: 30},
                {type:'lizardman', count: 6, pos:{x:0, y:0, z:70}, radius: 25}, // Lagartos en zonas más profundas
                {type:'ghoul', count: 4, pos:{x:0, y:0, z:100}} // Ghouls al final?
            ],
            interactables: [
                {type: 'chest', pos:{x:45, y:0, z:110}, level: 28},
                {type:'resource', defId:'silver_vein', pos:{x:-45,y:0,z:100}},
                // Podrías añadir objetos 'junk_pile_prop' aquí
            ]
        },
        // Ruinas de Eleusis (Nivel 30-40)
        "eleusis_ruins_1": {
            id: "eleusis_ruins_1", name: "Ruinas de Eleusis",
            layout: {
                type: 'box', size: [100, 12, 100],
                wallColor: 0x686878, floorColor: 0x787888, // Gris piedra antigua
                pillars: [{x:-30, z:-30}, {x:30, z:-30}, {x:-30, z:30}, {x:30, z:30}] // Pilares grandes
            },
            bgColor: 0x2a2a35, fogNear: 8, fogFar: 35, // Niebla grisácea
            music: 'music_dungeon_ruins',
            startPos: { x: 0, y: 1, z: -48 }, startRotY: 0, // Y=1 para empezar sobre posible escombro
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type:'mummy', count: 12, radius: 40},
                {type:'ghost', count: 8, pos:{x:0, y:1, z:0}, radius: 30},
                {type:'skeleton_warrior', count: 10, pos:{x:0, y:1, z:20}, radius: 25},
                {type:'necromancer_npc', count: 3, pos:{x:-20, y:1, z:35}, radius: 10}, // NPC enemigo
                {type:'lich', count: 1, pos:{x:0, y:1, z:45}, isBoss: true} // JEFE
            ],
            interactables: [
                {type: 'chest', pos:{x:40, y:0, z:40}, level: 35},
                {type: 'chest', pos:{x:-40, y:0, z:40}, level: 35, locked: true, lockLevel: 28},
                {type:'resource', defId:'magic_crystal_node', pos:{x:0, y:0, z:0}},
                {type: 'altar', defId: 'eleusis_dark_altar', pos: {x: 0, y: 1, z: 42}, name: "Altar Oscuro"}
            ]
        },
        // Criptas de Eleusis (Nivel 32-42) - Ejemplo continuación
        "eleusis_crypts_1": {
            id: "eleusis_crypts_1", name: "Criptas de Eleusis",
            layout: {
                type: 'box', size: [90, 7, 110],
                wallColor: 0x4f4f5f, floorColor: 0x5f5f6f, // Más oscuro que ruinas
                pillars: [] // Sin pilares, más laberíntico? O añadir sarcófagos
            },
            bgColor: 0x181820, fogNear: 5, fogFar: 20, music: 'music_dungeon_crypt_deep',
            startPos: { x: 0, y: 0, z: -53 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type:'ghoul', count: 15, radius: 45},
                {type:'ghost', count: 10, pos:{x:0, y:0, z:50}, radius: 30},
                {type:'mummy', count: 8, pos:{x:0, y:0, z:80}},
                {type:'skeleton_warrior', count: 5, pos:{x:0, y:0, z:100}}, // Menos guerreros, más ghouls/fantasmas
                // Podría haber un mini-boss aquí o un puzzle
            ],
            interactables: [
                {type: 'chest', pos:{x:0,y:0,z:105}, level: 38, locked: true, lockLevel: 30},
                {type: 'sarcophagus_prop', pos:{x:30,y:0,z:60}}, // Prop Sarcófago
                {type: 'sarcophagus_prop', pos:{x:-30,y:0,z:60}}
            ]
        },
         // Mina de Veril (Nivel 28-38) - Ejemplo con Oro
        "veril_mine_1": {
            id: "veril_mine_1", name: "Mina de Veril",
            layout: {
                type: 'box', size: [100, 10, 130],
                wallColor: 0x404040, floorColor: 0x505050, // Gris oscuro mina
                pillars: [{x:0,z:0},{x:40,z:40},{x:-40,z:40},{x:40,z:100},{x:-40,z:100}]
            },
            bgColor: 0x151005, fogNear: 7, fogFar: 28, music: 'music_dungeon_cave_deep',
            startPos: { x: 0, y: 0, z: -63 }, startRotY: 0,
            exitPosOffset: { x: 0, z: -1.5 },
            enemies: [
                {type: 'skeleton_warrior', count: 10, radius: 50},
                {type:'golem_stone', count: 3, pos:{x:0,y:0,z:50}, radius: 30}, // Más Golems
                {type:'lizardman', count: 8, pos:{x:-30, y:0, z:80}, radius: 20},
                {type:'giant_scorpion', count: 6, pos:{x:30, y:0, z:80}, radius: 20}
            ],
            interactables: [
                {type: 'resource', defId:'gold_vein', pos:{x:0, y:0, z:115}}, // Vetas de ORO
                {type: 'resource', defId:'gold_vein', pos:{x:45, y:0, z:60}},
                {type: 'resource', defId:'gold_vein', pos:{x:-45, y:0, z:60}},
                {type:'resource', defId:'silver_vein', pos:{x:0, y:0, z:20}},
                {type:'resource', defId:'silver_vein', pos:{x:30, y:0, z:80}},
                {type:'resource', defId:'silver_vein', pos:{x:-30, y:0, z:80}},
                {type: 'chest', pos:{x:0,y:0,z:120}, level: 35, locked: true, lockLevel: 25} // Cofre final
            ]
        },

    };

    // ============================================================
    // === DEFINICIÓN INDEPENDIENTE PARA CIUDADES (COMPLETA v3) ===
    // ============================================================
    // Colocar esta definición ANTES de la línea `worldData = { ... }`
    const citiesDefinition = [
        // --- 1. Ullathorpe (Ciudad Inicial Detallada) ---
        {
            id: "ullathorpe", name: "Ullathorpe", isSafeZone: true,
            center: { x: -50, z: -80 }, radius: 80, terrainHeight: 1.0, // Terreno base, ligeramente aplanado
            districts: [
                {
                    type: 'market', name: "Plaza del Mercado",
                    buildings: [
                        { id: 'market_stalls', pos: {x: -40, z: -75}, rotY: 0.5 }, // Puestos de mercado
                        { id: 'market_stalls', pos: {x: -45, z: -70}, rotY: -0.2 },
                        { id: 'market_stalls', pos: {x: -38, z: -71}, rotY: 0.1 },
                        { id: 'market_stalls', pos: {x: -48, z: -78}, rotY: 0.9 },
                        { id: 'fountain', pos: {x: -42, z: -72} }, // Fuente central
                        { id: 'barrels_stack', pos: {x: -35, z: -78} }, // Props decorativos
                        { id: 'crates_stack', pos: {x: -50, z: -73} }
                    ],
                    npcs: [
                        { type: 'merchant', pos: {x: -41, z: -76}, rotY: Math.PI } // Aldric, mercader principal
                    ]
                },
                {
                    type: 'residential_low', name: "Barrio Humilde",
                    buildings: [ // Casas pequeñas y juntas
                        { id: 'house_small', pos: {x: -70, z: -90}, rotY: 0 },
                        { id: 'house_small', pos: {x: -75, z: -95}, rotY: 0.1 },
                        { id: 'house_small', pos: {x: -65, z: -85}, rotY: -0.1 },
                        { id: 'house_small', pos: {x: -68, z: -98}, rotY: 0.2 },
                        { id: 'house_small', pos: {x: -60, z: -92}, rotY: 0.3 },
                        { id: 'house_small', pos: {x: -78, z: -88}, rotY: -0.3 },
                        { id: 'wood_pile_prop', pos: {x: -63, z: -95} } // Prop de leña
                    ],
                    npcs: [
                        { type: 'hunter_npc', pos: {x: -72, z: -92}, rotY: 1.5 } // Borin el cazador
                    ]
                },
                {
                    type: 'temple', name: "Templo de la Luz",
                    buildings: [
                        { id: 'temple', pos: {x: -45, z: -120}, rotY: 0 } // Templo modesto
                    ],
                    npcs: [
                        { type: 'priest', pos: {x: -45, z: -118}, rotY: 0 } // Padre Elian
                    ]
                },
                 {
                     type: 'crafting', name: "Zona de Artesanos",
                     buildings: [
                          { id: 'blacksmith', pos: {x: -80, z: -65}, rotY: 0 }, // Edificio herrería
                          { id: 'anvil', pos: {x: -79, z: -63} }, // Objeto Yunque
                          { id: 'workbench', pos: {x: -83, z: -68}, rotY: -0.5 }, // Mesa de trabajo
                          { id: 'house_small', pos: {x: -78, z: -70}, rotY: 0.1 }, // Casa del herrero/alquimista
                          { id: 'alchemy_pot', pos: {x: -82, z: -63}, scale: 0.8 } // Olla como objeto
                     ],
                     npcs: [
                          { type: 'seraphia', pos: {x: -81, z: -66}, rotY: 2.0 }, // Alquimista
                          { type: 'blacksmith', pos: {x: -79, z: -64}, rotY: -0.5 } // Herrero Borin
                     ]
                 },
                 {
                     type: 'inn', name: "Posada El Descanso",
                     buildings: [
                         { id: 'inn', pos: {x: -60, z: -50}, rotY: 0.2 } // Edificio Posada
                     ],
                     npcs: [
                         { type: 'innkeeper', pos: {x: -60, z: -48}, rotY: 0 } // Posadero Barnaby
                     ]
                 },
                {
                    type: 'gate_guard_south', name: "Puerta Sur",
                    buildings: [ // Torres y posible sección de muro simple
                        { id: 'guard_tower_small', pos: {x: -55, z: -132}, rotY: 0 },
                        { id: 'guard_tower_small', pos: {x: -25, z: -132}, rotY: 0 },
                        // Placeholder para muralla/puerta si se añade modelo
                        // { id: 'palisade_wall', pos: {x: -40, z: -130}, rotY: 0 },
                        // { id: 'palisade_gate', pos: {x: -40, z: -130}, rotY: 0 }
                    ],
                    npcs: [
                        { type: 'guard_start', pos: {x: -40, z: -128}, rotY: 0 } // Guardia Novato (quest)
                    ]
                },
            ]
        },
        // --- 2. Nix (Ciudad Portuaria Detallada) ---
        {
            id: "nix", name: "Nix", isSafeZone: true,
            center: { x: 200, z: 150 }, radius: 90, // Radio un poco mayor
            terrainHeight: 1.5, // Cerca del nivel del mar
            districts: [
                {
                    type: 'docks', name: "Muelles de Nix",
                    buildings: [
                        { id: 'dock_section', pos: {x: 230, z: 135}, rotY: 0 }, // Secciones de muelle
                        { id: 'dock_section', pos: {x: 238, z: 138}, rotY: 0 },
                        { id: 'dock_section', pos: {x: 246, z: 141}, rotY: 0 },
                        { id: 'dock_section', pos: {x: 254, z: 144}, rotY: 0 },
                        { id: 'warehouse_small', pos: {x: 225, z: 130}, rotY: -0.1 }, // Almacén pequeño
                        { id: 'warehouse', pos: {x: 215, z: 132}, rotY: 0 }, // Almacén grande
                        { id: 'crane_simple', pos: {x: 240, z: 145}, rotY: 0.8 }, // Grúa
                        { id: 'fishing_net_prop', pos: {x: 232, z: 138} }, // Redes
                        { id: 'rowboat_prop', pos: {x: 228, z: 142} }, // Bote
                        { id: 'barrels_stack', pos: {x: 220, z: 135} } // Barriles
                    ],
                    npcs: [
                        { type: 'fish_vendor', pos: {x: 233, z: 140}, rotY: 0.5 }, // Vendedor pescado
                        { type: 'sailor_npc', pos: {x: 248, z: 143}, rotY: -0.5 }, // Marinero
                        { type: 'harbor_master', pos: {x: 220, z: 131}, rotY: 0.2 } // Capitán puerto
                    ]
                },
                {
                    type: 'market', name: "Mercado Portuario",
                    buildings: [
                        { id: 'market_stalls', pos: {x: 215, z: 165}, rotY: -1.57 }, // Puestos mirando al oeste
                        { id: 'market_stalls', pos: {x: 210, z: 168}, rotY: -1.57 },
                        { id: 'market_stalls', pos: {x: 220, z: 162}, rotY: -1.57 },
                        { id: 'crates_stack', pos: {x: 218, z: 168} } // Cajas
                    ],
                    npcs: [
                        { type: 'generic_merchant', pos: {x: 213, z: 166}, rotY: 1.57 } // Mercader genérico
                    ]
                },
                {
                    type: 'residential', name: "Distrito Residencial",
                    buildings: [ // Casas variadas
                        { id: 'house_medium', pos: {x: 190, z: 180}, rotY: 0 },
                        { id: 'house_medium', pos: {x: 200, z: 185}, rotY: 0.2 },
                        { id: 'house_large', pos: {x: 185, z: 195}, rotY: -0.1 },
                        { id: 'house_small', pos: {x: 205, z: 175}, rotY: 0.5 },
                        { id: 'house_medium', pos: {x: 175, z: 188}, rotY: 0.1 },
                        { id: 'planter_box_prop', pos: {x: 192, z: 182} }, // Jardinera
                        { id: 'bench', pos: {x: 188, z: 198} } // Banco
                    ],
                    npcs: [
                        { type: 'noble_npc', pos: {x: 187, z: 196}, rotY: Math.PI } // Noble
                    ]
                },
                {
                    type: 'guard_post_north', name: "Puerta Norte",
                    buildings: [
                        { id: 'guard_tower_small', pos: {x: 180, z: 130}, rotY: 0 },
                        { id: 'guard_tower_small', pos: {x: 200, z: 130}, rotY: 0 },
                        { id: 'barracks_small', pos: {x: 190, z: 125}, rotY: 0 }, // Pequeño cuartel
                        { id: 'city_wall_section', pos: {x: 190, z: 130}, rotY: 0 }, // Sección de muro
                        { id: 'city_gate_simple', pos: {x: 190, z: 130}, rotY: 0 } // Puerta simple (modelo inventado)
                    ],
                    npcs: [
                        { type: 'captain_gate', pos: {x: 190, z: 132}, rotY: Math.PI }, // Capitán (quest bandidos)
                        { type: 'city_guard', pos: {x: 182, z: 128}, rotY: 0.5 }, // Guardia
                        { type: 'city_guard', pos: {x: 198, z: 128}, rotY: -0.5 } // Guardia
                    ]
                },
                {
                    type: 'mage_guild', name: "Torre Arcana",
                    buildings: [
                        { id: 'mage_tower_modest', pos: {x: 170, z: 160}, rotY: 0 }, // Torre mago
                        { id: 'glowing_crystal_prop', pos: {x: 172, z: 165} }, // Cristal decorativo
                        { id: 'bookshelf_prop', pos: {x: 168, z: 162} } // Estantería
                    ],
                    npcs: [
                        { type: 'mage_npc', pos: {x: 170, z: 158}, rotY: 0 }, // Archimago Eldrin (quest)
                        { type: 'spell_vendor_intermediate_nix', pos: {x: 171, z: 161}, rotY: Math.PI } // Vendedor hechizos
                    ]
                }
            ]
        },
        // --- 3. Arghal (Campamento Orco Detallado) ---
        {
            id: "arghal", name: "Arghal", isSafeZone: false, // NO ES SEGURO
            center: { x: -300, z: 250 }, radius: 75, terrainHeight: 5.0, // Terreno elevado/irregular
            districts: [
                 { type: 'tribal_center', name: "Plaza Central", buildings: [{id:'orc_hut_large', pos:{x:-300, z:250}}, {id:'bonfire', pos:{x:-300, z:258}}, {id:'totem_pole_large', pos:{x:-292, z:252}}, {id:'orc_banner', pos:{x:-308, z:252}}, {id:'skull_pile_prop', pos:{x:-295, z:245}}], npcs:[{type:'orc_chief', pos:{x:-300, z:248}}] },
                 { type: 'warrior_camp', name: "Zona Guerrera", buildings: [{id:'orc_tent', pos:{x:-280, z:270}}, {id:'orc_tent', pos:{x:-275, z:275}}, {id:'orc_tent', pos:{x:-285, z:278}}, {id:'training_dummy', pos:{x:-285, z:265}}, {id:'weapon_rack', pos:{x:-278, z:268}}, {id:'weapon_rack', pos:{x:-282, z:272}}], npcs:[{type:'orc_warrior_trainer', pos:{x:-280, z:272}}] },
                 { type: 'shaman_area', name: "Rincón del Chamán", buildings: [{id:'orc_hut_small', pos:{x:-320, z:240}}, {id:'orc_hut_small', pos:{x:-325, z:245}}, {id:'totem_pole_small', pos:{x:-318, z:242}}, {id:'cauldron_prop', pos:{x:-323, z:242}}], npcs:[{type:'orc_shaman', pos:{x:-322, z:241}}] }, // Necesita cauldron_prop
                 { type: 'goblin_slums', name: "Barrio Goblin", buildings: [{id:'goblin_shack', pos:{x:-310, z:285}}, {id:'goblin_shack', pos:{x:-315, z:288}}, {id:'goblin_shack', pos:{x:-308, z:290}}, {id:'junk_pile_prop', pos:{x:-312, z:292}}, {id:'crude_fence', pos:{x:-318, z:285}, rotY:0.5}], npcs:[{type:'goblin_merchant', pos:{x:-312, z:287}}]} // Necesita crude_fence
            ]
        },
        // --- 4. Penthar (Ciudad Erudita Detallada) ---
        {
            id: "penthar", name: "Penthar", isSafeZone: true,
            center: { x: 400, z: -100 }, radius: 70, // Radio moderado
            terrainHeight: 3.0, // Terreno estable
            districts: [
                 { type:'main_square', name:"Plaza Mayor", buildings:[ {id:'fountain', pos:{x:400, z:-100}}, {id:'bench', pos:{x:403, z:-102}}, {id:'bench', pos:{x:397, z:-102}}, {id:'marketStalls', pos:{x:405, z:-95}}, {id:'statue_scholar', pos:{x:395, z:-105}} ], npcs:[ {type:'traveler_npc', pos:{x:398, z:-101}, rotY:1}, {type:'city_guard', pos:{x:402, z:-95}, rotY:-1} ]},
                 { type:'library', name:"Gran Biblioteca", buildings:[ {id:'library', pos:{x:380, z:-115}, rotY:0}, {id:'bookshelf_prop', pos:{x:382, z:-117}}, {id:'bookshelf_prop', pos:{x:378, z:-117}}, {id:'bookshelf_prop', pos:{x:375, z:-113}}, {id:'reading_desk_prop', pos:{x:385, z:-112}} ], npcs:[ {type:'librarian', pos:{x:380, z:-113}}, {type:'quest_giver_scholar', pos:{x:382, z:-118}} ]}, // Necesita reading_desk_prop
                 { type:'shops', name:"Calles Comerciales", buildings:[ {id:'shop_generic', pos:{x:420, z:-110}, rotY:0.1}, {id:'shop_generic', pos:{x:423, z:-115}, rotY:-0.2}, {id:'shop_generic', pos:{x:417, z:-118}, rotY:0} ], npcs:[ {type:'generic_merchant', pos:{x:421, z:-108}, rotY:2.0} ]},
                 { type:'residential', name:"Distrito Residencial", buildings:[ {id:'house_medium', pos:{x:400, z:-75}, rotY:Math.PI}, {id:'house_medium', pos:{x:395, z:-80}, rotY:Math.PI+0.2}, {id:'house_medium', pos:{x:405, z:-82}, rotY:Math.PI-0.1}, {id:'house_large', pos:{x:385, z:-90}, rotY:Math.PI} ], npcs:[] },
                 { type:'alchemist_shop', name:"Laboratorio Alquímico", buildings:[ {id:'alchemist_lab', pos:{x:415, z:-125}, rotY:0}, {id:'alchemy_table_prop', pos:{x:416, z:-124}}, {id:'shelf_potion_prop', pos:{x:414, z:-127}} ], npcs:[ {type:'alchemist_vendor', pos:{x:415, z:-123}, rotY:0} ]}, // Necesita shelf_potion_prop
                 { type: 'gate_guard_east', name: "Puerta Este", buildings: [ {id:'guard_tower_small', pos:{x:440, z:-90}}, {id:'guard_tower_small', pos:{x:440, z:-110}}, {id:'city_wall_section', pos:{x:440, z:-100}} ], npcs: [ {type:'city_guard', pos:{x:438, z:-100}} ]}
            ]
        },
        // --- 5. Forgat (Ciudad Minera Detallada) ---
        {
            id: "forgat", name: "Forgat", isSafeZone: true,
            center: { x: -150, z: -300 }, radius: 65, // Radio moderado
            terrainHeight: 8.0, // Elevada, en montañas
            districts: [
                 { type:'forge_center', name:"Corazón de la Forja", buildings:[ {id:'blacksmith', pos:{x:-150, z:-300}}, {id:'blacksmith', pos:{x:-155, z:-305}}, {id:'anvil', pos:{x:-148, z:-298}}, {id:'anvil', pos:{x:-157, z:-303}}, {id:'cooling_trough_prop', pos:{x:-147, z:-302}}, {id:'grindstone_prop', pos:{x:-152, z:-308}} ], npcs:[ {type:'blacksmith', pos:{x:-150, z:-297}}, {type:'tool_merchant', pos:{x:-156, z:-304}} ] }, // Necesita grindstone_prop
                 { type:'mining_guild', name:"Gremio Minero", buildings:[ {id:'guild_hall_small', pos:{x:-165, z:-290}}, {id:'mining_cart_prop', pos:{x:-167, z:-292}}, {id:'ore_pile_prop', pos:{x:-163, z:-293}} ], npcs:[ {type:'mining_guildmaster', pos:{x:-165, z:-288}} ] }, // Necesita ore_pile_prop
                 { type:'worker_housing', name:"Barracones Mineros", buildings:[ {id:'house_small', pos:{x:-140, z:-315}, rotY:-0.1}, {id:'house_small', pos:{x:-143, z:-318}, rotY:0.2}, {id:'house_small', pos:{x:-137, z:-312}, rotY:0}, {id:'house_small', pos:{x:-145, z:-322}, rotY:-0.3}, {id:'wood_pile_prop', pos:{x:-139, z:-310}} ], npcs:[] },
                 { type:'tavern', name:"Taberna 'La Piqueta Oxidada'", buildings:[ {id:'inn', pos:{x:-160, z:-315}, rotY:Math.PI}, {id:'barrels_stack', pos:{x:-162, z:-313}} ], npcs:[ {type:'innkeeper', pos:{x:-160, z:-313}, rotY:Math.PI} ] },
                 { type: 'gate_guard_west', name: "Entrada Oeste", buildings: [ {id:'guard_tower_small', pos:{x:-175, z:-305}}, {id:'guard_tower_small', pos:{x:-175, z:-295}} ], npcs: [ {type:'city_guard', pos:{x:-173, z:-300}} ]}
            ]
        },
        // --- 6. Banderbill (Puerto Pesquero Detallado) ---
        {
            id: "banderbill", name: "Banderbill", isSafeZone: true,
            center: { x: -400, z: 50 }, radius: 70, // Radio moderado
            terrainHeight: 0.5, // Muy cerca del nivel del mar
            districts:[
                 { type:'port', name:"Puerto Principal", buildings:[ {id:'dock_section', pos:{x:-420, z:40}}, {id:'dock_section', pos:{x:-425, z:45}}, {id:'dock_section', pos:{x:-418, z:50}}, {id:'warehouse_small', pos:{x:-415, z:35}, rotY:0.2}, {id:'warehouse_small', pos:{x:-408, z:38}, rotY:0.1}, {id:'crane_simple', pos:{x:-428, z:42}}, {id:'rowboat_prop', pos:{x:-422, z:52}}, {id:'fishing_boat_prop', pos:{x:-430, z:48}} ], npcs:[ {type:'sailor_npc', pos:{x:-422, z:42}}, {type:'harbor_master', pos:{x:-416, z:38}} ] }, // Necesita fishing_boat_prop
                 { type:'market_fish', name:"Mercado de Pescado", buildings:[ {id:'market_stalls', pos:{x:-400, z:65}}, {id:'market_stalls', pos:{x:-405, z:68}}, {id:'fish_barrel', pos:{x:-402, z:63}}, {id:'fish_net_prop', pos:{x:-398, z:68}}, {id:'fish_crate_prop', pos:{x:-408, z:66}} ], npcs:[ {type:'fish_vendor', pos:{x:-403, z:66}} ] }, // Necesita fish_crate_prop
                 { type:'residential_fishing', name:"Casas de Pescadores", buildings:[ {id:'house_small', pos:{x:-380, z:70}, rotY:-0.1}, {id:'house_small', pos:{x:-385, z:75}, rotY:0.1}, {id:'house_small', pos:{x:-375, z:65}, rotY:0.2}, {id:'house_small', pos:{x:-390, z:78}, rotY:-0.3} ], npcs:[] },
                 { type:'tavern', name:"La Ancla Oxidada", buildings:[ {id:'inn', pos:{x:-390, z:40}, rotY:0.3} ], npcs:[ {type:'innkeeper', pos:{x:-390, z:42}} ] },
                 { type: 'gate_guard_land', name: "Entrada Terrestre", buildings: [ {id:'guard_tower_small', pos:{x:-380, z:30}}, {id:'guard_tower_small', pos:{x:-360, z:30}} ], npcs: [ {type:'city_guard', pos:{x:-370, z:32}} ]}
            ]
        },
        // --- 7. Arkhein (Ciudad Académica/Militar Detallada) ---
        {
            id: "arkhein", name: "Arkhein", isSafeZone: true,
            center: { x: 100, z: 350 }, radius: 80, // Radio bueno
            terrainHeight: 4.0, // Algo elevada
            districts:[
                 { type:'academy', name:"Academia Arcana", buildings:[ {id:'academy_building', pos:{x:90, z:340}}, {id:'library_small', pos:{x:85, z:355}, rotY:0.2}, {id:'observatory_dome_prop', pos:{x:95, z:335}}, {id:'mage_tower_modest', pos:{x:75, z:345}} ], npcs:[ {type:'mage_trainer', pos:{x:90, z:338}}, {type:'quest_giver_academic', pos:{x:88, z:353}}, {type:'spell_vendor_intermediate_arkhein', pos:{x:78, z:343}} ]}, // Vendedor hechizos
                 { type:'barracks', name:"Cuartel de la Guardia", buildings:[ {id:'barracks', pos:{x:120, z:360}}, {id:'training_dummy', pos:{x:125, z:362}}, {id:'training_dummy', pos:{x:128, z:364}}, {id:'armory_small', pos:{x:118, z:365}}, {id:'guard_tower_small', pos:{x:130, z:355}} ], npcs:[ {type:'guard_captain', pos:{x:120, z:358}}, {type:'city_guard', pos:{x:123, z:363}}, {type:'city_guard', pos:{x:117, z:357}} ]},
                 { type:'shops_upper', name:"Distrito Comercial", buildings:[ {id:'shop_generic', pos:{x:110, z:330}}, {id:'shop_generic', pos:{x:115, z:335}}, {id:'shop_potion', pos:{x:105, z:335}}, {id:'shop_books', pos:{x:112, z:342}} ], npcs:[ {type:'generic_merchant', pos:{x:112, z:331}}, {type:'alchemist_vendor', pos:{x:106, z:334}} ]}, // Necesita shop_books
                 { type:'residential_mid', name:"Zona Residencial", buildings:[ {id:'house_medium', pos:{x:80, z:370}, rotY:0.3}, {id:'house_medium', pos:{x:85, z:375}, rotY:-0.1}, {id:'house_medium', pos:{x:95, z:372}, rotY:0}, {id:'house_large', pos:{x:105, z:375}, rotY:0.1} ], npcs:[] },
                 { type:'gate_south', name:"Puerta Sur", buildings:[ {id:'guard_tower_small', pos:{x:90, z:385}}, {id:'guard_tower_small', pos:{x:110, z:385}} ], npcs:[ {type:'city_guard', pos:{x:100, z:383}} ]}
            ]
        },
        // --- 8. Eleusis (Ruinas Peligrosas - Sin cambios, ya detallada) ---
        {
            id: "eleusis", name: "Eleusis", isSafeZone: false, center: { x: -500, z: -600 }, radius: 80, terrainHeight: 12.0, districts: [ { type:'ruined_temple', name:"Templo Arruinado", buildings:[ {id:'ruined_temple_large', pos:{x:-500, z:-600}}, {id:'broken_pillar', pos:{x:-495, z:-595}}, {id:'rubble', pos:{x:-505, z:-605}}, {id:'broken_statue', pos:{x:-500, z:-598}} ], npcs:[ ] }, { type:'undead_area', name:"Cementerio", buildings:[ {id:'ruined_crypt', pos:{x:-470, z:-580}}, {id:'ruined_crypt', pos:{x:-475, z:-585}}, {id:'gravestone', pos:{x:-465, z:-575}}, {id:'gravestone', pos:{x:-468, z:-588}}, {id:'mausoleum_ruined', pos:{x:-480, z:-595}} ], npcs:[ {type:'ghost_npc', pos:{x:-472, z:-582}} ] }, { type:'shadow_cult_camp', name:"Campamento Sectario", buildings:[ {id:'dark_tent', pos:{x:-530, z:-620}}, {id:'dark_tent', pos:{x:-535, z:-625}}, {id:'evil_altar', pos:{x:-532, z:-622}}, {id:'cage_prop', pos:{x:-528, z:-618}} ], npcs:[ {type:'necromancer_npc', pos:{x:-531, z:-621}} ] } ]
        },
        // --- 9. Ciudad Abandonada (Sin cambios, ya detallada) ---
        {
            id: "abandoned_city", name: "Ciudad Abandonada", isSafeZone: false, center: { x: -350, z: -350 }, radius: 90, terrainHeight: 2.0, districts: [ { type: 'ruined_houses', name: "Casas en Ruinas", buildings: [ {id:'house_ruined', pos:{x:-340, z:-340}}, {id:'house_ruined', pos:{x:-360, z:-350}}, {id:'house_ruined', pos:{x:-345, z:-360}}, {id:'rubble', pos:{x:-355, z:-345}} ], npcs:[]}, { type: 'collapsed_tower', name: "Torre Derrumbada", buildings: [ {id:'tower_ruined', pos:{x:-360, z:-330}} ], npcs:[]}, { type: 'overgrown_square', name: "Plaza Cubierta", buildings: [ {id:'fountain_broken', pos:{x:-350, z:-350}}, {id:'broken_bench', pos:{x:-353, z:-352}} ], npcs:[]}, { type: 'sewer_entrance_area', name: "Entrada Alcantarilla", buildings: [{id:'sewer_grate', pos:{x:-350, z:-350}}], npcs:[]} ]
        },
    ];

    // --- DEFINICIÓN INDEPENDIENTE PARA POIs y ENTRADAS ---
    const specialLocationsDefinition = [
        // --- DUNGEON ENTRANCES ---
        { id: "perdition_mines_entrance", name: "Entrada Minas Perdición", type: "dungeon_entrance", pos: { x: -150, z: 200 }, targetLevel: "perdition_mines_1", visualDefId:"cave_entrance_dark" },
        { id: "ancient_crypt_entrance", name: "Entrada Cripta Ancestral", type: "dungeon_entrance", pos: { x: 550, z: -420 }, targetLevel: "ancient_crypt_1", visualDefId: "crypt_door_stone" },
        { id: "dragon_lair_entrance", name: "Entrada Guarida Dragón", type: "dungeon_entrance", pos: { x: 400, z: 600 }, targetLevel: "dragon_lair_1", visualDefId:"mountain_cave_large" },
        { id: "goblin_cave_entrance", name: "Entrada Cueva Goblin", type: "dungeon_entrance", pos: { x: -240, z: 90 }, targetLevel: "goblin_cave_1", visualDefId:"cave_entrance_small" },
        { id: "veril_mine_entrance", name: "Entrada Mina de Veril", type: "dungeon_entrance", pos: { x: -100, z: -400 }, targetLevel: "veril_mine_1", visualDefId:"mine_entrance_wooden" },
        { id: "eleusis_ruins_entrance", name: "Entrada Ruinas Eleusis", type: "dungeon_entrance", pos: { x: -500, z: -550 }, targetLevel: "eleusis_ruins_1", visualDefId:"ruined_archway" },
        { id: "orc_cave_entrance", name: "Entrada Caverna Orca", type: "dungeon_entrance", pos: { x: -270, z: 310 }, targetLevel: "orc_training_cave_1", visualDefId:"cave_entrance_reinforced" },
        { id: "sewer_grate_entrance", name: "Rejilla Alcantarilla", type: "dungeon_entrance", pos: { x: -350, z: -350 }, targetLevel: "abandoned_city_sewers_1", visualDefId:"sewer_grate" },

        // --- SHRINES ---
        { id: "altar_vida_1", name: "Altar de Vida", type: "shrine", pos: { x: 80, z: 95 }, visualDefId:"shrine_health", effect:"heal_player_full" },
        { id: "mana_spring", name: "Fuente de Maná", type: "shrine", pos: { x: -250, z: -250 }, visualDefId:"shrine_mana", effect:"regen_mana_buff" },
        { id: "shrine_of_war", name: "Altar de Guerra", type: "shrine", pos: { x: -290, z: 260 }, visualDefId: "shrine_strength", effect: "strength_buff_long" }, // En Arghal
        { id: "hermit_shrine", name: "Altar del Ermitaño", type: "shrine", pos: { x: 450, z: 100 }, visualDefId: "shrine_wisdom", effect: "xp_boost_short" }, // Cerca de montañas este?
        { id: "forgotten_altar", name: "Altar Olvidado", type: "shrine", pos: { x: -510, z: -570 }, visualDefId: "shrine_ruined", effect: "random_weak_curse" }, // En Eleusis
        { id: "resistance_shrine", name: "Altar Res. Mágica", type: "shrine", pos: {x: 150, z: 400}, visualDefId:"shrine_magic_res", effect:"magic_resist_buff"}, // Cerca Arkhein?

        // --- LANDMARKS ---
        { id: "wizard_tower_ruin", name: "Torre del Mago Caído", type: "landmark", pos: { x: 300, z: 300 }, visualDefId: "wizard_tower_ruined" },
        { id: "abandoned_farm", name: "Granja Abandonada", type: "landmark", pos: { x: 120, z: -150 }, visualDefId:"farmhouse_ruined"},
        { id: "elfic_grove", name: "Arboleda Élfica", type: "landmark", pos: { x: -450, z: -400 }, visualDefId:"elfic_tree_large"},
        { id: "bandit_camp_main", name: "Campamento Bandido", type: "landmark", pos: { x: 50, z: 280 }, visualDefId:"bandit_camp_props"},
        { id: "orc_watchtower", name: "Atalaya Orca", type: "landmark", pos: { x: -200, z: 300 }, visualDefId:"orc_watchtower_model"},
        { id: "lonely_lighthouse", name: "Faro Solitario", type: "landmark", pos: { x: 300, z: -300 }, visualDefId:"lighthouse_model"},
        { id: "shipwreck_coast", name: "Costa del Naufragio", type: "landmark", pos: { x: -450, z: 100 }, visualDefId:"shipwreck_model"},
        { id: "standing_stones", name: "Círculo de Piedras", type: "landmark", pos: { x: 150, z: -250 }, visualDefId:"standing_stones_model"},
        { id: "giant_skeleton", name: "Esqueleto Gigante", type: "landmark", pos: { x: -300, z: -100 }, visualDefId:"giant_skeleton_bones"},
        { id: "volcanic_vent", name: "Fumarola Volcánica", type: "landmark", pos: { x: 420, z: 620 }, visualDefId:"volcanic_vent_effect"},
        { id: "ancient_bridge", name: "Puente Antiguo", type: "landmark", pos: { x: -100, z: 10 }, visualDefId:"stone_bridge_ruined"},
        { id: "desert_oasis", name: "Oasis del Desierto", type: "landmark", pos: { x: -480, z: -230 }, visualDefId:"oasis_model"},
        { id: "waterfall_cave", name: "Cueva Tras Cascada", type: "landmark", pos: { x: 250, z: 450 }, visualDefId:"waterfall_with_cave"}, // Norte de Arkhein?
        { id: "graveyard_ullathorpe", name: "Cementerio de Ullathorpe", type: "landmark", pos: { x: -20, z: -140 }, visualDefId:"graveyard_small"}, // Sur de Ullathorpe
    ];

    // --- DEFINICIÓN INDEPENDIENTE PARA CARRETERAS ---
    const mainRoadsDefinition = [
        { points: [ {x: -50, z: -130}, {x: -60, z: -110}, {x:-55, z:-40}, {x: -20, z: 0}, {x: 80, z: 50}, {x: 150, z: 120}, {x: 190, z: 130} ] }, // Ullathorpe <-> Nix
        { points: [ {x: -75, z: -60}, {x: -100, z: -150}, {x: -130, z:-220}, {x: -145, z: -280}, {x: -148, z: -295} ] }, // Ullathorpe -> Forgat
        { points: [ {x: 180, z: 180}, {x: 100, z: 200}, {x: 50, z: 220}, {x: -50, z: 230}, {x: -150, z: 240}, {x: -280, z: 245}, {x: -295, z: 248} ] }, // Nix -> Arghal
        { points: [ {x: 220, z: 180}, {x: 280, z: 100}, {x: 350, z: 50}, {x: 380, z:-30}, {x: 395, z: -80}, {x: 400, z: -95} ] }, // Nix -> Penthar
        { points: [ {x: 0, z: 10}, {x: -10, z: -15}, {x: -25, z: -45}, {x: -45, z: -75}, {x: -50, z: -85} ] }, // Spawn Point -> Ullathorpe
        { points: [ {x: 220, z: 190}, {x: 300, z: 220}, {x: 400, z: 280}, {x: 500, z: 350}, {x: 580, z: 390}, {x: 600, z: 400} ] }, // Nix -> Eldoria
        { points: [ {x: -90, z: -60}, {x: -180, z: -30}, {x: -250, z: 0}, {x: -320, z: 20}, {x: -380, z: 40}, {x: -395, z: 48} ] }, // Ullathorpe -> Banderbill
        { points: [ {x: 180, z: 190}, {x: 150, z: 280}, {x: 105, z: 330}, {x: 100, z: 345} ] }, // Nix -> Arkhein
        { points: [ {x: -250, z: 260}, {x: -100, z: 300}, {x: 80, z: 340}, {x: 95, z: 348} ] }, // Arghal -> Arkhein
        { points: [ {x:-155, z:-310}, {x:-180, z:-380}, {x:-300, z:-450}, {x:-480, z:-580}, {x: -495, z: -595} ]}, // Forgat -> Eleusis
        { points: [ {x:410, z:-80}, {x:500, z:-50}, {x:580, z: 100}, {x:610, z:350}, {x: 615, z: 395} ]}, // Penthar -> Eldoria
        { points: [ {x:-160, z:-270}, {x:-155, z:-100}, {x:-150, z:50}, {x:-150, z:180}, {x:-150, z:195} ]}, // Forgat -> Minas Perdición
    ];

    // ============================================
    // === CONSTRUCCIÓN DEL OBJETO worldData FINAL ===
    // ============================================
    worldData = {
        // --- Parámetros, Biomas ---
        size: { width: WORLD_SIZE, depth: WORLD_SIZE },
        chunkSize: 64, resolution: 0.5,
        get numChunksX() { return Math.ceil(this.size.width / this.chunkSize); },
        get numChunksZ() { return Math.ceil(this.size.depth / this.chunkSize); },
        get verticesPerChunkEdge() { return Math.ceil(this.chunkSize * this.resolution); },
        biomeIdMap: { 0:'water', 1:'beach', 2:'grassland', 3:'forest', 4:'hills', 5:'mountains', 6:'desert', 7:'snow', 8:'ruin', 9:'city', 10:'road', 11:'swamp', 12:'taiga', 13:'forest_dense', 14:'mountains_rocky', 15:'water_shallow', 16: 'forest_elfic', 17: 'island_special', 18: 'mountains_deep' },
        getBiomeName(id) { return this.biomeIdMap[id] || 'grassland'; },
        getBiomeId(name) { return parseInt(Object.keys(this.biomeIdMap).find(key => this.biomeIdMap[key] === name) || '2', 10); },
        biomeColors: { water: 0x2a5e8f, beach: 0xfaf0e6, grassland: 0x6b8e23, forest: 0x228b22, hills: 0x9e8a70, mountains: 0xacb2b8, desert: 0xedc9af, snow: 0xfffafa, ruin: 0x778899, city: 0xa0a0a0, road: 0xaa8866, swamp: 0x556b2f, taiga: 0x7aa095, forest_dense: 0x186a18, mountains_rocky: 0x888c90, water_shallow: 0x60a0b0, forest_elfic: 0x33aa88, island_special: 0xffccaa, mountains_deep: 0x606570 },

        // --- ASIGNACIÓN DE ARRAYS PREDEFINIDOS ---
        cities: citiesDefinition,
        mainRoads: mainRoadsDefinition,
        roadSegments: [], // Llenado por ChunkManager.init
        specialLocations: specialLocationsDefinition,
      dungeonDefinitions: dungeonDefinitions, // <<< AÑADIR ESTO >>>

        // --- ZONAS DE SPAWN (CON IIFE CORREGIDO y DENSIDAD AJUSTABLE) ---
        enemySpawns: (() => {
            const spawns = [];
            const initialSpawnPoint = { x: 0, z: 125 };
            const initialSafeRadiusSq = 40 * 40;
            const DENSITY_MULTIPLIER = 0.4; // <-- AJUSTA ESTE VALOR PARA DENSIDAD (0.1 a 1.0)

            const isSpawnValid = (center) => {
                if ((center.x - initialSpawnPoint.x)**2 + (center.z - initialSpawnPoint.z)**2 < initialSafeRadiusSq) { return false; }
                for (const city of citiesDefinition) { // <-- Usa la variable predefinida
                    if (city.isSafeZone && (center.x - city.center.x)**2 + (center.z - city.center.z)**2 < (city.radius * 0.9)**2) { return false; }
                }
                return true;
            };

            // Definición de Zonas (Completa)
            const zoneDefs = [
                // Zona Inicial (Nivel 1-5)
                { type: 'ant', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: 15, z: 45}, radius: 30 },
                { type: 'bat', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: -25, z: 50}, radius: 35 },
                { type: 'snake', count: Math.max(1, Math.floor(22 * DENSITY_MULTIPLIER)), center: {x: 35, z: 25}, radius: 40 },
                { type: 'rooster', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: -30, z: 20}, radius: 30 },
                { type: 'rat', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: 40, z: 10}, radius: 25 },
                { type: 'wolf', count: Math.max(1, Math.floor(7 * DENSITY_MULTIPLIER)), center: {x: -55, z: -15}, radius: 40 },
                { type: 'goblin', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 60, z: 60}, radius: 35 },

                // Bosque Oeste/Sur Ullathorpe (Nivel 3-8)
                { type: 'wolf', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -80, z: -40}, radius: 45 },
                { type: 'wolfang', count: 1, center: {x: -95, z: -55}, radius: 10, isUnique: true }, // Jefes no se multiplican
                { type: 'goblin', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: -100, z: -120}, radius: 40 },
                { type: 'bear', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: -150, z: -50}, radius: 55 },
                { type: 'spider', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x:-120, z:-80}, radius: 35 },
                { type: 'bandit', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x:-130, z:-150}, radius: 30 },

                // Cerca Cueva Goblin (Noroeste Ullathorpe - Nivel 4-9)
                { type: 'goblin', count: Math.max(1, Math.floor(25 * DENSITY_MULTIPLIER)), center: {x: -240, z: 110}, radius: 35 },
                { type: 'rat', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -230, z: 100}, radius: 30 },
                { type: 'spider', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: -250, z: 120}, radius: 25 },
                { type: 'wolf', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x:-260, z:80}, radius: 35},

                // Camino Norte / Camp. Bandidos (Nivel 5-12)
                { type: 'bandit', count: Math.max(1, Math.floor(30 * DENSITY_MULTIPLIER)), center: {x: 50, z: 280}, radius: 60 },
                { type: 'assassin', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: 70, z: 300}, radius: 40 },
                { type: 'wolf', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 30, z: 260}, radius: 40 },
                { type: 'orc_hunter', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: 90, z: 250}, radius: 30 },

                // Camino a Penthar / Ruinas (Este - Nivel 5-14)
                { type: 'skeleton', count: Math.max(1, Math.floor(40 * DENSITY_MULTIPLIER)), center: {x: 300, z: 100}, radius: 70 },
                { type: 'zombie', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: 320, z: 80}, radius: 45 },
                { type: 'ghoul', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: 350, z: 50}, radius: 40 },
                { type: 'skeleton_warrior', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 330, z: 120}, radius: 35 },
                { type: 'ghost', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: 300, z: 300}, radius: 30 },

                // Afueras Arghal (Territorio Orco - Nivel 7-20)
                { type: 'orc_hunter', count: Math.max(1, Math.floor(35 * DENSITY_MULTIPLIER)), center: {x: -250, z: 280}, radius: 55 },
                { type: 'orc_protector', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -260, z: 270}, radius: 40 },
                { type: 'goblin', count: Math.max(1, Math.floor(25 * DENSITY_MULTIPLIER)), center: {x: -310, z: 300}, radius: 35 },
                { type: 'orc_bewitched', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: -330, z: 230}, radius: 30 },
                { type: 'orc_warrior', count: Math.max(1, Math.floor(18 * DENSITY_MULTIPLIER)), center: {x:-280, z: 250}, radius: 40 },
                { type: 'troll', count: 2, center: {x:-280, z:300}, radius: 15, respawn: UNIQUE_ENEMY_RESPAWN_TIME }, // No multiplicar jefes
                { type: 'orc_farmer', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: -340, z: 260}, radius: 30 },

                // Cerca Forgat / Minas Perdición (Montañas - Nivel 8-22)
                { type: 'spider', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: -180, z: -280}, radius: 35 },
                { type: 'skeleton', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -130, z: -320}, radius: 40 },
                { type: 'bat', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: -160, z: -260}, radius: 30 },
                { type: 'golem_stone', count: 3, center: {x: -180, z: -330}, radius: 30, respawn: UNIQUE_ENEMY_RESPAWN_TIME * 0.8 },
                { type: 'skeleton_warrior', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: -120, z: -300}, radius: 30 },
                { type: 'lizardman', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: -200, z: -310}, radius: 35 },
                { type: 'giant_scorpion', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: -100, z: -350}, radius: 25 },

                // Zona Asesinos (Este/Sureste - Nivel 6-15)
                { type: 'assassin', count: Math.max(1, Math.floor(30 * DENSITY_MULTIPLIER)), center: {x: 250, z: -100}, radius: 55 },
                { type: 'bandit', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: 270, z: -120}, radius: 40 },
                { type: 'rat', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center:{x: 230, z:-80}, radius: 25},

                // Zona Lord Duendes (Noroeste - Nivel 6-16)
                { type: 'lord_goblin', count: Math.max(1, Math.floor(25 * DENSITY_MULTIPLIER)), center: {x: -200, z: 150}, radius: 60 },
                { type: 'goblin', count: Math.max(1, Math.floor(30 * DENSITY_MULTIPLIER)), center: {x: -220, z: 170}, radius: 45 },
                { type: 'spider', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: -180, z: 160}, radius: 35 },
                { type: 'orc_hunter', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: -160, z: 140}, radius: 30 },

                // Zona Granja / Campos Sureste (Nivel 6-14)
                { type: 'orc_farmer', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x: 120, z: -110}, radius: 30 },
                { type: 'orc_bewitched', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: 110, z: -130}, radius: 20 },
                { type: 'orc_hunter', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 140, z: -120}, radius: 35 },
                { type: 'orc_protector', count: 3, center: {x: 100, z: -100}, radius: 18 }, // Pocos protectores
                { type: 'skeleton', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: 130, z: -140}, radius: 40 },
                { type: 'rooster', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x:150, z:-100}, radius: 25},

                // Exterior Cripta Ancestral (Sureste Lejano - Nivel 15-28)
                { type: 'skeleton_warrior', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: 540, z: -400}, radius: 45 },
                { type: 'ghoul', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 560, z: -430}, radius: 40 },
                { type: 'ghost', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: 530, z: -440}, radius: 35 },
                { type: 'mummy', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 570, z: -410}, radius: 30 },
                { type: 'lich', count: 1, center: {x: 555, z: -425}, radius: 15, isUnique: true },

                // Cerca de Eleusis (Ruinas Peligrosas - Nivel 25-40+)
                { type: 'mummy', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: -480, z: -570}, radius: 50 },
                { type: 'lich', count: 1, center: {x: -500, z: -600}, radius: 10, isUnique: true }, // JEFE
                { type: 'skeleton_warrior', count: Math.max(1, Math.floor(18 * DENSITY_MULTIPLIER)), center: {x: -520, z: -580}, radius: 55 },
                { type: 'ghoul', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -460, z: -620}, radius: 45 },
                { type: 'ghost', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: -530, z: -590}, radius: 35 },
                { type: 'demon', count: 1, center: {x: -470, z: -640}, radius: 10, isUnique: true },

                // Montañas / Guarida Dragón (Nivel 35-45+)
                { type: 'drake', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: 380, z: 580}, radius: 60 },
                { type: 'giant_scorpion', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 420, z: 560}, radius: 45 },
                { type: 'golem_iron', count: 3, center: {x: 350, z: 620}, radius: 30, respawn: UNIQUE_ENEMY_RESPAWN_TIME * 0.9 },
                { type: 'minotaur', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x: 450, z: 610}, radius: 40 },
                { type: 'cyclops', count: 4, center: {x: 360, z: 550}, radius: 35 },
                { type: 'ogre', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: 470, z: 580}, radius: 35 },

                // Bosque Norte (Nivel 10-20)
                { type: 'bear', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x: 50, z: 450}, radius: 50 },
                { type: 'wolf', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: 0, z: 400}, radius: 60 },
                { type: 'orc_hunter', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: -50, z: 420}, radius: 40 },
                { type: 'harpy', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: 20, z: 500}, radius: 35 },

                // Colinas Centrales (Nivel 8-18)
                { type: 'bandit', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 150, z: 50}, radius: 45 },
                { type: 'lizardman', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: 100, z: 0}, radius: 35 },
                { type: 'goblin', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: 180, z: 80}, radius: 30 },
                { type: 'skeleton', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: 50, z: -50}, radius: 40 },

                // Costa Oeste (Nivel 12-22) - Cerca Banderbill
                { type: 'lizardman', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: -450, z: 0}, radius: 50 },
                { type: 'harpy', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x: -430, z: 150}, radius: 40 },

                // Zona Desértica (Suroeste - Nivel 15-25)
                { type: 'giant_scorpion', count: Math.max(1, Math.floor(12 * DENSITY_MULTIPLIER)), center: {x: -400, z: -200}, radius: 50 },
                { type: 'snake', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -380, z: -220}, radius: 35 },
                { type: 'lizardman', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: -420, z: -250}, radius: 40 },
                { type: 'mummy', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: -450, z: -180}, radius: 30 },
                { type: 'bandit', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x: -350, z: -150}, radius: 25 },

                // Pantano (Sur - Nivel 10-22)
                { type: 'snake', count: Math.max(1, Math.floor(20 * DENSITY_MULTIPLIER)), center: {x: -50, z: -400}, radius: 55 },
                { type: 'spider', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: -70, z: -420}, radius: 35 },
                { type: 'lizardman', count: Math.max(1, Math.floor(10 * DENSITY_MULTIPLIER)), center: {x: -30, z: -430}, radius: 40 },
                { type: 'zombie', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: 0, z: -420}, radius: 25 },

                // Taiga/Nieve (Norte Lejano - Nivel 20-35)
                { type: 'wolf', count: Math.max(1, Math.floor(15 * DENSITY_MULTIPLIER)), center: {x: 0, z: 600}, radius: 60 },
                { type: 'bear', count: Math.max(1, Math.floor(8 * DENSITY_MULTIPLIER)), center: {x: 50, z: 620}, radius: 45 },
                { type: 'elemental_ice', count: Math.max(1, Math.floor(5 * DENSITY_MULTIPLIER)), center: {x: -50, z: 650}, radius: 35 },
                { type: 'troll', count: 3, center: {x: 20, z: 630}, radius: 30 }, // Más trolls
                { type: 'skeleton_warrior', count: Math.max(1, Math.floor(6 * DENSITY_MULTIPLIER)), center: {x: -80, z: 580}, radius: 30 },
            ];

            // Filtrar spawns inválidos
            zoneDefs.forEach(zoneDef => {
                if (zoneDef.spawns) { zoneDef.spawns.forEach(innerSpawn => { const finalCount = Math.max(1, Math.floor((innerSpawn.count || 1) * DENSITY_MULTIPLIER)); if (isSpawnValid(innerSpawn.center)) spawns.push({ ...innerSpawn, count: finalCount, respawn: innerSpawn.respawn || (enemyDefinitions[innerSpawn.type]?.isUnique ? UNIQUE_ENEMY_RESPAWN_TIME : ENEMY_RESPAWN_TIME) }); }); }
                else { const finalCount = Math.max(1, Math.floor((zoneDef.count || 1) * DENSITY_MULTIPLIER)); if (isSpawnValid(zoneDef.center)) { spawns.push({ ...zoneDef, count: finalCount, respawn: zoneDef.respawn || (enemyDefinitions[zoneDef.type]?.isUnique ? UNIQUE_ENEMY_RESPAWN_TIME : ENEMY_RESPAWN_TIME) }); } }
            });

            console.log(`Total enemy spawn definitions generated (Density: ${DENSITY_MULTIPLIER}): ${spawns.length}`);
            return spawns;
        })(), // Fin IIFE

        // --- Datos Cacheados ---
        chunkObjects: new Map(),
        chunkEnemySpawnPoints: new Map(),
    };

    // --- Post-procesamiento icon_type ---
    Object.values(itemDefinitions).forEach(def => { if(!def.icon || def.icon.length < 3 || !def.icon.startsWith('<img')) def.icon_type = 'text'; else def.icon_type = 'html'; });
    Object.values(spellDefinitions).forEach(def => { if(!def.icon || def.icon.length < 3 || !def.icon.startsWith('<img')) def.icon_type = 'text'; else def.icon_type = 'html'; });

    // --- BUFF DATA (Definiciones Globales) ---
    window.STRENGTH_BUFF_DATA = { id:'strength_buff', name:'Fuerza Aumentada', icon:'fa-dumbbell', duration:60, statsModifiers:{strength: 3}, class:'status-buff', description:'+3 Fuerza (60s).'};
    window.AGILITY_BUFF_DATA = { id:'agility_buff', name:'Agilidad Aumentada', icon:'fa-shoe-prints', duration:60, statsModifiers:{dexterity: 3}, class:'status-buff', description:'+3 Destreza (60s).'};
    window.STAGGER_EFFECT_DATA = { id: 'stagger', name: 'Aturdido', icon: 'fa-star', duration: 1.5, onApply: (t) => { t.aiState = 'staggered'; if(t.mixer) t.mixer.stopAllAction(); }, onEnd: (t) => { if (!t.isDead) t.aiState = t.isAggro ? 'chasing' : 'idle'; }, class: 'status-stun', description: 'Incapacitado.' };
    // Añadir más efectos base aquí

    console.log("Definiciones del juego pobladas completamente.");
} // --- FIN initGameDataDefinitions ---


  function openCreditsPanel() {
        const panel = domCache['credits-panel'];
        const startScreen = domCache['start-screen'];
        if (panel instanceof HTMLElement && startScreen instanceof HTMLElement) {
            closeOtherModals(); // Cierra otros si están abiertos
            startScreen.style.display = 'none';
            panel.style.display = 'flex';
            gameState.isCreditsPanelOpen = true;
            AudioManager.playSound('ui_open', 0.4);
        }
    }

    function closeCreditsPanel() {
        const panel = domCache['credits-panel'];
        const startScreen = domCache['start-screen'];
        if (panel instanceof HTMLElement && startScreen instanceof HTMLElement) {
            panel.style.display = 'none';
            startScreen.style.display = 'flex'; // Volver al menú principal
            gameState.isCreditsPanelOpen = false;
            AudioManager.playSound('ui_close', 0.4);
        }
    }

    function openManualPanel() {
        const panel = domCache['manual-panel'];
        const startScreen = domCache['start-screen'];
        if (panel instanceof HTMLElement && startScreen instanceof HTMLElement) {
            closeOtherModals();
            startScreen.style.display = 'none';
            panel.style.display = 'flex';
            gameState.isManualPanelOpen = true;
            // Asegurar que la primera pestaña esté activa al abrir
            switchManualTab(domCache.manualTabButtons?.[0]?.dataset.manualTab || 'controls');
            AudioManager.playSound('ui_open', 0.4);
        }
    }

    function closeManualPanel() {
        const panel = domCache['manual-panel'];
        const startScreen = domCache['start-screen'];
        if (panel instanceof HTMLElement && startScreen instanceof HTMLElement) {
            panel.style.display = 'none';
            startScreen.style.display = 'flex';
            gameState.isManualPanelOpen = false;
            AudioManager.playSound('ui_close', 0.4);
        }
    }

    /** Cambia la pestaña visible en el panel del manual */
    function switchManualTab(tabId) {
        if (!tabId || !domCache.manualTabButtons) return;
        const manualPanel = domCache['manual-panel'];
        if (!(manualPanel instanceof HTMLElement)) return;

        let tabActivated = false;
        // Desactivar botones y contenido anterior
        domCache.manualTabButtons.forEach(button => {
            if (button instanceof HTMLElement) button.classList.remove('active');
        });
        manualPanel.querySelectorAll('.manual-content-section').forEach(section => {
            if (section instanceof HTMLElement) section.classList.remove('active');
        });

        // Activar botón y contenido nuevos
        const targetButton = manualPanel.querySelector(`.manual-tab-button[data-manual-tab="${tabId}"]`);
        const targetContent = document.getElementById(`manual-${tabId}-content`);

        if (targetButton instanceof HTMLElement) {
             targetButton.classList.add('active');
             tabActivated = true;
        }
        if (targetContent instanceof HTMLElement) {
            targetContent.classList.add('active');
            targetContent.scrollTop = 0; // Ir al inicio del contenido
            tabActivated = true;
        }

        // Sonido solo si se cambió de pestaña (evitar sonido al abrir el panel)
        // if (tabActivated && gameState.isManualPanelOpen) { // Solo si el panel ya está abierto
        //     AudioManager.playSound('ui_confirm', 0.25);
        // }
    }

    /** Cierra todos los paneles modales abiertos (incluyendo los nuevos) */
    function closeOtherModals() {
        if (gameState.isCharacterSheetOpen) toggleCharacterSheet();
        if (gameState.isShopOpen) closeShop();
        if (gameState.isInDialog) closeDialog();
        if (gameState.isOptionsMenuOpen) closeOptionsMenu();
        if (gameState.isLargeMapOpen) closeLargeMap();
        if (gameState.isEquipmentModalOpen) closeEquipmentModal();
        if (gameState.isCraftingModalOpen) closeCraftingModal();
        if (gameState.isQuestsModalOpen) closeQuestsModal();
        if (gameState.isSkillsModalOpen) closeSkillsModal();
        if (currentDropItemId !== null) hideDropQuantityPrompt();
        // *** CERRAR NUEVOS PANELES ***
        if (gameState.isCreditsPanelOpen) closeCreditsPanel();
        if (gameState.isManualPanelOpen) closeManualPanel();
        // *** FIN CIERRE NUEVOS PANELES ***
        hideTooltip();
    }

    // --- Inicialización Principal ---
    window.addEventListener('load', init);

    </script>
</body>
</html>
